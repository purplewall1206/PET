#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>



// net/tipc/crypto.c
// static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)
// {
// 	struct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;
// 	struct tipc_aead_key *skey = NULL;
// 	u16 key_gen = msg_key_gen(hdr);
// 	u16 size = msg_data_sz(hdr);
// 	u8 *data = msg_data(hdr);
//     ...
// 	skey = kmalloc(size, GFP_ATOMIC);
//     ...
// 2324	skey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME))); // skey + 0x20
// 2325	memcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);
// 2326	memcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),
// 	       skey->keylen); // real oob   skey->key: 0x24(%r15),  
// 	pr_info("tipc_crypto_key_rcv:skey:%016lx, size:0x%x, skey->key:%016lx, keylen:0x%x\n", (unsigned long)skey, size, (unsigned long)&(skey->key), skey->keylen);


// ffffffff81dbbab6 <tipc_crypto_msg_rcv.cold>:
// ...
// ffffffff81dbbb13:       49 8d 4f 24             lea    0x24(%r15),%rcx
// ffffffff81dbbb17:       48 8d 70 24             lea    0x24(%rax),%rsi
// ffffffff81dbbb1b:       44 89 44 24 04          mov    %r8d,0x4(%rsp)
// ffffffff81dbbb20:       48 89 cf                mov    %rcx,%rdi
// ffffffff81dbbb23:       e8 f8 44 00 00          call   ffffffff81dc0020 <__memcpy>


// ffffffff81d42089 <tipc_crypto_msg_rcv.cold>:
// ...
// ffffffff81d420ea:       49 8d 4e 24             lea    0x24(%r14),%rcx
// ffffffff81d420ee:       48 8d 70 24             lea    0x24(%rax),%rsi
// ffffffff81d420f2:       44 89 44 24 0c          mov    %r8d,0xc(%rsp)
// ffffffff81d420f7:       48 89 cf                mov    %rcx,%rdi
// ffffffff81d420fa:       e8 21 5a 00 00          call   ffffffff81d47b20 <__memcpy>      ffffffff81d420fb: R_X86_64_PLT32        memcpy-0x4


// python -c 'print(hex(0xffffffff81dbbb23-0xffffffff81dbbab6))'
// python -c 'print(hex(0xffffffff81d420fa-0xffffffff81d42089))'
SEC("kprobe/tipc_crypto_msg_rcv.cold+0x71")
int BPF_KPROBE(prog1)
{
    // check len
    u64 addr_skey_key = ctx->di;
    u64 skey_keylen = ctx->dx;
    u64 skey_len = addr_skey_key + skey_keylen;

    u64 addr_start = bpf_get_slab_start(addr_skey_key);
    u32 addr_len = bpf_get_buff_len(addr_skey_key);
    u64 addr_end = addr_start + addr_len;
    bool oob = (skey_len > addr_end);
    bpf_printk("tipc_crypto_msg_rcv.cold: skey->key: 0x%lx, 0x%lx\n", addr_skey_key, skey_len);
    bpf_printk("tipc_crypto_msg_rcv.cold: skey:      0x%lx, 0x%lx\n", addr_start, addr_end);
    bpf_printk("tipc_crypto_msg_rcv.cold: OOB : %d\n", oob);
    return 0;
}


// SEC("kprobe/__free_pages")
// int BPF_KPROBE()



char LICENSE[] SEC("license") = "Dual BSD/GPL";


// ffffffff81d92d1b <tipc_crypto_msg_rcv.cold>:


// 0xffffffff81d92d84   2326      2      1   0             0


// 0xffffffff81d92d77   2326      2      1   0             0
// 0xffffffff81d92d7c   2326      2      1   0             0
// 0xffffffff81d92d80   2326     46      1   0             0
// 0xffffffff81d92d84   2326      2      1   0             0