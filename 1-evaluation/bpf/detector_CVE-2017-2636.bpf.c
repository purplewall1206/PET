#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u64); // addr
    __type(value, u32); 
} race_points SEC(".maps");

// drivers/tty/n_hdlc.c

// static int n_hdlc_tty_ioctl(struct tty_struct *tty, struct file *file,
// static void flush_tx_queue(struct tty_struct *tty) // inlined
// 175	while ((buf = n_hdlc_buf_get(&n_hdlc->tx_buf_list)))
// 176		n_hdlc_buf_put(&n_hdlc->tx_free_buf_list, buf);

// ffffffff81704fc0 <n_hdlc_tty_ioctl>:
// ...
// ffffffff817050d8:       48 8b 14 24             mov    (%rsp),%rdx
// ffffffff817050dc:       48 8d 4b 38             lea    0x38(%rbx),%rcx
// ffffffff817050e0:       4c 89 f7                mov    %r14,%rdi
// ffffffff817050e3:       48 89 c6                mov    %rax,%rsi
//    [0xffffffff817050d7, 0xffffffff81705101): DW_OP_fbreg -72





// python -c 'print(hex(0xffffffff817050d8-0xffffffff81704fc0))'
SEC("kprobe/n_hdlc_tty_ioctl+0x118")
int BPF_KPROBE(p0) {
    u64 k = 0;
    u64 addr = ctx->sp;
    bpf_core_read(&k, 8, addr);
    u64 v = 0;
    int err = bpf_map_update_elem(&race_points, &k, &v, BPF_NOEXIST);
    if (err < 0) {
        bpf_printk("race condition in tcp_send_challenge_ack.constprop.0+0x5d\n");
    }
    return 0;
}

// python -c 'print(hex(0xffffffff817050dc-0xffffffff81704fc0))'
SEC("kprobe/n_hdlc_tty_ioctl+0x11c")
int BPF_KPROBE(v0) {
    u64 k = 0;
    u64 addr = ctx->sp;
    bpf_core_read(&k,  8, addr);
    int err = bpf_map_delete_elem(&race_points, &k);
    return 0;
}






// drivers/tty/n_hdlc.c
// static void n_hdlc_send_frames(struct n_hdlc *n_hdlc, struct tty_struct *tty)
// 284	tbuf = n_hdlc_buf_get(&n_hdlc->tx_buf_list);

// ffffffff81704a80 <n_hdlc_send_frames>:
// ...
// ffffffff81704aeb:       49 89 c7                mov    %rax,%r15 <--
// ffffffff81704aee:       48 85 c0                test   %rax,%rax
// ffffffff81704af1:       75 71                   jne    ffffffff81704b64 <n_hdlc_send_frames+0xe4>
//                    [0xffffffff81704aee, 0xffffffff81704af8): DW_OP_reg0 RAX
//                    [0xffffffff81704af8, 0xffffffff81704b5b): DW_OP_reg15 R15
// python -c 'print(hex(0xffffffff81704aeb-0xffffffff81704a80))'
SEC("kprobe/n_hdlc_send_frames+0x6b")
int BPF_KPROBE(p1) {
    u64 k = ctx->bp + 0x310;
    u64 v = 0;
    int err = bpf_map_update_elem(&race_points, &k, &v, BPF_NOEXIST);
    if (err < 0) {
        bpf_printk("race condition in tcp_send_challenge_ack.constprop.0+0x5d\n");
    }
    return 0;
}


// python -c 'print(hex(0xffffffff81704aee-0xffffffff81704a80))'
SEC("kprobe/n_hdlc_send_frames+0x6e")
int BPF_KPROBE(prog0) {
    u64 k = ctx->bp + 0x310;
    int err = bpf_map_delete_elem(&race_points, &k);
    return 0;
}

char LICENSE[] SEC("license") = "Dual BSD/GPL";
