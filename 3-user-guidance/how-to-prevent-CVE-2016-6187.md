# CVE-2016-6187: Design overview: pipeline

listing1

```c
KASAN: slab-out-of-bounds in apparmor_setprocattr+0x116/0x590
Write of size 1 at addr ffff888007449c80
Call Trace:
    apparmor_setprocattr+0x116/0x590
    proc_pid_attr_write+0x15f/0x1e0

// source code
static int apparmor_setprocattr(const char *name, void *value,
				size_t size)    
637	if (args[size - 1] != '\0') {
		// ....
643		if (size == PAGE_SIZE)
644			return -EINVAL;
645		args[size] = '\0';  // off-by-one-byte       

// sanitized kernel
lea    0x0(%r13,%r12,1),%r14
mov    %r14,%rdi
call   ffffffff814a06b0 <__asan_store1>
movb   $0x0,(%r14)

// native kernel
movb   $0x0,(%rsi,%rdx,1)
```

 













reference:

- [source code](./CVE-2016-6188-source.md)
- [sanitized binary](./CVE-2016-6187-binary-sanitized.md)
- [native binary](./CVE-2016-6187-binary.md)
- [sanitized dwarf](./CVE-2016-6187-dwarf-sanitized.md)
- [native dwarf](./CVE-2016-6187-dwarf.md)
- dwarf debug-line/frame info are too long, this article shows the useful parts.


## 0. dwarf information analysis

Dwarf information is designed for transformation between source code and binary during debugging.

There are three types of debugging information in the Dwarf that are mainly used by our analysis tools

- debug-info: record DIEs, we can find function range, varible type and location, members of structures
    The basic unit of dwarf is 'Dwarf Information Entry'(DIE), where compiler records the profile of elements in source code, e.g.  functions, structures, structure member offset, varibles, inline.
    
    DIEs also have their children DIEs, generally, function DIEs' children are varibles and inlined Functions, Structure DIEs' children are structure members.
```
0x067d894a: DW_TAG_subprogram
              DW_AT_name	("apparmor_setprocattr")
              DW_AT_decl_file	("/root/linux-5.15-vulns-for-SANITIZERS/out-kasan/../security/apparmor/lsm.c")
              DW_AT_decl_line	(624)
              DW_AT_decl_column	(0x0c)
              DW_AT_prototyped	(true)
              DW_AT_type	(0x067a2b68 "int")
              DW_AT_low_pc	(0xffffffff8180b5b0)
              DW_AT_high_pc	(0xffffffff8180bb31)
              DW_AT_frame_base	(DW_OP_call_frame_cfa)
              DW_AT_GNU_all_call_sites	(true)
              DW_AT_sibling	(0x067d9993)

0x067d8982:   DW_TAG_formal_parameter
                DW_AT_name	("value")
                DW_AT_decl_file	("/root/linux-5.15-vulns-for-SANITIZERS/out-kasan/../security/apparmor/lsm.c")
                DW_AT_decl_line	(624)
                DW_AT_decl_column	(0x39)
                DW_AT_type	(0x067a2fbf "void *")
                DW_AT_location	(0x01b236bf: 
                   [0xffffffff8180b5b0, 0xffffffff8180b6a5): DW_OP_reg4 RSI
                   [0xffffffff8180b6a5, 0xffffffff8180b781): DW_OP_reg13 R13

0x067d89ac:   DW_TAG_variable
                DW_AT_name	("command")
                DW_AT_decl_file	("/root/linux-5.15-vulns-for-SANITIZERS/out-kasan/../security/apparmor/lsm.c")
                DW_AT_decl_line	(628)
                DW_AT_decl_column	(0x08)
                DW_AT_type	(0x067a2d2c "char *")
                DW_AT_location	(0x01b23815: 
                   [0xffffffff8180b6f0, 0xffffffff8180b6fd): DW_OP_reg0 RAX
                   [0xffffffff8180b6fd, 0xffffffff8180b787): DW_OP_reg15 R15

0x067d89c1:   DW_TAG_variable 
                DW_AT_name	("args")
                DW_AT_decl_file	("/root/linux-5.15-vulns-for-SANITIZERS/out-kasan/../security/apparmor/lsm.c")
                DW_AT_decl_line	(628)
                DW_AT_decl_column	(0x12)
                DW_AT_type	(0x067a2d2c "char *")
                ==========here the args is optimized and not exist, but if it exists, it will be==============
                DW_AT_location  (DW_OP_fbreg -392)
                
0x067d89ce:   DW_TAG_variable
                DW_AT_name	("arg_size")
                DW_AT_decl_file	("/root/linux-5.15-vulns-for-SANITIZERS/out-kasan/../security/apparmor/lsm.c")
                DW_AT_decl_line	(629)
                DW_AT_decl_column	(0x09)
                DW_AT_type	(0x067a2e12 "size_t")
                DW_AT_location	(0x01b238a7: 
                   [0xffffffff8180b718, 0xffffffff8180b781): DW_OP_breg13 R13+0, DW_OP_breg14 R14+0, DW_OP_minus, DW_OP_breg12 R12+0, DW_OP_plus, DW_OP_stack_value

```
    in the figure, `DW_TAG_subprogram` means the type of DIE is a function, where we can obtain the name, location, return type and range of the function. 

    There is a 2-space indent in `DW_TAG_formal_parameter`, means that argument `value` is a child DIE of function `apparmor_setprocattr`.
    The location of `value` is in register `RSI` when the bianry range is [0xffffffff814de980, 0xffffffff814dea1a)

    similar to `value`, `command`, `args` and `arg_size` with `DW_TAG_variable` tag are function's local varibles. but the location of  `args` is not exist, the reason may be the compiler O2 optimization. if the `args` exist, the location will be `DW_OP_fbreg -392`(KASAN stack redzone), it means the location is on the stack with a -392 offset to the function stack frame begin.
    
    The location of `arg_size` is `DW_OP_breg13 R13+0`, it means that the varible is in the memory, and its address is stored in `R13`.

- debug-line: record the translation table between instruction address to kernel 

```
file_names[  1]:
           name: "lsm.c"
      dir_index: 1
       mod_time: 0x00000000
         length: 0x00000000

Address            Line   Column File   ISA Discriminator Flags
------------------ ------ ------ ------ --- ------------- -------------
0xffffffff8180b6a6    637      5      1   0             0
0xffffffff8180b6ac    643      3      1   0             0  is_stmt
0xffffffff8180b6ac    643      6      1   0             0
0xffffffff8180b6b9    645      3      1   0             0  is_stmt
0xffffffff8180b6b9    645      7      1   0             0
0xffffffff8180b6be    645     14      1   0             0
0xffffffff8180b6ca    649      2      1   0             0  is_stmt
0xffffffff8180b6ca    649      9      1   0             0
0xffffffff8180b6d2    650     12      1   0             0
0xffffffff8180b6de    649      7      1   0             0
0xffffffff8180b6e3    650      2      1   0             0  is_stmt
```

- debug-frame: get the CFA(call frame address/fbreg), here we know the store address of `args` near the trigger point is `RSP+392-392=RSP`,   because the location of stack frame near the trigger point is `CFA=RSP+392`, 

```
  0xffffffff8180b5b0: CFA=RSP+8: RIP=[CFA-8]
  0xffffffff8180b5b7: CFA=RSP+16: R15=[CFA-16], RIP=[CFA-8]
  0xffffffff8180b5c8: CFA=RSP+24: R14=[CFA-24], R15=[CFA-16], RIP=[CFA-8]
  0xffffffff8180b5ca: CFA=RSP+32: R13=[CFA-32], R14=[CFA-24], R15=[CFA-16], RIP=[CFA-8]
  0xffffffff8180b5cc: CFA=RSP+40: R12=[CFA-40], R13=[CFA-32], R14=[CFA-24], R15=[CFA-16], RIP=[CFA-8]
  0xffffffff8180b5cd: CFA=RSP+48: RBP=[CFA-48], R12=[CFA-40], R13=[CFA-32], R14=[CFA-24], R15=[CFA-16], RIP=[CFA-8]
  0xffffffff8180b5d1: CFA=RSP+56: RBX=[CFA-56], RBP=[CFA-48], R12=[CFA-40], R13=[CFA-32], R14=[CFA-24], R15=[CFA-16], RIP=[CFA-8]
  0xffffffff8180b5d8: CFA=RSP+392: RBX=[CFA-56], RBP=[CFA-48], R12=[CFA-40], R13=[CFA-32], R14=[CFA-24], R15=[CFA-16], RIP=[CFA-8]
```






-----------------------------------------

## 1. syzkaller report

```
[   40.661480] ==================================================================
[   40.663185] BUG: KASAN: slab-out-of-bounds in apparmor_setprocattr+0x116/0x590
[   40.664938] Write of size 1 at addr ffff888007449c80 by task poc_cfh_baselin/1140

[   40.668938] Call Trace:
[   40.672164]  apparmor_setprocattr+0x116/0x590
[   40.674617]  proc_pid_attr_write+0x15f/0x1e0


[   40.684604] Allocated by task 408:
[   40.684953]  kasan_save_stack+0x1b/0x40
[   40.685380]  __kasan_kmalloc+0x7c/0x90
[   40.685787]  ext4_htree_store_dirent+0x56/0x200
```

critical information
- the vulnerability type is `slab-out-of-bound` write
- trigger point is in `apparmor_setprocattr+0x116`
- in the file `security/apparmor/lsm.c`


## 2. analysis trigger point in sanitized kernel

### 2.1 get source code from `apparmor_setprocattr+0x116`

first of all, the address of `apparmor_setprocattr+0x116` is 0xffffffff8180b6c6, a `mov` instruction

```c
ffffffff8180b5b0 <apparmor_setprocattr>:
....
ffffffff8180b6b9:       4f 8d 74 25 00          lea    0x0(%r13,%r12,1),%r14
ffffffff8180b6be:       4c 89 f7                mov    %r14,%rdi
ffffffff8180b6c1:       e8 ea 4f c9 ff          call   ffffffff814a06b0 <__asan_store1> ffffffff8180b6c2: R_X86_64_PLT32        __asan_store1_noabort-0x4
ffffffff8180b6c6:       41 c6 06 00             movb   $0x0,(%r14)
ffffffff8180b6ca:       4c 89 ef                mov    %r13,%rdi
ffffffff8180b6cd:       e8 1e 59 10 00          call   ffffffff81910ff0 <strim> ffffffff8180b6ce: R_X86_64_PLT32        strim-0x4

```

in the dwarf line information, we retrieve the address of the nearest instructions, and get the loc of the trigger point.

```
file_names[  1]:
           name: "lsm.c"
      dir_index: 1
       mod_time: 0x00000000
         length: 0x00000000

Address            Line   Column File   ISA Discriminator Flags
------------------ ------ ------ ------ --- ------------- -------------
0xffffffff8180b6a6    637      5      1   0             0
0xffffffff8180b6ac    643      3      1   0             0  is_stmt
0xffffffff8180b6ac    643      6      1   0             0
0xffffffff8180b6b9    645      3      1   0             0  is_stmt
0xffffffff8180b6b9    645      7      1   0             0
0xffffffff8180b6be    645     14      1   0             0
0xffffffff8180b6ca    649      2      1   0             0  is_stmt
0xffffffff8180b6ca    649      9      1   0             0
0xffffffff8180b6d2    650     12      1   0             0
0xffffffff8180b6de    649      7      1   0             0
0xffffffff8180b6e3    650      2      1   0             0  is_stmt

```

here is the source code: in `security/apparmor/lsm.c`

```c
static int apparmor_setprocattr(const char *name, void *value,
				size_t size)     //           
{
	// char *command, *largs = NULL, *args = value;
	char *command, *args = value;
	size_t arg_size;
	int error;
	DEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETPROCATTR);

	if (size == 0)
		return -EINVAL;
// =================================================================================================
	/* AppArmor requires that the buffer must be null terminated atm */
637	if (args[size - 1] != '\0') {
		// ....
643		if (size == PAGE_SIZE)
644			return -EINVAL;
645		args[size] = '\0';  // off-by-one-byte         
	}
// =================================================================================================
	// ... error = -EINVAL;
} 
```

### 2.2 extract the trigger point (reg to var)

from [2.1](#21-get-source-code-from-apparmor_setprocattr0x116) we get the instruction `movb   $0x0,(%r14)` that triggers KASAN report.

however there is no varible that stores in `R14` near the address of trigger point 0xffffffff8180b6c6

so we make a backward retrieve, find the instruction `lea    0x0(%r13,%r12,1),%r14`, where `R14` stores the result of `0x0(%r13,%r12,1)`.

then we retrieve the debug-info again, find that the register `R13` is varible `value` and the `R12` is varible `size`.

```
0x067d8982:   DW_TAG_formal_parameter
                DW_AT_name	("value")
                DW_AT_location	(0x01b236bf: 
                   [0xffffffff8180b5b0, 0xffffffff8180b6a5): DW_OP_reg4 RSI
                   [0xffffffff8180b6a5, 0xffffffff8180b781): DW_OP_reg13 R13  <<<<<<<

0x067d8997:   DW_TAG_formal_parameter
                DW_AT_name	("size")
                DW_AT_location	(0x01b2376b: 
                   [0xffffffff8180b5b0, 0xffffffff8180b6a5): DW_OP_reg1 RDX
                   [0xffffffff8180b6a5, 0xffffffff8180b787): DW_OP_reg12 R12   <<<<<<<

0x067d89c1:   DW_TAG_variable 
                DW_AT_name	("args")
                DW_AT_decl_file	("/root/linux-5.15-vulns-for-SANITIZERS/out-kasan/../security/apparmor/lsm.c")
                location optimized
```

`char *args = value;`, `args` is identical to `value` and `args` is optimized here, 

**the binary trigger point matches the source code trigger point**, even though the compiler optimization has changed part of the source code structure




here we get varibles:
- source code: `security/apparmor/lsm.c`: 645
- instruction: `mov 0x0, (memory address)`
- ptr: `args` or `value`
- size: `size`


## 3. mapping to the native kernel

### 3.1 get the trigger point from `security/apparmor/lsm.c`: 645

in dwarf debug line, 
```
file_names[  1]:
           name: "lsm.c"
      dir_index: 1
       mod_time: 0x00000000
         length: 0x00000000

Address            Line   Column File   ISA Discriminator Flags
------------------ ------ ------ ------ --- ------------- -------------
0xffffffff814dea00    637      2      1   0             0  is_stmt
0xffffffff814dea00    637      5      1   0             0
0xffffffff814dea02    643      3      1   0             0  is_stmt
0xffffffff814dea02    643      6      1   0             0
0xffffffff814dea0f    645      3      1   0             0  is_stmt    <--
0xffffffff814dea0f    645     14      1   0             0             <--
0xffffffff814dea13    649      2      1   0             0  is_stmt
0xffffffff814dea13    649      9      1   0             0   
```

the instruction here is also a `mov` instant number 0x0.
```c
ffffffff814de9fd:       48 89 d3                mov    %rdx,%rbx
ffffffff814dea00:       74 11                   je     ffffffff814dea13 <apparmor_setprocattr+0x93>
ffffffff814dea02:       48 81 fa 00 10 00 00    cmp    $0x1000,%rdx
ffffffff814dea09:       0f 84 f7 01 00 00       je     ffffffff814dec06 <apparmor_setprocattr+0x286>
ffffffff814dea0f:       c6 04 16 00             movb   $0x0,(%rsi,%rdx,1)    <-----
ffffffff814dea13:       48 89 ef                mov    %rbp,%rdi

```

so the trigger point in native kernel is `pparmor_setprocattr+0x8f`


### 3.2 get the varible/buffer range

varible is also important in analyzing the base and offset of a overflowed buffer.

- ptr in variable `args`: (%rsp) or %rsi
    ```c
    args: DW_AT_location  (DW_OP_fbreg -176), // which means the value is stored in the memory, and gives the addr
    DW_OP_fbreg: 0xffffffff814de99a: CFA=RSP+176: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
                0xffffffff814deafb: CFA=RSP+40: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
    args: store in the stack addr, RSP-176+176 = RSP
    ```

    because `args = value;` where `value` is in `%rsi` and the value `%rsi` is not changed before `apparmor_setprocattr+0x8f`, so compiler use `%rsi` directly, rather than store `(%rsp)` in the `%rsi` first.

- offset in varible `size`: %rdx
    ```c
    size: [0xffffffff814c3a70, 0xffffffff814c3b0a): DW_OP_reg1 RDX 
    ```

in dwarf debug-info and debug-frame(only use for get DW_OP_fbreg)

*debug-info*
```
0x0616caf8: DW_TAG_subprogram
              DW_AT_name        ("apparmor_setprocattr")
              DW_AT_decl_file   ("/root/linux-5.15/security/apparmor/lsm.c")
              DW_AT_decl_line   (624)
              DW_AT_decl_column (0x0c)
              DW_AT_prototyped  (true)
              DW_AT_type        (0x061391b7 "int")
              DW_AT_low_pc      (0xffffffff814de980)
              DW_AT_high_pc     (0xffffffff814ded6b)
              DW_AT_frame_base  (DW_OP_call_frame_cfa)
              DW_AT_GNU_all_call_sites  (true)
              DW_AT_sibling     (0x0616d63a)

0x0616cb1b:   DW_TAG_formal_parameter
                DW_AT_name      ("name")
                DW_AT_decl_file ("/root/linux-5.15/security/apparmor/lsm.c")
                DW_AT_decl_line (624)
                DW_AT_decl_column       (0x2d)
                DW_AT_type      (0x06139126 "const char *")
                DW_AT_location  (0x0199af62:
                   [0xffffffff814de980, 0xffffffff814de9b2): DW_OP_reg5 RDI
                   [0xffffffff814de9b2, 0xffffffff814dea64): DW_OP_reg12 R12)
                DW_AT_GNU_locviews      (0x0199af5e)

0x0616cb30:   DW_TAG_formal_parameter
                DW_AT_name      ("value")
                DW_AT_decl_file ("/root/linux-5.15/security/apparmor/lsm.c")
                DW_AT_decl_line (624)
                DW_AT_decl_column       (0x39)
                DW_AT_type      (0x0613960e "void *")
                DW_AT_location  (0x0199afa6:
                   [0xffffffff814de980, 0xffffffff814dea1a): DW_OP_reg4 RSI
                   [0xffffffff814dea1a, 0xffffffff814deadd): DW_OP_reg6 RBP
                   [0xffffffff814deadd, 0xffffffff814deb02): DW_OP_GNU_entry_value(DW_OP_reg4 RSI), DW_OP_stack_value
                   [0xffffffff814deb02, 0xffffffff814dec01): DW_OP_reg6 RBP
                   [0xffffffff814dec01, 0xffffffff814dec10): DW_OP_GNU_entry_value(DW_OP_reg4 RSI), DW_OP_stack_value
                   [0xffffffff814dec10, 0xffffffff814dec2c): DW_OP_reg6 RBP
                   [0xffffffff814dec2c, 0xffffffff814ded6b): DW_OP_GNU_entry_value(DW_OP_reg4 RSI), DW_OP_stack_value)
                DW_AT_GNU_locviews      (0x0199af98)

0x0616cb45:   DW_TAG_formal_parameter
                DW_AT_name      ("size")
                DW_AT_decl_file ("/root/linux-5.15/security/apparmor/lsm.c")
                DW_AT_decl_line (625)
                DW_AT_decl_column       (0x0c)
                DW_AT_type      (0x06139461 "size_t")
                DW_AT_location  (0x0199b052:
                   [0xffffffff814de980, 0xffffffff814dea1a): DW_OP_reg1 RDX     <-----
                   [0xffffffff814dea1a, 0xffffffff814deadd): DW_OP_reg3 RBX
                   [0xffffffff814deadd, 0xffffffff814deb02): DW_OP_GNU_entry_value(DW_OP_reg1 RDX), DW_OP_stack_value
                   [0xffffffff814deb02, 0xffffffff814dec01): DW_OP_reg3 RBX
                   [0xffffffff814dec01, 0xffffffff814dec10): DW_OP_GNU_entry_value(DW_OP_reg1 RDX), DW_OP_stack_value
                   [0xffffffff814dec10, 0xffffffff814dec34): DW_OP_reg3 RBX
                   [0xffffffff814dec34, 0xffffffff814ded6b): DW_OP_GNU_entry_value(DW_OP_reg1 RDX), DW_OP_stack_value)
                DW_AT_GNU_locviews      (0x0199b044)


0x0616cb6f:   DW_TAG_variable                           <------
                DW_AT_name      ("args")
                DW_AT_decl_file ("/root/linux-5.15/security/apparmor/lsm.c")
                DW_AT_decl_line (628)
                DW_AT_decl_column       (0x12)
                DW_AT_type      (0x0613937b "char *")
                DW_AT_location  (DW_OP_fbreg -176)
```

*debug-frame*
```
  0xffffffff814de980: CFA=RSP+8: RIP=[CFA-8]
  0xffffffff814de987: CFA=RSP+16: R13=[CFA-16], RIP=[CFA-8]
  0xffffffff814de98e: CFA=RSP+24: R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
  0xffffffff814de992: CFA=RSP+32: RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
  0xffffffff814de993: CFA=RSP+40: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
  0xffffffff814de99a: CFA=RSP+176: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]  <--------
  0xffffffff814deafb: CFA=RSP+40: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
  0xffffffff814deafc: CFA=RSP+32: RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
  0xffffffff814deafd: CFA=RSP+24: R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
  0xffffffff814deaff: CFA=RSP+16: R13=[CFA-16], RIP=[CFA-8]
  0xffffffff814deb01: CFA=RSP+8: RIP=[CFA-8]
  0xffffffff814deb02: CFA=RSP+8: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
```


### 3.3 get the return address of the function(for checkpoint & restore)

the address is 0xffffffff814deb01, that will be changed when KASLR is on.

but we set it as a global varible in BPF detector, where `BPF skeleton` can change the value of all global varibles.

```c
ffffffff814deafb:	5b                   	pop    %rbx
ffffffff814deafc:	5d                   	pop    %rbp
ffffffff814deafd:	41 5c                	pop    %r12
ffffffff814deaff:	41 5d                	pop    %r13
ffffffff814deb01:	c3                   	ret        <-------
ffffffff814deb02:	48 29 e8             	sub    %rbp,%rax
```

## 4. IR analysis for checkpoint & restore.

we first record all memory alloctions and synchronize operations before the trigger point. When bug is triggered and BPF jump to the end of the function, we can release the memory and unlock the locks to avoid memory leakage, dead locks or starvation.

We also record the ERROR code or the return value of the function, we can return a "failed" result to caller of the function and launch proceed error handle procedure in the call stack,.

- there is no memory allocation before `apparmor_setprocattr+0x8f`
- there is no lock before `apparmor_setprocattr+0x8f`
- get ERROR code: `-EINVAL`

*discussion here*:
- rcu is out of our scope, future challenge.
- The kernel development community is composed of responsible senior engineers, so we assume that the kernel code is relatively well-defined and the call stack contains error handling paths.


## 5. action: `args[size] \in [bottomed(%rsi), bottomed(%rsi) + buff_size(%rsi)) `

in spatial memory violation, a pointer refer to an address out of the legal range, where in slab oob means the boundary of the referred slab object.

so we use BPF helper functions to get boundary

- base: `bpf_get_buffer_start(%rsi)`
- length: `bpf_get_buffer_len(%rsi)`





## 6. eBPF

### 6.1 detectors

catch the out-of-bound trigger


```c
u64 return_address = 0xffffffff814deb01; // which can be modified by BPF skeleton 

// ffffffff814dea0f:	c6 04 16 00          	movb   $0x0,(%rsi,%rdx,1)
// size: [0xffffffff814c3a70, 0xffffffff814c3b0a): DW_OP_reg1 RDX 
// args: DW_AT_location  (DW_OP_fbreg -176)
//      DW_OP_fbreg: 0xffffffff814de99a: CFA=RSP+176: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
//                   0xffffffff814deafb: CFA=RSP+40: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
// args: store in the stack addr, RSP-176+176 = RSP
SEC("kprobe/apparmor_setprocattr+0x8f")
int BPF_KRETPROBE(trigger_detect)
{
    u64 args = ctx->si;
    // u64 args = BPF_CORE_READ(ctx->rsp); is also correct!
    u64 size = ctx->dx;
    bpf_printk("args: 0x%lx, size: 0x%lx\n", args, size);
    
    u64 objsize = bpf_get_buff_len(args);
    u64 objstart = bpf_get_buff_start(args);

    u64 addr = args + 8 * size; // args[size] off-by-one-byte

    bool check = addr < objstart || addr >= (objstart + objsize);
    // optimize: bool check = !(addr < (objstart+objsize));
    if (check) {
        bpf_printk("OOB happens at apparmor_setprocattr+0x8f\n");
        // send signal
        int err = bpf_send_signal(9);// SIGKILL
        // get checkpoint and restore
        u32 pid = bpf_get_current_pid_tgid();
        struct pt_regs *px_regs = bpf_map_lookup_elem(&checkpoints, &pid);
        if (px_regs) {
            px_regs->ax = -EINVAL;
            px_regs->ip = return_address;
            err = bpf_set_regs(ctx, px_regs);
            bpf_printk("null_skcipher_crypt bpf_set_regs: %d\n", err);
        }
    }

    return 0;
}
```

### 6.2 check point

set up and remove check points at the start and end of the current function.

```c
SEC("kprobe/apparmor_setprocattr")
int BPF_KPROBE(checkpoint_setup)
{
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs x_regs = {};
	x_regs.r15 = ctx->r15 ;
	x_regs.r14 = ctx->r14 ;
	x_regs.r13 = ctx->r13 ;
	x_regs.r12 = ctx->r12 ;
	x_regs.bp  = ctx->bp  ;
	x_regs.bx  = ctx->bx  ;
	x_regs.r11 = ctx->r11;
	x_regs.r10 = ctx->r10;
	x_regs.r9  = ctx->r9 ;
	x_regs.r8  = ctx->r8 ;
	x_regs.ax  = ctx->ax ;
	x_regs.cx  = ctx->cx ;
	x_regs.dx  = ctx->dx ;
	x_regs.si  = ctx->si ;
	x_regs.di  = ctx->di ;
    x_regs.orig_ax = ctx->orig_ax;
	x_regs.ip = ctx->ip;
	x_regs.cs = ctx->cs;
	x_regs.flags = ctx->flags;
	x_regs.sp = ctx->sp;
	x_regs.ss = ctx->ss;
    // bpf_printk("checkpoint setup pid:%u\n", pid);
    int err = bpf_map_update_elem(&checkpoints, &pid, &x_regs, BPF_ANY);
    if (err < 0) {
        bpf_printk("checkpoint setup failed: %d\n", err);
        return err;
    }
    return 0;
}

SEC("kretprobe/apparmor_setprocattr")
int BPF_KRETPROBE(checkpoint_delete)
{
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs* pregs = bpf_map_lookup_elem(&checkpoints, &pid);
    if (pregs) {
        int err = bpf_map_delete_elem(&checkpoints, &pid);
        // bpf_printk("checkpoint remove pid:%u\n", pid);
        if (err < 0) {
            bpf_printk("checkpoints delete failed:%d\n", err);
            return err;
        }
    }
    return 0;
}

```










==========================================================================================================
<!-- ## 1. root cause/trigger point introduction

### 1.1 source code
```c
static int apparmor_setprocattr(const char *name, void *value,
				size_t size)     //                             ---'kprobe/apparmor_setprocattr'ï¼š check point setup
{
	// char *command, *largs = NULL, *args = value;
	char *command, *args = value;
	size_t arg_size;
	int error;
	DEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETPROCATTR);

	if (size == 0)
		return -EINVAL;
// =================================================================================================
	/* AppArmor requires that the buffer must be null terminated atm */
	if (args[size - 1] != '\0') {
		// /* null terminate */
		if (size == PAGE_SIZE)
			return -EINVAL;
		args[size] = '\0';  // off-by-one-byte                 - 'kprobe/apparmor_setprocattr+0x8f': check OOB, restore check point
	}
// =================================================================================================
	// error = -EINVAL;

}  //                                                         - 'kretprobe/apparmor_setprocattr': unused check point removed
```


### 1.2 binary

**native kernel**
```c
ffffffff814de980 <apparmor_setprocattr>:
ffffffff814de980:	e8 eb a9 be ff       	call   ffffffff810c9370 <__fentry__>	ffffffff814de981: R_X86_64_PLT32	__fentry__-0x4
ffffffff814de985:	41 55                	push   %r13
ffffffff814de987:	b9 0b 00 00 00       	mov    $0xb,%ecx
ffffffff814de98c:	41 54                	push   %r12
ffffffff814de98e:	49 89 fc             	mov    %rdi,%r12
ffffffff814de991:	55                   	push   %rbp
ffffffff814de992:	53                   	push   %rbx
ffffffff814de993:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
ffffffff814de99a:	65 48 8b 04 25 28 00 00 00 	mov    %gs:0x28,%rax
ffffffff814de9a3:	48 89 84 24 80 00 00 00 	mov    %rax,0x80(%rsp)
ffffffff814de9ab:	31 c0                	xor    %eax,%eax
ffffffff814de9ad:	48 8d 7c 24 28       	lea    0x28(%rsp),%rdi
// ====================================================================================
ffffffff814de9b2:	48 89 34 24          	mov    %rsi,(%rsp)   // %rsi == (%rsp) binary here still use 
// ====================================================================================
ffffffff814de9b6:	48 c7 44 24 08 00 00 00 00 	movq   $0x0,0x8(%rsp)
ffffffff814de9bf:	48 c7 44 24 10 00 00 00 00 	movq   $0x0,0x10(%rsp)
ffffffff814de9c8:	48 c7 44 24 18 00 00 00 00 	movq   $0x0,0x18(%rsp)
ffffffff814de9d1:	c6 44 24 08 07       	movb   $0x7,0x8(%rsp)
ffffffff814de9d6:	f3 48 ab             	rep stos %rax,%es:(%rdi)
ffffffff814de9d9:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
ffffffff814de9de:	48 c7 44 24 30 5c e6 6e 82 	movq   $0xffffffff826ee65c,0x30(%rsp)	ffffffff814de9e3: R_X86_64_32S	.rodata+0x2ee65c
ffffffff814de9e7:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
ffffffff814de9ec:	48 85 d2             	test   %rdx,%rdx
// ====================================================================================

ffffffff814de9ef:	0f 84 11 02 00 00    	je     ffffffff814dec06 <apparmor_setprocattr+0x286>
ffffffff814de9f5:	80 7c 16 ff 00       	cmpb   $0x0,-0x1(%rsi,%rdx,1)  
ffffffff814de9fa:	48 89 f5             	mov    %rsi,%rbp
ffffffff814de9fd:	48 89 d3             	mov    %rdx,%rbx
ffffffff814dea00:	74 11                	je     ffffffff814dea13 <apparmor_setprocattr+0x93>
ffffffff814dea02:	48 81 fa 00 10 00 00 	cmp    $0x1000,%rdx
ffffffff814dea09:	0f 84 f7 01 00 00    	je     ffffffff814dec06 <apparmor_setprocattr+0x286>
ffffffff814dea0f:	c6 04 16 00          	movb   $0x0,(%rsi,%rdx,1)    // so here use $rsi instead of (%rsp), mov ($rsp), %rsi
// ====================================================================================

```

**sanitized kernel**
```c

ffffffff8180b6a1:       e8 ba 4f c9 ff          call   ffffffff814a0660 <__asan_load1>  ffffffff8180b6a2: R_X86_64_PLT32        __asan_load1_noabort-0x4
ffffffff8180b6a6:       41 80 3e 00             cmpb   $0x0,(%r14)
ffffffff8180b6aa:       74 1e                   je     ffffffff8180b6ca <apparmor_setprocattr+0x11a>
ffffffff8180b6ac:       49 81 fc 00 10 00 00    cmp    $0x1000,%r12
ffffffff8180b6b3:       0f 84 00 02 00 00       je     ffffffff8180b8b9 <apparmor_setprocattr+0x309>
ffffffff8180b6b9:       4f 8d 74 25 00          lea    0x0(%r13,%r12,1),%r14
ffffffff8180b6be:       4c 89 f7                mov    %r14,%rdi
// ====================================================================================

ffffffff8180b6c1:       e8 ea 4f c9 ff          call   ffffffff814a06b0 <__asan_store1> ffffffff8180b6c2: R_X86_64_PLT32        __asan_store1_noabort-0x4
ffffffff8180b6c6:       41 c6 06 00             movb   $0x0,(%r14)
// ====================================================================================

ffffffff8180b6ca:       4c 89 ef                mov    %r13,%rdi


```

## 2. critical information in syzkaller reports

slab, apparmor_setprocattr+0x116, `security/apparmor/lsm.c`

```
[   40.661480] ==================================================================
[   40.663185] BUG: KASAN: slab-out-of-bounds in apparmor_setprocattr+0x116/0x590
[   40.664938] Write of size 1 at addr ffff888007449c80 by task poc_cfh_baselin/1140

[   40.668938] Call Trace:
[   40.669224]  dump_stack_lvl+0x34/0x44
[   40.669630]  print_address_description.constprop.0+0x21/0x140
[   40.671215]  kasan_report.cold+0x83/0xdf
[   40.672164]  apparmor_setprocattr+0x116/0x590
[   40.674617]  proc_pid_attr_write+0x15f/0x1e0


[   40.684604] Allocated by task 408:
[   40.684953]  kasan_save_stack+0x1b/0x40
[   40.685380]  __kasan_kmalloc+0x7c/0x90
[   40.685787]  ext4_htree_store_dirent+0x56/0x200


```



### 3. bin->src->bin mapping

**sanitized kernel:**

1. report: apparmor_setprocattr+0x116, get the previous instruction of `__asan_store`, get the source code line

- binary: `0xffffffff8180b6be    645     14      1   0             0 ` line 645 in `security/apparmor/lsm.c`

- line `args[size] = '\0'; `


**native kernel**

2. mapping: line 645 in `security/apparmor/lsm.c`, ptr is in varible `args` and offset is in `size`, it is a store instruction.

- line 645:  `apparmor_setprocattr+0x8f:   movb   $0x0,(%rsi,%rdx,1)`
    ```
    0xffffffff814dea0f    645      3      1   0             0  is_stmt
    0xffffffff814dea0f    645     14      1   0             0

    0xffffffff814dea0f:       c6 04 16 00             movb   $0x0,(%rsi,%rdx,1)
    ```
- ptr in variable `args`: (%rsp) or %rsi
    ```c
    args: DW_AT_location  (DW_OP_fbreg -176)
         DW_OP_fbreg: 0xffffffff814de99a: CFA=RSP+176: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
                      0xffffffff814deafb: CFA=RSP+40: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
    args: store in the stack addr, RSP-176+176 = RSP
    ```

    because `args = value;` where `value` is in `%rsi` and the value `%rsi` is not changed before `apparmor_setprocattr+0x8f`, so compiler use `%rsi` directly, rather than store `(%rsp)` in the `%rsi` first.

- offset in varible `size`: %rdx
    ```c
    size: [0xffffffff814c3a70, 0xffffffff814c3b0a): DW_OP_reg1 RDX 
    ```

- ret address: `ffffffff814deb01:   c3   ret`

3. analysis: 

- there is no memory allocation before `apparmor_setprocattr+0x8f`
- there is no lock before `apparmor_setprocattr+0x8f`
- get ERROR code: `-EINVAL`


4. action: `args[size] \in [bottomed(%rsi), bottomed(%rsi) + buff_size(%rsi)) `

- bpf_get_buffer_start
- bpf_get_buffer_len






## 4. eBPF

### 4.1 detectors

```c
u64 return_address = 0xffffffff814deb01; // which can be modified by BPF skeleton 

// ffffffff814dea0f:	c6 04 16 00          	movb   $0x0,(%rsi,%rdx,1)
// size: [0xffffffff814c3a70, 0xffffffff814c3b0a): DW_OP_reg1 RDX 
// args: DW_AT_location  (DW_OP_fbreg -176)
//      DW_OP_fbreg: 0xffffffff814de99a: CFA=RSP+176: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
//                   0xffffffff814deafb: CFA=RSP+40: RBX=[CFA-40], RBP=[CFA-32], R12=[CFA-24], R13=[CFA-16], RIP=[CFA-8]
// args: store in the stack addr, RSP-176+176 = RSP
SEC("kprobe/apparmor_setprocattr+0x8f")
int BPF_KRETPROBE(trigger_detect)
{
    u64 args = ctx->si;
    // u64 args = BPF_CORE_READ(ctx->rsp); is also correct!
    u64 size = ctx->dx;
    bpf_printk("args: 0x%lx, size: 0x%lx\n", args, size);
    
    u64 objsize = bpf_get_buff_len(args);
    u64 objstart = bpf_get_buff_start(args);

    u64 addr = args + 8 * size; // args[size] off-by-one-byte

    bool check = addr < objstart || addr >= (objstart + objsize);
    // optimize: bool check = !(addr < (objstart+objsize));
    if (check) {
        bpf_printk("OOB happens at apparmor_setprocattr+0x8f\n");
        // send signal
        int err = bpf_send_signal(9);// SIGKILL
        // get checkpoint and restore
        u32 pid = bpf_get_current_pid_tgid();
        struct pt_regs *px_regs = bpf_map_lookup_elem(&checkpoints, &pid);
        if (px_regs) {
            px_regs->ax = -EINVAL;
            px_regs->ip = return_address;
            err = bpf_set_regs(ctx, px_regs);
            bpf_printk("null_skcipher_crypt bpf_set_regs: %d\n", err);
        }
    }

    return 0;
}
```

### 4.2 check point

set up and remove check points at the start and end of the current function.

```c
SEC("kprobe/apparmor_setprocattr")
int BPF_KPROBE(checkpoint_setup)
{
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs x_regs = {};
	x_regs.r15 = ctx->r15 ;
	x_regs.r14 = ctx->r14 ;
	x_regs.r13 = ctx->r13 ;
	x_regs.r12 = ctx->r12 ;
	x_regs.bp  = ctx->bp  ;
	x_regs.bx  = ctx->bx  ;
	x_regs.r11 = ctx->r11;
	x_regs.r10 = ctx->r10;
	x_regs.r9  = ctx->r9 ;
	x_regs.r8  = ctx->r8 ;
	x_regs.ax  = ctx->ax ;
	x_regs.cx  = ctx->cx ;
	x_regs.dx  = ctx->dx ;
	x_regs.si  = ctx->si ;
	x_regs.di  = ctx->di ;
    x_regs.orig_ax = ctx->orig_ax;
	x_regs.ip = ctx->ip;
	x_regs.cs = ctx->cs;
	x_regs.flags = ctx->flags;
	x_regs.sp = ctx->sp;
	x_regs.ss = ctx->ss;
    // bpf_printk("checkpoint setup pid:%u\n", pid);
    int err = bpf_map_update_elem(&checkpoints, &pid, &x_regs, BPF_ANY);
    if (err < 0) {
        bpf_printk("checkpoint setup failed: %d\n", err);
        return err;
    }
    return 0;
}

SEC("kretprobe/apparmor_setprocattr")
int BPF_KRETPROBE(checkpoint_delete)
{
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs* pregs = bpf_map_lookup_elem(&checkpoints, &pid);
    if (pregs) {
        int err = bpf_map_delete_elem(&checkpoints, &pid);
        // bpf_printk("checkpoint remove pid:%u\n", pid);
        if (err < 0) {
            bpf_printk("checkpoints delete failed:%d\n", err);
            return err;
        }
    }
    return 0;
}

``` -->