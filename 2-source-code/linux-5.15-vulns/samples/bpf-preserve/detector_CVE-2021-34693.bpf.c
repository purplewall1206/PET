#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

// static enum hrtimer_restart bcm_tx_timeout_handler(struct hrtimer *hrtimer)
// {
// 	struct bcm_msg_head msg_head;

// 418			bcm_send_to_user(op, &msg_head, NULL, 0);

// ffffffff81c50290 <bcm_tx_timeout_handler>:
// ...
// ffffffff81c5039c:       c7 44 24 08 09 00 00 00         movl   $0x9,0x8(%rsp)
// ffffffff81c503a4:       c7 44 24 10 00 00 00 00         movl   $0x0,0x10(%rsp)
// ffffffff81c503ac:       89 44 24 38             mov    %eax,0x38(%rsp)
// ffffffff81c503b0:       c7 44 24 3c 00 00 00 00         movl   $0x0,0x3c(%rsp)
// ffffffff81c503b8:       e8 93 f6 ff ff          call   ffffffff81c4fa50 <bcm_send_to_user>

// 0x0d9b06eb:   DW_TAG_variable
//                 DW_AT_name      ("msg_head")
//                 DW_AT_decl_file ("/home/ppw/Documents/ebpf-detector/linux-5.15-vulns/net/can/bcm.c")
//                 DW_AT_decl_line (402)
//                 DW_AT_decl_column       (0x16)
//                 DW_AT_type      (0x0d9aa7ae "bcm_msg_head")
//                 DW_AT_location  (DW_OP_breg7 RSP+8)
// struct bcm_msg_head {
//         __u32                      opcode;               /*     0     4 */
//         __u32                      flags;                /*     4     4 */
//         __u32                      count;                /*     8     4 */

//         /* XXX 4 bytes hole, try to pack */

//         struct bcm_timeval         ival1;                /*    16    16 */
//         struct bcm_timeval         ival2;                /*    32    16 */
//         canid_t                    can_id;               /*    48     4 */
//         __u32                      nframes;              /*    52     4 */
//         struct can_frame           frames[];             /*    56     0 */

//         /* size: 56, cachelines: 1, members: 8 */
//         /* sum members: 52, holes: 1, sum holes: 4 */
//         /* last cacheline: 56 bytes */
// }


SEC("kprobe/bcm_tx_timeout_handler")
int BPF_KPROBE(creation) {
    u64 addr = ctx->sp + 0x8 ;
    return 0;
}


// python -c 'print(hex(0xffffffff81c503b8-0xffffffff81c50290))'
SEC("kprobe/bcm_tx_timeout_handler+0x128")
int BPF_KPROBE(use) {
    u64 addr = ctx->sp + 0x8;
    return 0;
}






// ==========================
// bcm_rx_timeout_handler
// bcm_rx_changed

// bcm_tx_timeout_handler check if there is a hole in structure
// net/can/bcm.c


// check if the branch is executed, if executed, then there is a uninitialized
SEC("kprobe/bcm_rx_timeout_handler")
int BPF_KPROBE(prog1)
{
    bpf_printk("bcm_rx_timeout_handler:there is a hole in struct bcm_msg_head msg_head\n");
    return 0;
}

// 

char LICENSE[] SEC("license") = "Dual BSD/GPL";

