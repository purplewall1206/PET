#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>
// #include <linux/gfp.h>
// #include <linux/slab.h>

u64 ret_bcm_sendmsg = 0x0;

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u32); // pid
    __type(value, struct pt_regs); 
} checkpoints SEC(".maps");


SEC("kprobe/bcm_sendmsg.cold")
int BPF_KPROBE(checkpoint_setup)
{
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs x_regs = {};
        x_regs.r15 = ctx->r15 ;
        x_regs.r14 = ctx->r14 ;
        x_regs.r13 = ctx->r13 ;
        x_regs.r12 = ctx->r12 ;
        x_regs.bp  = ctx->bp  ;
        x_regs.bx  = ctx->bx  ;
        x_regs.r11 = ctx->r11;
        x_regs.r10 = ctx->r10;
        x_regs.r9  = ctx->r9 ;
        x_regs.r8  = ctx->r8 ;
        x_regs.ax  = ctx->ax ;
        x_regs.cx  = ctx->cx ;
        x_regs.dx  = ctx->dx ;
        x_regs.si  = ctx->si ;
        x_regs.di  = ctx->di ;
    x_regs.orig_ax = ctx->orig_ax;
        x_regs.ip = ctx->ip;
        x_regs.cs = ctx->cs;
        x_regs.flags = ctx->flags;
        x_regs.sp = ctx->sp;
        x_regs.ss = ctx->ss;
    int err = bpf_map_update_elem(&checkpoints, &pid, &x_regs, BPF_ANY);
    return 0;
}

SEC("kretprobe/bcm_sendmsg.cold")
int BPF_KRETPROBE(checkpoint_remove)
{
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs* pregs = bpf_map_lookup_elem(&checkpoints, &pid);
    if (pregs) {
        int err = bpf_map_delete_elem(&checkpoints, &pid);
    }
    return 0;
}

int restore(struct pt_regs *ctx, u64 errcode, u64 retaddr)
{
    int err = bpf_send_signal(9);// SIGKILL
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs *px_regs = bpf_map_lookup_elem(&checkpoints, &pid);
    if (px_regs) {
        px_regs->ax = errcode;
        px_regs->ip = retaddr;
        err = bpf_set_regs(ctx, px_regs);
    }
    return 0;
}


// in net/can/bcm.c->bcm_sendmsg.cold(bcm_rx_setup real vulnerability is inlined during the compiler optimization)
// policy: msg_head->nframes < UINT_MAX/16

// ffffffff81d0e828 <bcm_sendmsg.cold>: 
// ....
// ffffffff81d0eb8a:       8b 7d c4                mov    -0x3c(%rbp),%edi  [here]
// ffffffff81d0eb8d:       be c0 0c 00 00          mov    $0xcc0,%esi  [probe here read edi]
// ffffffff81d0eb92:       41 0f af bc 24 f4 00 00 00      imul   0xf4(%r12),%edi
// ffffffff81d0eb9b:       e8 e0 4a 5c ff          call   ffffffff812d3680 <__kmalloc>
// 0xffffffff81d0eb8d - 0xffffffff81d0e828 = 0x365
// python -c 'print(hex(0xffffffff81d0eb8d - 0xffffffff81d0e828))'


// ffffffff81d0ecb7 <bcm_sendmsg.cold>:
// ...
// ffffffff81d0f019:       8b 7d c4                mov    -0x3c(%rbp),%edi
// ffffffff81d0f01c:       be c0 0c 00 00          mov    $0xcc0,%esi
// ffffffff81d0f021:       41 0f af bc 24 f4 00 00 00      imul   0xf4(%r12),%edi
// ffffffff81d0f02a:       e8 51 46 5c ff          call   ffffffff812d3680 <__kmalloc>
// python -c 'print(hex(0xffffffff81d0f01c - 0xffffffff81d0ecb7))' = 0x365  didn't change anything


// ffffffff81d59aaa <bcm_sendmsg.cold>:
// ...
// ffffffff81d59e27:       8b 7d c4                mov    -0x3c(%rbp),%edi
// ffffffff81d59e2a:       be c0 0c 00 00          mov    $0xcc0,%esi
// ffffffff81d59e2f:       41 0f af bc 24 f4 00 00 00      imul   0xf4(%r12),%edi
// ffffffff81d59e38:       e8 83 73 5b ff          call   ffffffff813111c0 <__kmalloc>     ffffffff81d59e39: R_X86_64_PLT32        __kmalloc-0x4
// python3 -c 'print(hex(0xffffffff81d59e38 - 0xffffffff81d59aaa))'

// SEC("kprobe/bcm_sendmsg.cold+0x365")
SEC("kprobe/bcm_sendmsg.cold+0x38e")
int BPF_KPROBE(prog1)
{
    u32 cpu = bpf_get_smp_processor_id();
    u32 pid = bpf_get_current_pid_tgid();
    u32 rdi = (u32) ctx->di;
    u32 cmp = 0xffffffff / 16;
    bool chk = rdi < cmp;
    bpf_printk("bcm_sendmsg.cold: cpu=%u, pid=%u\n", cpu, pid);
    bpf_printk("bcm_sendmsg.cold integer OOB: msg_head->nframes=%u, %u, chk=%u\n", rdi, cmp, chk);
    return 0;
}


// if (msg_head->nframes) {  -0x3c(%rbp)
// 			err = copy_from_iter(op->frames, msg_head->nframes * op->cfsiz ( 0xf4(%r12)  ), &msg->msg_iter);

// ffffffff81d0ecb7 <bcm_sendmsg.cold>:

// ffffffff81d0edf5:       8b 45 c4                mov    -0x3c(%rbp),%eax  [msg_head->nframes]
// ffffffff81d0edf8:       85 c0                   test   %eax,%eax
// ffffffff81d0edfa:       74 63                   je     ffffffff81d0ee5f <bcm_sendmsg.cold+0x1a8>
// ffffffff81d0edfc:       41 0f af 84 24 f4 00 00 00      imul   0xf4(%r12),%eax
// ffffffff81d0ee05:       49 8b bc 24 08 01 00 00         mov    0x108(%r12),%rdi  [op->frames]
// ffffffff81d0ee0d:       89 c6                   mov    %eax,%esi  
// ffffffff81d0ee0f:       85 c0                   test   %eax,%eax
// ffffffff81d0ee11:       0f 89 e8 03 00 00       jns    ffffffff81d0f1ff <bcm_sendmsg.cold+0x548>

// ffffffff81d0f1ff:       48 8b 55 88             mov    -0x78(%rbp),%rdx  [&msg->msg_iter]
// ffffffff81d0f203:       e8 f8 7d 80 ff          call   ffffffff81517000 <_copy_from_iter>  [probe here, rdi, rsi, rdx]

// python -c 'print(hex(0xffffffff81d0f203 - 0xffffffff81d0ecb7))'
// size_t _copy_from_iter(void *addr, size_t bytes, struct iov_iter *i)


// ffffffff81d59aaa <bcm_sendmsg.cold>:
// ...
// ffffffff81d5a005:       b8 f2 ff ff ff          mov    $0xfffffff2,%eax
// ffffffff81d5a00a:       e9 95 eb f0 ff          jmp    ffffffff81c68ba4 <bcm_sendmsg+0x124>     ffffffff81d5a00b: R_X86_64_PC32 .text+0xc68ba0
// ffffffff81d5a00f:       4c 89 f2                mov    %r14,%rdx
// ffffffff81d5a012:       e8 d9 73 87 ff          call   ffffffff815d13f0 <_copy_from_iter>       ffffffff81d5a013: R_X86_64_PLT32        _copy_from_iter-0x4

// python3 -c 'print(hex(0xffffffff81d5a012 - 0xffffffff81d59aaa))'
// SEC("kprobe/bcm_sendmsg.cold+0x54c")
SEC("kprobe/bcm_sendmsg.cold+0x568")
int BPF_KPROBE(prog2)
{
    u32 cpu = bpf_get_smp_processor_id();
    u32 pid = bpf_get_current_pid_tgid();
    u64 arg0 = ctx->di;
    u32 arg1 = (u32)ctx->si;
    u64 arg2 = ctx->dx;
    u32 iov_iter_len = BPF_CORE_READ((struct iov_iter*)arg2, count);
    u64 iov_addr = (u64)BPF_CORE_READ((struct iov_iter*)arg2, iov, iov_base);
    u32 iov_len = BPF_CORE_READ((struct iov_iter*)arg2, iov, iov_len);
    bool chk = arg1 <= iov_iter_len;

    // how big is op->frame? 256, we need a helper function.
    bpf_printk("bcm_sendmsg.cold: cpu=%u, pid=%u\n", cpu, pid);
    bpf_printk("bcm_sendmsg.cold: arg0:%lx, arg1=%u, arg2=%lx\n", arg0, arg1, arg2);
    bpf_printk("bcm_sendmsg.cold iov_iter:%u, iov:%lx, iov_len:%u\n", iov_iter_len, iov_addr, iov_len);

    bpf_printk("bcm_sendmsg.cold arg1 <= msg->msg_iter->count : %u\n", chk);
    int buf_len = bpf_get_buff_len(arg0);
    bpf_printk("bcm_sendmsg.cold len(addr)=%d\n", buf_len);
    return 0;
}


//  poc_cfh_baselin-1085    [000] d.Z.1   356.694410: bpf_trace_printk: bcm_sendmsg.cold: arg0:ffff88800723f200, arg1=1024, arg2=ffffc9000015fe38

//  poc_cfh_baselin-1085    [000] d.Z.1   356.694411: bpf_trace_printk: bcm_sendmsg.cold iov_iter:768, iov:7f641f842000, iov_len:824

//  poc_cfh_baselin-1085    [000] d.Z.1   356.694412: bpf_trace_printk: bcm_sendmsg.cold arg1 <= msg->msg_iter->count : 0

//  poc_cfh_baselin-1085    [000] d.Z.1   356.694414: bpf_trace_printk: bcm_sendmsg.cold len(addr)=256


// Here is the vulnerability, copy_from_iter(addr, bytes, iov_iter), where the buff len of addr is 256, but bytes want to write 1024 bytes, and iov_iter passed 768 bytes

// A very large Out-of-bound was found




// #define __iterate_and_advance(i, n, base, len, off, I, K) {	\
// 	if (unlikely(i->count < n))				\
// 		n = i->count;					\    here, i->count(768) < n (1024)

// https://stackoverflow.com/questions/72262410/where-is-source-code-for-cold-functions-located-in-glibc
// The cold attribute on functions is used to inform the compiler that the function is unlikely to be executed. The function is optimized for size rather than speed and on many targets it is placed into a special subsection of the text section so all cold functions appear close together, improving code locality of non-cold parts of program.


char LICENSE[] SEC("license") = "Dual BSD/GPL";




// ffffffff81d90c83:       e8 48 c0 7e ff          call   ffffffff8157ccd0 <_copy_from_iter>       ffffffff81d90c84: R_X86_64_PLT32        _copy_from_iter-0x4

// 0xffffffff81d90c80    216      6      3   0             0  is_stmt
// 0xffffffff81d90c80    216      6      3   0             0  is_stmt
// 0xffffffff81d90c80    216      6      3   0             0  is_stmt
// 0xffffffff81d90c80    216      6      3   0             0  is_stmt
// 0xffffffff81d90c80    216      6      3   0             0  is_stmt
// 0xffffffff81d90c80    216      6      3   0             0




// 0xffffffff81d90b79    216      6      3   0             0  is_stmt
//     ffffffff81d90b79:       48 81 fe ff ff ff 7f    cmp    $0x7fffffff,%rsi
// 0xffffffff81d90c80    216      6      3   0             0
// 0xffffffff81d90b86    216      6      3   0             0  is_stmt
// 0xffffffff81d90b88    216      6      3   0             0  is_stmt