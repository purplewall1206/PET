#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


char LICENSE[] SEC("license") = "Dual BSD/GPL";

// the UAF/double free is because the ccid object in struct dccp_sock->dccps_hc_tx_ccid/dccps_hc_rx_ccid, freed by mistake and leave the dangling ptr
// quarantine objects: ccid
        // net/dccp/ccid.c
        // void ccid_hc_rx_delete(struct ccid *ccid, struct sock *sk)
        // 		kmem_cache_free(ccid->ccid_ops->ccid_hc_rx_slab, ccid);
        // void ccid_hc_tx_delete(struct ccid *ccid, struct sock *sk)
        // 		kmem_cache_free(ccid->ccid_ops->ccid_hc_tx_slab, ccid);

// dangling ptr store address in struct dccp_sock, 1. DCCPv6(1920) + 0x620/0x628

struct hmap_elem {
	// int pad; /* unused */
	struct bpf_timer timer;
};

struct inner_map {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(max_entries, 1024);
	__type(key, int);
	__type(value, struct hmap_elem);
} inner_htab SEC(".maps");

#define ARRAY_KEY 1
#define HASH_KEY 1234

struct outer_arr {
	__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
	__uint(max_entries, 100);
	__uint(key_size, sizeof(int));
	__uint(value_size, sizeof(int));
	__array(values, struct inner_map);
} outer_arr SEC(".maps") = {
	.values = { [ARRAY_KEY] = &inner_htab },
};


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 33000000);
    __type(key, u64); 
    __type(value, u64); 
} dangling_ptr_map SEC(".maps");


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); 
    __type(value, u64); 
} quarantine_map SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u64); // quarantined flag
    __type(value, u64); 
} quaran_flag SEC(".maps");

u64 offset0 = 0x620;
u64 offset1 = 0x628;

char target[30] = "DCCPv6";

#define ARRAY_KEY 1
#define HASH_KEY 1234
#define CLOCK_REALTIME			0
#define CLOCK_MONOTONIC			1

#define RANGE_FLAG	0
#define OFFSET_FLAG	1


u64 INTERVAL = 1 * (u64)1000000000;

u64 count = 0;

static int timer_sweep(void *map, int *key, struct hmap_elem *val)
{

    // int err = bpf_uaf_slab_sweep(&slab_page_map, &quaran_obj_map, offset);
    int err = 0;
    unsigned long start_addr = 0xffff888000000000;
    unsigned long GB = (1 << 30);
    unsigned long MB = (1 << 20);
    unsigned long len = 512 * MB;
    ++count;
    // if (count % 2 == 0) {
    //     bpf_printk("odd %lu\n", count);
    // } else {
    //     bpf_printk("even %lu\n", count);
    // }
    // struct range_args args = {0xffff888000000000, ((unsigned long)1 << 30) * (unsigned long)17};
    // start_addr = ((32 + count - 1) % 32) * len + start_addr;
    // struct range_args args = {start_addr, len};
    
    // bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args, RANGE_FLAG);

    // if (count % 16 == 0)
        // bpf_uaf_free_undangle(&dangling_ptr_map, &quarantine_map);


    // struct range_args args = {0x0, ((unsigned long)1 << 30) * (unsigned long)17};
    // bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args, RANGE_FLAG);
    // bpf_uaf_free_undangle(&dangling_ptr_map, &quarantine_map, RANGE_FLAG);

    struct offset_args args0 = {"DCCPv6", offset0};
    bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args0, OFFSET_FLAG);
    struct offset_args args1 = {"DCCPv6", offset1};
    bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args1, OFFSET_FLAG);
    bpf_uaf_free_undangle(&dangling_ptr_map, &quarantine_map, OFFSET_FLAG);


    bpf_printk("timer_sweep %d\n", count);
    bpf_timer_set_callback(&val->timer, timer_sweep);
    bpf_timer_start(&val->timer, INTERVAL, 0);

    return 0;
}


int timer_init(void)
{
    int err = 0;
    struct hmap_elem init = {};
	struct bpf_map *inner_map;
	struct hmap_elem *val;
	int array_key = ARRAY_KEY;
	int hash_key = HASH_KEY;

    u32 pid = bpf_get_current_pid_tgid();
    
    u64 v = 0;
    u32 *pval = NULL;


    inner_map = bpf_map_lookup_elem(&outer_arr, &array_key);
    if (!inner_map)
        return 0;
    bpf_map_update_elem(inner_map, &hash_key, &init, 0);
    val = bpf_map_lookup_elem(inner_map, &hash_key);
    if (!val)
        return 0;
    bpf_timer_init(&(val->timer), inner_map, CLOCK_REALTIME);
    err = bpf_timer_set_callback(&val->timer, timer_sweep);
    if (err < 0) {
        bpf_printk("bpf_timer_set_callback failed\n");
        return err;
    }
    err = bpf_timer_start(&val->timer, INTERVAL, 0);
    if (err < 0) {
        bpf_printk("bpf_timer_start failed\n");
        return err;
    }

    bpf_printk("==========initialized===========\n");
}



// struct range_args {
// 	unsigned long addr;
// 	unsigned long len;
// };

int init_flag = 0;
SEC("kprobe/kfree")
int BPF_KPROBE(initialized)
{
    // int err = 0;
    // u32 pid = bpf_get_current_pid_tgid();
    // u64 v = 0;
    // u32 *pval = NULL;
    // err = bpf_map_update_elem(&quaran_flag, &cpu, &pid, BPF_ANY);
    

// ========timer init===================
    if (!init_flag) {
        init_flag = 1;
        timer_init();
        // struct range_args args = {0xffff888000000000, ((unsigned long)1 << 30) * (unsigned long)17};
        // bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args, RANGE_FLAG);
        // struct offset_args args = {"kmalloc-32", 0};
        // bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args, OFFSET_FLAG);

    //         struct range_args args = {0x0, ((unsigned long)1 << 30) * (unsigned long)17};
    
    // bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args, RANGE_FLAG);
    //     bpf_uaf_free_undangle(&dangling_ptr_map, &quarantine_map);
    }
    
    return 0;
}




SEC("kprobe/ccid_hc_rx_delete")
SEC("kprobe/ccid_hc_tx_delete")
int BPF_KPROBE(prog1)
{
    u64 ccid = ctx->di ^ 0xffffffffffffffff;
    u64 val = 0;
    int err = 0;

    if (ccid != 0) {
        err = bpf_map_update_elem(&quaran_flag, &ccid, &val, BPF_ANY);
        if (err < 0) {
            bpf_printk("ccdi_hc_rx/tx_delete: %d\n", err);
        }
    }
    

    return err;
}


SEC("kprobe/kmem_cache_free")
int BPF_KPROBE(prog10)
{
    u64 ccid = ctx->si ^ 0xffffffffffffffff;
    int err = 0;
    u64 *pv = bpf_map_lookup_elem(&quaran_flag, &ccid);
    u64 val = 0;

    if (pv) {
        bpf_printk("quarantine object: %lx\n", (u64) ccid);
        if (pv) {
            struct pt_regs x_regs = {};
            x_regs.r15 = ctx->r15 ;
            x_regs.r14 = ctx->r14 ;
            x_regs.r13 = ctx->r13 ;
            x_regs.r12 = ctx->r12 ;
            x_regs.bp  = ctx->bp  ;
            x_regs.bx  = ctx->bx  ;
            x_regs.r11 = ctx->r11;
            x_regs.r10 = ctx->r10;
            x_regs.r9  = ctx->r9 ;
            x_regs.r8  = ctx->r8 ;
            x_regs.ax  = 0;
            x_regs.cx  = ctx->cx ;
            x_regs.dx  = ctx->dx ;
            x_regs.si  = ctx->si ;
            x_regs.di  = ctx->di ;
            x_regs.orig_ax = ctx->orig_ax;
            x_regs.ip = 0xffffffff812d8c1b;
            x_regs.cs = ctx->cs;
            x_regs.flags = ctx->flags;
            x_regs.sp = ctx->sp;
            x_regs.ss = ctx->ss;
            err |= bpf_set_regs(ctx, &x_regs);
            bpf_printk("kmem_cache_free quarantine %d\n", err);
        }
        err |= bpf_map_delete_elem(&quaran_flag, &ccid);

        // u64 key = (u64)ctx->di ^ (u64)0xffffffffffffffff;
        u64 *pv1 = bpf_map_lookup_elem(&quarantine_map, &ccid);
        if (pv1) {
            bpf_printk("find double free: %lx, %d\n", ccid, err);
            err = bpf_send_signal(9);
        }

        // inject into linear sweep, vanish the sweeper to sweep itself.
        // ccid = ccid ^ (u64) 0xffffffffffffffff;
        bpf_printk("update quarantine_map: %lx\n", ccid);
        err = bpf_map_update_elem(&quarantine_map, &ccid, &val, BPF_ANY);
        
        if (err < 0) {
            bpf_printk("kmem_cache_free quarantine failed: %d\n", err);
        }

    }

    return err;
}



// 0xffffffff81c8cec5    188     23      1   0             0
// 0xffffffff81c8cec9    188      3      1   0             0  is_stmt
// 0xffffffff81c8ced1    188      3      1   0             0