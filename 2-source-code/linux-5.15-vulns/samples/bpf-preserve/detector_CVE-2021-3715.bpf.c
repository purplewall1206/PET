#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>



// !!!!!!!!!!!!!!!!!!!!!!attetion!!!!!!!!!!!!!!!!!!
/*
this vuln is interesting, because the context near memory corruption will be damanged during the UAF exploitation/double free

the dangling ptr point to `route4_filter`, but during the object release, the `route4_filter->exts->net` will be released asyn by `net_put`

so there will be a memory corruption caused by `route4_filter->exts->net->ns.count` when `route4_filter` is freed multiple times

eliminate the danger of the context corruption!!

------------

What make the vuln more interesting is that the `route4_filter` is also freed by kworker asynchronisly.

    // kworker/u4:2-69      [000] d...1    61.429201: bpf_trace_printk: __route4_delete_filter 69: ffff88800695be40:192
    //  poc-1102    [000] d.Z.1    62.424835: bpf_trace_printk: route4_change: fold:ffff88800695be40

so when we try to check the double free / UAF, probe the worker function a.k.a. __route4_delete_filter,

if we probe route4_filter, it is hard to make sure there is dangling ptr in the qurarntine map.
*/




// struct route4_bucket {        =========(0x0118)========== kmalloc 512        
// 	/* 16 FROM buckets + 16 IIF buckets + 1 wildcard bucket */
// 	struct route4_filter __rcu	*ht[16 + 16 + 1];
// 	struct rcu_head			rcu;
// };

// struct route4_filter {   ===============(0x90)=========== kmalloc 192
// 	struct route4_filter __rcu	*next;
// 	u32			id;
// 	int			iif;
// 	struct tcf_result	res;
// 	struct tcf_exts		exts;  ==========(0x20)==========
// 	u32			handle;
// 	struct route4_bucket	*bkt;
// 	struct tcf_proto	*tp;
// 	struct rcu_work		rwork;
// };


// 1. fold, stores in fold->bkt->ht[0], a.k.a struct route4_bucket->ht[0] where stores the route4_filter object
	// if (fold) {
	// 	tcf_unbind_filter(tp, &fold->res);
	// 	tcf_exts_get_net(&fold->exts);
	// 	tcf_queue_work(&fold->rwork, route4_delete_filter_work);
	// }

    // static void __route4_delete_filter(struct route4_filter *f)
    // {
    //     tcf_exts_destroy(&f->exts);
    //     tcf_exts_put_net(&f->exts);
    //     kfree(f);
    // }


// ===============================================================
// syzkaller report the free point!!
//  __route4_delete_filter is inlined in the route4_delete_filter_work.

// ffffffff81ad3070 <route4_delete_filter_work>:
// ...
// ffffffff81ad30ae:       85 c0                   test   %eax,%eax
// ffffffff81ad30b0:       7e 23                   jle    ffffffff81ad30d5 <route4_delete_filter_work+0x65>
// ffffffff81ad30b2:       48 89 ef                mov    %rbp,%rdi
// ffffffff81ad30b5:       e8 06 76 80 ff          call   ffffffff812da6c0 <kfree> ffffffff81ad30b6: R_X86_64_PLT32        kfree-0x4  <- probe here, %rdi is f.
// ffffffff81ad30ba:       5b                      pop    %rbx
// ffffffff81ad30bb:       5d                      pop    %rbp

// python -c 'print(hex(0xffffffff81ad30b5-0xffffffff81ad3070))' 0x45


const char target[32] = "kmalloc-512";
u32 offset = 0;

// use 
// net/sched/cls_route.c
// static void *route4_get(struct tcf_proto *tp, u32 handle)
// 	struct route4_filter *f;
//235 			if (f->handle == handle)

// ffffffff81aa1c80 <route4_get>:
// ...
// ffffff81aa1cd0:       48 8b 00                mov    (%rax),%rax
// ffffffff81aa1cd3:       48 85 c0                test   %rax,%rax
// ffffffff81aa1cd6:       74 05                   je     ffffffff81aa1cdd <route4_get+0x5d>
// ffffffff81aa1cd8:       39 70 40                cmp    %esi,0x40(%rax)


// python -c 'print(hex(0xffffffff81aa1cd8-0xffffffff81aa1c80))' = 0x58


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // start addr of page
    __type(value, u64); 
} store_map SEC(".maps");



struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // quarantined objects
    __type(value, u64); 
} quaran_obj_map SEC(".maps");



struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u64); // quarantined flag
    __type(value, u64); 
} quaran_flag SEC(".maps");


struct hmap_elem {
	// int pad; /* unused */
	struct bpf_timer timer;
};

struct inner_map {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(max_entries, 1024);
	__type(key, int);
	__type(value, struct hmap_elem);
} inner_htab SEC(".maps");

#define ARRAY_KEY 1
#define HASH_KEY 1234

struct outer_arr {
	__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
	__uint(max_entries, 100);
	__uint(key_size, sizeof(int));
	__uint(value_size, sizeof(int));
	__array(values, struct inner_map);
} outer_arr SEC(".maps") = {
	.values = { [ARRAY_KEY] = &inner_htab },
};
    

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u32); // pid
    __type(value, struct pt_regs); 
} checkpoints SEC(".maps");

SEC("kprobe/route4_delete_filter_work")
int BPF_KPROBE(prog0)
{
    u64 f = ctx->di ^ 0xffffffffffffffff;
    // bpf_printk("search:%lx\n", f);
    u32 *pv = bpf_map_lookup_elem(&quaran_obj_map, &f);
    if (pv) {
        u32 pid = bpf_get_current_pid_tgid();
        struct pt_regs x_regs = {};
        x_regs.r15 = ctx->r15 ;
        x_regs.r14 = ctx->r14 ;
        x_regs.r13 = ctx->r13 ;
        x_regs.r12 = ctx->r12 ;
        x_regs.bp  = ctx->bp  ;
        x_regs.bx  = ctx->bx  ;
        x_regs.r11 = ctx->r11;
        x_regs.r10 = ctx->r10;
        x_regs.r9  = ctx->r9 ;
        x_regs.r8  = ctx->r8 ;
        x_regs.ax  = 0 ;
        x_regs.cx  = ctx->cx ;
        x_regs.dx  = ctx->dx ;
        x_regs.si  = ctx->si ;
        x_regs.di  = ctx->di ;
        x_regs.orig_ax = ctx->orig_ax;
        x_regs.ip = 0xffffffff81ac27bb;
        x_regs.cs = ctx->cs;
        x_regs.flags = ctx->flags;
        x_regs.sp = ctx->sp;
        x_regs.ss = ctx->ss;

        int err = bpf_set_regs(ctx, &x_regs);
        bpf_printk("======UAF HAPPENS:%lx at __delete======\n", f);
    }
    
    // bpf_printk("checkpoint setup pid:%u\n", pid);
    // int err = bpf_map_update_elem(&checkpoints, &pid, &x_regs, BPF_ANY);
    // if (err < 0) {
    //     bpf_printk("checkpoint setup failed: %d\n", err);
    //     return err;
    // }
    return 0;
}


SEC("kprobe/route4_change")
int BPF_KPROBE(prog1)
{

        u32 pid = bpf_get_current_pid_tgid();
        struct pt_regs x_regs = {};
        x_regs.r15 = ctx->r15 ;
        x_regs.r14 = ctx->r14 ;
        x_regs.r13 = ctx->r13 ;
        x_regs.r12 = ctx->r12 ;
        x_regs.bp  = ctx->bp  ;
        x_regs.bx  = ctx->bx  ;
        x_regs.r11 = ctx->r11;
        x_regs.r10 = ctx->r10;
        x_regs.r9  = ctx->r9 ;
        x_regs.r8  = ctx->r8 ;
        x_regs.ax  = ctx->ax ;
        x_regs.cx  = ctx->cx ;
        x_regs.dx  = ctx->dx ;
        x_regs.si  = ctx->si ;
        x_regs.di  = ctx->di ;
        x_regs.orig_ax = ctx->orig_ax;
        x_regs.ip = ctx->ip;
        x_regs.cs = ctx->cs;
        x_regs.flags = ctx->flags;
        x_regs.sp = ctx->sp;
        x_regs.ss = ctx->ss;

    
    // bpf_printk("checkpoint setup pid:%u\n", pid);
    int err = bpf_map_update_elem(&checkpoints, &pid, &x_regs, BPF_ANY);
    if (err < 0) {
        bpf_printk("checkpoint setup failed: %d\n", err);
        return err;
    }
    return 0;
}


SEC("kretprobe/route4_change")
int BPF_KRETPROBE(prog2)
{
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs* pregs = bpf_map_lookup_elem(&checkpoints, &pid);
    if (pregs) {
        int err = bpf_map_delete_elem(&checkpoints, &pid);
        // bpf_printk("checkpoint remove pid:%u\n", pid);
        if (err < 0) {
            bpf_printk("checkpoints delete failed:%d\n", err);
            return err;
        }
    }
    return 0;
}

// ffffffff81ac2c40 <route4_change>:
// ...
// ffffffff81ac2d71:       41 ba 01 00 00 00       mov    $0x1,%r10d
// ffffffff81ac2d77:       48 89 43 38             mov    %rax,0x38(%rbx)
// ffffffff81ac2d7b:       4d 85 ff                test   %r15,%r15
// ffffffff81ac2d7e:       74 38                   je     ffffffff81ac2db8 <route4_change+0x178>

// python -c 'print(hex(0xffffffff81ac2d7b-0xffffffff81ac2c40))'
// fold: R15
// ret position: 0xffffffff81ac2f37


// python -c 'print(hex(0xffffffff81ad3c5c-0xffffffff81ad3670))'
SEC("kprobe/route4_change+0x5ec")
// SEC("kprobe/route4_change+0x59a")
int BPF_KPROBE(prog3)
{
    // if use after free, exit the program!
    u64 fold = ctx->r15 ^ 0xffffffffffffffff;
    bpf_printk("route4_change: fold:%lx\n", fold);
    u64 *pv = bpf_map_lookup_elem(&quaran_obj_map, &fold);
    int err;
    if (pv) {
        bpf_printk("======UAF HAPPENS:%lx at route4_change======\n", fold);
        u32 pid = bpf_get_current_pid_tgid();
        struct pt_regs *px_regs = bpf_map_lookup_elem(&checkpoints, &pid);
        if (px_regs) {
            px_regs->ax = (unsigned long)((int)-35);
            px_regs->ip = 0xffffffff81ac2f16;
            err = bpf_set_regs(ctx, px_regs);
            bpf_printk(" bpf_set_regs: %d\n", err);
            bpf_send_signal(9);
            bpf_printk(" bpf_send sigkill to pid:%d\n", pid);
        }
    } else if (fold != 0) {
        bpf_printk("fold not found %lx\n", fold);
    }

    return 0;
}


// net/sched/cls_route.c
// static void *route4_get(struct tcf_proto *tp, u32 handle)
// 		     f = rtnl_dereference(f->next))
// 235			if (f->handle == handle)
// 236				return f;

// ffffffff81ad3330 <route4_get>:
// ...
// ffffffff81ad3380:       48 8b 00                mov    (%rax),%rax
// ffffffff81ad3383:       48 85 c0                test   %rax,%rax
// ffffffff81ad3386:       74 05                   je     ffffffff81ad338d <route4_get+0x5d>
// ffffffff81ad3388:       39 70 40                cmp    %esi,0x40(%rax)
// python -c 'print(hex(0xffffffff81ad3380-0xffffffff81ad3330))'
//f   [0xffffffff81ad3379, 0xffffffff81ad338d): DW_OP_reg0 RAX)
// f == f->handle same address
SEC("kprobe/route4_get+0x50")
int BPF_KPROBE(prog10)
{
    // if use after free, exit the program!
    u64 f = ctx->ax ^ 0xffffffffffffffff;
    u64 *pv = bpf_map_lookup_elem(&quaran_obj_map, &f);
    int err;
    if (pv) {
        bpf_printk("======UAF HAPPENS:%lx at route4_get======\n", f);
        u32 pid = bpf_get_current_pid_tgid();
        struct pt_regs *px_regs = bpf_map_lookup_elem(&checkpoints, &pid);
        if (px_regs) {
            px_regs->ax = (unsigned long)((int)-35);
            px_regs->ip = 0xffffffff81ad338d;
            err = bpf_set_regs(ctx, px_regs);
            bpf_printk(" bpf_set_regs: %d\n", err);
            bpf_send_signal(9);
            bpf_printk(" bpf_send sigkill to pid:%d\n", pid);
        }
    } else if (f != 0) {
        bpf_printk("fold not found %lx\n", f);
    }

    return 0;
}


u64 INTERVAL = 1 * 1000000000;
u64 cnt = 0;

static __u64 elem_cnt(struct bpf_map *map, __u32 *key, __u64 *val,
		  void *pdata)
{
    // u64 data = *(u64 *)pdata;
    // *(u64 *)pdata = data + 1;
    return 0;
}
#define RANGE_FLAG	0
#define OFFSET_FLAG	1
static int timer_sweep(void *map, int *key, struct hmap_elem *val)
{

    int err = 0;
    ++cnt;

    // for (int i = 0;i < 33;i++) {
    //     u32 offset = i * 8;
    //     err = bpf_uaf_slab_sweep(&store_map, &quaran_obj_map, offset, target); 
    // }
    // err = bpf_uaf_slab_sweep(&store_map, &quaran_obj_map, 31 * 8, target);
    // // if (cnt % 10 == 0) {
    //     u64 data = 0;
    //     int elems = bpf_for_each_map_elem(&quaran_obj_map, elem_cnt, &data, 0);
    //     if (elems > 0) {
    //         bpf_printk("there is dangling ptr\n");
    //     }
    // // }

    struct offset_args args = {"kmalloc-512", offset};
    bpf_uaf_dangling_ptr_sweep(&store_map, &args, OFFSET_FLAG);
    bpf_uaf_free_undangle(&quaran_obj_map, &quaran_obj_map, OFFSET_FLAG);

    bpf_printk("timer_sweep\n");
    bpf_timer_set_callback(&val->timer, timer_sweep);
    bpf_timer_start(&val->timer, INTERVAL, 0);

    return 0;
}


#define ARRAY_KEY 1
#define HASH_KEY 1234
#define CLOCK_REALTIME			0
#define CLOCK_MONOTONIC			1


int timer_init(void)
{
    int err = 0;
    struct hmap_elem init = {};
	struct bpf_map *inner_map;
	struct hmap_elem *val;
	int array_key = ARRAY_KEY;
	int hash_key = HASH_KEY;

    u32 pid = bpf_get_current_pid_tgid();
    
    u64 v = 0;
    u32 *pval = NULL;


    inner_map = bpf_map_lookup_elem(&outer_arr, &array_key);
    if (!inner_map)
        return 0;
    bpf_map_update_elem(inner_map, &hash_key, &init, 0);
    val = bpf_map_lookup_elem(inner_map, &hash_key);
    if (!val)
        return 0;
    bpf_timer_init(&(val->timer), inner_map, CLOCK_REALTIME);
    err = bpf_timer_set_callback(&val->timer, timer_sweep);
    if (err < 0) {
        bpf_printk("bpf_timer_set_callback failed\n");
        return err;
    }
    err = bpf_timer_start(&val->timer, INTERVAL, 0);
    if (err < 0) {
        bpf_printk("bpf_timer_start failed\n");
        return err;
    }

    bpf_printk("==========initialized===========\n");
}

int init_flag = 0;
SEC("kprobe/kfree")
int BPF_KPROBE(initialized)
{
    int err = 0;
    u32 pid = bpf_get_current_pid_tgid();
    u64 v = 0;
    u32 *pval = NULL;
    u32 *pv1 = NULL;
    // err = bpf_map_update_elem(&quaran_flag, &cpu, &pid, BPF_ANY);
    u64 obj_addr = ctx->di;
    u64 tmp = ctx->di ^ 0xffffffffffffffff;
    pval = bpf_map_lookup_elem(&quaran_flag, &tmp);
    if (pval != NULL) {
        // skip the kfree and quarantine the freed object
        v = bpf_get_buff_len(obj_addr);
        bpf_printk("__route4_delete_filter %u: %lx:%u\n", pid, obj_addr, v);

        if (*pval) {
            pv1 = bpf_map_lookup_elem(&quaran_obj_map, &tmp);
            if (pv1) {
                bpf_printk("===double free %u: %lx=====\n", v, obj_addr);
            }
            err = bpf_map_update_elem(&quaran_obj_map, &obj_addr, &v, BPF_ANY);
        } 

        err |= bpf_map_delete_elem(&quaran_flag, &tmp);
        if (err < 0) {
            bpf_printk("quarantine failed %d\n", err);
            return -1;
        }
        bpf_override_return(ctx, 0);
    }

// ========timer init===================
    if (!init_flag) {
        init_flag = 1;
        timer_init();
    }
    
    return 0;
}


// ffffffff81ac2770 <__route4_delete_filter>:
// ...
// ffffffff81ac2779:       48 83 c7 20             add    $0x20,%rdi
// ffffffff81ac277d:       e8 6e 1f fc ff          call   ffffffff81a846f0 <tcf_exts_destroy>      ffffffff81ac277e: R_X86_64_PLT32        tcf_exts_destroy-0x4
// ffffffff81ac2782:       48 8b 7d 30             mov    0x30(%rbp),%rdi
// ...
// ffffffff81ac27ab:       5d                      pop    %rbp
// ffffffff81ac27ac:       e9 9f 57 81 ff          jmp    ffffffff812d7f50 <kfree> ffffffff81ac27ad: R_X86_64_PLT32        kfree-0x4

// python -c 'print(hex(0xffffffff81ac27ac-0xffffffff81ac2770))'


// python -c 'print(hex(0xffffffff81ad30b5-0xffffffff81ad3070))' 0x45 see the front of the document
SEC("kprobe/route4_delete_filter_work+0x45")
int BPF_KPROBE(prog8)
{
    u32 pid = bpf_get_current_pid_tgid();
    u64 val = 1;
    u64 quaran_addr = ctx->di ^ 0xffffffffffffffff;
    int err = bpf_map_update_elem(&quaran_flag, &quaran_addr, &val, BPF_ANY);
    // bpf_printk("__route4_delete_filter+0x3c %u: %lx\n", pid, quaran_addr);
    if (err < 0) {
        bpf_printk("__route4_delete_filter set flag failed: %d\n", err);
        return -1;
    }
    return 0;
}







char LICENSE[] SEC("license") = "Dual BSD/GPL";




// root cause 1: 
/*
static void __route4_delete_filter(struct route4_filter *f)
{
	tcf_exts_destroy(&f->exts);
	tcf_exts_put_net(&f->exts);  ---》 here put_net, clean the f->exts->net, where route4_destroy use net->ns.count
	kfree(f);
}




 0[0  00 00  00  060 2.426062] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
00 0[0  00    | 6 .2...426955] RIP: 0010:route4_change+0x59a/0x7a0

and

[   85.952838] #PF: supervisor read access in kernel mode
[   85.952838] #PF: error_code(0x0000) - not-present page
[   85.952838] PGD 0 P4D 0 
[   85.952838] Oops: 0000 [#1] SMP
[   85.952838] CPU: 1 PID: 69 Comm: kworker/u4:2 Not tainted 5.15.0 #282
[   85.952838] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
[   85.952838] Workqueue: netns cleanup_net
[   85.952838] RIP: 0010:route4_destroy+0xd6/0x1c0
[   85.952838] Code: 48 8b 78 48 48 85 ff 74 1d 4c 89 f6 49 87 77 10 48 85 f6 74 11 48 8b 47 18 48 8b 40 08 48 8b 40 58 e8 be 1d 74 00 4d 8b 4f 30 <41> 8b 91 8c9
[   85.952838] RSP: 0018:ffffc900001bfc30 EFLAGS: 00000246
[   85.952838] RAX: ffff888003ed6800 RBX: ffff888006bc6a00 RCX: 0000000000000000
[   85.952838] RDX: 0000000000000006 RSI: 0000000000000000 RDI: ffff888006bb1000
[   85.952838] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000
[   85.952838] R10: ffff888006b15e40 R11: 0000000000000001 R12: ffff888006bc6a00
[   85.952838] R13: ffff888007541980 R14: 0000000000000000 R15: ffff888006b156c0
[   85.952838] FS:  0000000000000000(0000) GS:ffff88803ed00000(0000) knlGS:0000000000000000
[   85.952838] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   85.952838] CR2: 000000000000008c CR3: 0000000005bd5000 CR4: 00000000000006e0
[   85.952838] Call Trace:
[   85.958005]  tcf_proto_destroy+0x20/0xa0
[   85.958005]  tcf_chain_flush+0x70/0xa0
[   85.960228]  __tcf_block_put+0xb6/0x140
[   85.960228]  tcf_block_put+0x4d/0x70
[   85.960228]  sfq_destroy+0x15/0x50
[   85.960228]  qdisc_destroy+0x3e/0xb0
[   85.960228]  dev_shutdown+0x86/0xb0
[   85.960228]  unregister_netdevice_many+0x256/0x5f0
[   85.960228]  ? netdev_run_todo+0x5f/0x2a0
[   85.960228]  ? rtnl_is_locked+0x11/0x20
[   85.960228]  default_device_exit_batch+0x141/0x170
[   85.960228]  ? autoremove_wake_function+0x30/0x30
[   85.960228]  cleanup_net+0x208/0x340
[   85.960228]  process_one_work+0x1d9/0x380
[   85.960228]  worker_thread+0x4a/0x3b0
[   85.960228]  ? process_one_work+0x380/0x380
[   85.960228]  kthread+0x127/0x150
[   85.960228]  ? set_kthread_struct+0x40/0x40
[   85.960228]  ret_from_fork+0x22/0x30
[   85.960228] Modules linked in:
[   85.960228] CR2: 000000000000008c
[   85.960228] ---[ end trace 2337a6aab9a40ebf ]---
[   85.960228] RIP: 0010:route4_destroy+0xd6/0x1c0
[   85.962647] Code: 48 8b 78 48 48 85 ff 74 1d 4c 89 f6 49 87 77 10 48 85 f6 74 11 48 8b 47 18 48 8b 40 08 48 8b 40 58 e8 be 1d 74 00 4d 8b 4f 30 <41> 8b 91 8c9
[   85.962647] RSP: 0018:ffffc900001bfc30 EFLAGS: 00000246
[   85.962647] RAX: ffff888003ed6800 RBX: ffff888006bc6a00 RCX: 0000000000000000
[   85.963513] RDX: 0000000000000006 RSI: 0000000000000000 RDI: ffff888006bb1000
[   85.963513] RBP: 0000000000000000 R08: 0000000000000000 R09: 0000000000000000
[   85.963513] R10: ffff888006b15e40 R11: 0000000000000001 R12: ffff888006bc6a00
[   85.963513] R13: ffff888007541980 R14: 0000000000000000 R15: ffff888006b156c0
[   85.963513] FS:  0000000000000000(0000) GS:ffff88803ed00000(0000) knlGS:0000000000000000
[   85.963513] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[   85.963513] CR2: 000000000000008c CR3: 0000000005bd5000 CR4: 00000000000006e0*/





// 			for (pfp = rtnl_dereference(*fp); pfp;
// 			     fp = &pfp->next, pfp = rtnl_dereference(*fp)) {
// here seems to null pointer poison!
// CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
// #define LIST_POISON1  ((void *) 0x100 + POISON_POINTER_DELTA)

// 1] general protection fault, probably for non-canonical address 0xdead000000000100: 0000 [#1] SMP
// [  100.597798] CPU: 0 PID: 1115 Comm: poc Not tainted 5.15.0 #282
// [  100.598136] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
// [  100.598588] RIP: 0010:route4_change+0x547/0x7a0
// [  100.598837] Code: 00 01 00 00 48 85 c9 74 29 89 c2 48 8b 04 d1 48 85 c0 74 1e 48 39 d8 75 0e e9 ba 01 00 00 48 39 d8 0f 84 b5 01 00 00 48 89 c2 <48> 8b 00 48b
// [  100.599785] RSP: 0018:ffffc9000013b920 EFLAGS: 00010287
// [  100.600056] RAX: dead000000000100 RBX: ffff8880079b0c00 RCX: ffff8880070f8e00
// [  100.600413] RDX: dead000000000100 RSI: ffff88800a384000 RDI: ffff8880079da800
// [  100.600772] RBP: ffffc9000013b9d0 R08: ffff8880079b0c20 R09: ffff88800a384088
// [  100.601129] R10: 0000000000000000 R11: ffffc9000013bbb8 R12: 0000000000000011
// [  100.601528] R13: 0000000000000000 R14: ffff888006a406c0 R15: ffff888006a40600
// [  100.601931] FS:  00007f77b87c0580(0000) GS:ffff88803ec00000(0000) knlGS:0000000000000000
// [  100.602367] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
// [  100.602657] CR2: 00005574f099f000 CR3: 00000000072d7000 CR4: 00000000000006f0


// __route4_delete_filter

// ffffffff81adc110 <route4_delete_filter_work>:
// ...
// ffffffff81adc152:       48 89 ef                mov    %rbp,%rdi
// ffffffff81adc155:       e8 36 80 7f ff          call   ffffffff812d4190 <kfree> ffffffff81adc156: R_X86_64_PLT32        kfree-0x4
// ffffffff81adc15a:       5b                      pop    %rbx


// 0xffffffff81adc152    282      5      7   0             0
// 0xffffffff81adc152    257      2      1   0             0  is_stmt



// 0xffffffff81adc152    257      2      1   0             0  is_stmt
// 0xffffffff81adc15a    257      2      1   0             0
// 0xffffffff81adc166    257      2      1   0             0  is_stmt
// 0xffffffff81adc16e    257      2      1   0             0



// ffffffff81adc3d0 <route4_get>:
// ...
// ffffffff81adc426:       74 05                   je     ffffffff81adc42d <route4_get+0x5d>
// ffffffff81adc428:       39 70 40                cmp    %esi,0x40(%rax)
// ffffffff81adc42b:       75 f3                   jne    ffffffff81adc420 <route4_get+0x50>


// 0xffffffff81adc428    235      4      1   0             0  is_stmt


// 0xffffffff81adc289    235     20      5   0             0  is_stmt
// 0xffffffff81adc428    235      4      1   0             0  is_stmt
// 0xffffffff81adc607    235     20      5   0             0  is_stmt