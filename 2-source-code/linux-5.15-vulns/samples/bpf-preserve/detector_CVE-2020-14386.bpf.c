#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


u64 ret_tpacket_rcv = 0x0;

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u32); // pid
    __type(value, struct pt_regs); 
} checkpoints SEC(".maps");


SEC("kprobe/tpacket_rcv")
int BPF_KPROBE(checkpoint_setup)
{
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs x_regs = {};
        x_regs.r15 = ctx->r15 ;
        x_regs.r14 = ctx->r14 ;
        x_regs.r13 = ctx->r13 ;
        x_regs.r12 = ctx->r12 ;
        x_regs.bp  = ctx->bp  ;
        x_regs.bx  = ctx->bx  ;
        x_regs.r11 = ctx->r11;
        x_regs.r10 = ctx->r10;
        x_regs.r9  = ctx->r9 ;
        x_regs.r8  = ctx->r8 ;
        x_regs.ax  = ctx->ax ;
        x_regs.cx  = ctx->cx ;
        x_regs.dx  = ctx->dx ;
        x_regs.si  = ctx->si ;
        x_regs.di  = ctx->di ;
    x_regs.orig_ax = ctx->orig_ax;
        x_regs.ip = ctx->ip;
        x_regs.cs = ctx->cs;
        x_regs.flags = ctx->flags;
        x_regs.sp = ctx->sp;
        x_regs.ss = ctx->ss;
    int err = bpf_map_update_elem(&checkpoints, &pid, &x_regs, BPF_ANY);
    return 0;
}

SEC("kretprobe/tpacket_rcv")
int BPF_KRETPROBE(checkpoint_remove)
{
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs* pregs = bpf_map_lookup_elem(&checkpoints, &pid);
    if (pregs) {
        int err = bpf_map_delete_elem(&checkpoints, &pid);
    }
    return 0;
}

int restore(struct pt_regs *ctx, u64 errcode, u64 retaddr)
{
    int err = bpf_send_signal(9);// SIGKILL
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs *px_regs = bpf_map_lookup_elem(&checkpoints, &pid);
    if (px_regs) {
        px_regs->ax = errcode;
        px_regs->ip = retaddr;
        err = bpf_set_regs(ctx, px_regs);
    }
    return 0;
}

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // addr (pg_vec[i].buffer)
    __type(value, u32); // order of pages
} page_orders SEC(".maps");

// *****************integer OOB**********************
// net/packet/af_packet.c
// static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
// 		       struct packet_type *pt, struct net_device *orig_dev)
// ...
// 2268		netoff = TPACKET_ALIGN(po->tp_hdrlen +          // ffffffff81bdafbc
// 2269				       (maclen < 16 ? 16 : maclen)) +
// 2270				       po->tp_reserve;                  // ffffffff81bdafcd
// 2271		// po->tp_reserve is cutoff here by netoff
// 2272		if (po->has_vnet_hdr) {
// ...
// 2330    pr_info("cve-2020-14386: h.raw:%016lx, underflow:%016lx\n", (unsigned long)h.raw, 
// 2331                                            (unsigned long )(h.raw + macoff -sizeof(struct virtio_net_hdr)));
// 2332	if (do_vnet &&                                      // 0xffffffff81bdae63
// 2333	    virtio_net_hdr_from_skb(skb, h.raw + macoff -   // 0xffffffff81bdae71
// 2334				    sizeof(struct virtio_net_hdr),
// 2335				    vio_le(), true, 0)) {

//   CFA=RSP+144:

// ffffffff81bda780 <tpacket_rcv>:
// ...
// ffffffff81bda93d:       83 e0 f0                and    $0xfffffff0,%eax
// ffffffff81bda940:       01 f0                   add    %esi,%eax
// ffffffff81bda942:       66 89 44 24 16          mov    %ax,0x16(%rsp) // 0x16(%rsp) netoff [ prog1 : probe here] the po->tp_reserve is cut off here
// ffffffff81bda947:       41 f6 84 24 cc 04 00 00 04      testb  $0x4,0x4cc(%r12)
// ffffffff81bda950:       0f 85 8d 02 00 00       jne    ffffffff81bdabe3 <tpacket_rcv+0x463>
// ffffffff81bda956:       0f b7 44 24 16          movzwl 0x16(%rsp),%eax 




// netoff: [0xffffffff81bda947, 0xffffffff81bda956): DW_OP_reg0 RAX
            // [0xffffffff81bda956, 0xffffffff81bdaba6): DW_OP_fbreg -122  : %rsp + 144 - 122 = %rsp + 0x16
// po:[0xffffffff81bda7f9, 0xffffffff81bdb20b): DW_OP_reg12 R12
// po->tp_reserve: po+1300
// po->tp_hdrlen: po+1296
// macoff   [0xffffffff81bdae39, 0xffffffff81bdb08a): DW_OP_fbreg -124   %rsp + 144 - 124 = %rsp + 0x14
// python -c 'print(hex(0xffffffff81bda947-0xffffffff81bda780))'
// python -c 'print(hex(0xffffffff81bc0739-0xffffffff81bc0580))'
SEC("kprobe/tpacket_rcv+0x1b9")
int BPF_KPROBE(prog1)
{
    // compare the u32 po->tp_reserve, and u16 netoff, that cut off u32 po->tp_reserve
    u64 addr_po = ctx->r12;
    u64 addr_po_tp_reserve = addr_po + 0x04fc;
    u64 val_po_tp_reserve = 0;
    bpf_core_read(&val_po_tp_reserve, 8, addr_po_tp_reserve);

    u16 netoff = ctx->ax;

    bpf_printk("tpacket_rcv: int oob: netoff=0x%hx, po=0x%lx, po->tp_reserve=0x%x\n", netoff, addr_po, val_po_tp_reserve);
 
    return 0;
}

// 0x11a1a05d:     DW_TAG_member
//                   DW_AT_name	("tp_reserve")
//                   DW_AT_decl_file	("/root/linux-5.15/net/packet/internal.h")
//                   DW_AT_decl_line	(133)
//                   DW_AT_decl_column	(0x10)
//                   DW_AT_type	(0x119f41e4 "unsigned int")
//                   DW_AT_data_member_location	(0x04fc)



// ffffffff81bda780 <tpacket_rcv>:
// ...
// ffffffff81bdae63:       80 7c 24 18 00          cmpb   $0x0,0x18(%rsp)  // do_vnet: 0x18(%rsp)
// ffffffff81bdae68:       0f b7 54 24 14          movzwl 0x14(%rsp),%edx  // macoff: 0x14(%rsp)
// ffffffff81bdae6d:       74 72                   je     ffffffff81bdaee1 <tpacket_rcv+0x761>
// ffffffff81bdae6f:       31 c9                   xor    %ecx,%ecx
// ffffffff81bdae71:       49 8d 44 12 f6          lea    -0xa(%r10,%rdx,1),%rax   // h.raw:%r10, macoff:%rax, sizeof(): 0xa
// ffffffff81bdae76:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)  [probe here prog2] get addr in %rax!! real oob!
// ffffffff81bdae7d:       66 89 48 08             mov    %cx,0x8(%rax)
// ffffffff81bdae81:       8b 8d bc 00 00 00       mov    0xbc(%rbp),%ecx
// ffffffff81bdae87:       48 03 8d c0 00 00 00    add    0xc0(%rbp),%rcx
// ffffffff81bdae8e:       66 83 79 04 00          cmpw   $0x0,0x4(%rcx)
// ffffffff81bdae93:       0f 84 93 02 00 00       je     ffffffff81bdb12c <tpacket_rcv+0x9ac>

// do_vnet  [0xffffffff81bdae39, 0xffffffff81bdb007): DW_OP_fbreg -120   %rsp + 144 - 120 = %rsp + 0x18
// skb    [0xffffffff81bdabc4, 0xffffffff81bdb248): DW_OP_reg6 RBP
// h/h.raw  [0xffffffff81bdae39, 0xffffffff81bdaf31): DW_OP_reg10 R10, DW_OP_piece 0x8
// macoff   [0xffffffff81bdae39, 0xffffffff81bdb08a): DW_OP_fbreg -124   %rsp + 144 - 124 = %rsp + 0x14
// python -c 'print(hex(0xffffffff81bdae76-0xffffffff81bda780))'
// python -c 'print(hex(0xffffffff81bc0b5a-0xffffffff81bc0580))'

SEC("kprobe/tpacket_rcv+0x5da")
int BPF_KPROBE(prog2)
{
    // get origin addr and the underflow addr

    u64 h_raw = ctx->r10;
    u64 underflow_addr = ctx->ax;
    u64 start_addr = bpf_get_slab_start(h_raw);
    u64 buf_len = bpf_get_buff_len(h_raw);
    u64 end_addr = start_addr + (u32) buf_len;
    int oob = (underflow_addr < start_addr || underflow_addr > end_addr);
    bpf_printk("tpacket_rcv: underflow: h.raw=0x%lx, skb, (h.raw+macoff-sizeof)=0x%lx\n", h_raw, underflow_addr);
    bpf_printk("tpacket_rcv: oob:%d [0x%lx, 0x%lx)\n", oob, start_addr, end_addr);
    if (oob) {
        bpf_printk("\n");
        // restore(ctx, (u64)((u32)(-1)), ret_tpacket_rcv);
    }
    return 0;
}





// 2332 if (do_vnet &&
// 2333	    virtio_net_hdr_from_skb(skb, h.raw + macoff -
// 				    sizeof(struct virtio_net_hdr),
// 				    vio_le(), true, 0)) {
// 		if (po->tp_version == TPACKET_V3)
// 			prb_clear_blk_fill_status(&po->rx_ring);
// 		goto drop_n_account;
// 	}
// oob here, the function is inlined, memset also inlined, oob is here



char LICENSE[] SEC("license") = "Dual BSD/GPL";



// 0x11a26578:     DW_TAG_inlined_subroutine
//                   DW_AT_abstract_origin (0x11a2d325 "virtio_net_hdr_from_skb")
//                   DW_AT_entry_pc        (0xffffffff81bdae76)
//                   DW_AT_unknown_2138    (0x0000)
//                   DW_AT_ranges  (0x012bed70
//                      [0xffffffff81bdae6f, 0xffffffff81bdae71)
//                      [0xffffffff81bdae76, 0xffffffff81bdae99)
//                      [0xffffffff81bdae99, 0xffffffff81bdae99)
//                      [0xffffffff81bdae99, 0xffffffff81bdaea7)
//                      [0xffffffff81bdaea7, 0xffffffff81bdaee1)
//                      [0xffffffff81bdb12c, 0xffffffff81bdb135)
//                      [0xffffffff81bdb142, 0xffffffff81bdb145)
//                      [0xffffffff81bdb145, 0xffffffff81bdb167)
//                      [0xffffffff81bdb167, 0xffffffff81bdb170)
//                      [0xffffffff81bdb1c3, 0xffffffff81bdb1d5))
//                   DW_AT_call_file       ("/root/linux-5.15/net/packet/af_packet.c")
//                   DW_AT_call_line       (2333)
//                   DW_AT_call_column     (0x06)
//                   DW_AT_sibling (0x11a266ea)

// 0xffffffff81c7d329   2333     50      1   0             0
//     ffffffff81c7d329:       0f b7 54 24 1c          movzwl 0x1c(%rsp),%edx
//     ffffffff81c7d32e:       41 83 86 10 03 00 00 01         addl   $0x1,0x310(%r14)
// 0xffffffff81c7d65e   2333     50      1   0             0
//     ffffffff81c7d65e:       0f b7 54 24 1c          movzwl 0x1c(%rsp),%edx  -> STATS
//     ffffffff81c7d663:       31 c9                   xor    %ecx,%ecx
// 0xffffffff81c7d665   2333     50      1   0             0
//     ffffffff81c7d665:       49 8d 44 12 f6          lea    -0xa(%r10,%rdx,1),%rax
//     ffffffff81c7d66a:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)
// 0xffffffff81c7d9d2   2333     50      1   0             0

// // ffffffff81c7d090 <tpacket_rcv>:
// // ffffffff81c7d66a

// 0xffffffff81c7d665

// 0xffffffff81c7d665   2333     50      1   0             0