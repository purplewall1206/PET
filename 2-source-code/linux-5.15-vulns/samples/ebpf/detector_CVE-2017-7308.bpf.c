#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


// policy: req->tp_block_size > BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)
// in net/packet/af_packet.c  packet_set_ring




// ffffffff81d0e695 <packet_set_ring.cold>:
// ...
// ffffffff81d0e6ea:       8b 4b 14                mov    0x14(%rbx),%ecx  [here]
// ffffffff81d0e6ed:       8b 03                   mov    (%rbx),%eax      [%eax:  here is req->tp_block_size]
// ffffffff81d0e6ef:       8d 51 07                lea    0x7(%rcx),%edx
// ffffffff81d0e6f2:       83 e8 30                sub    $0x30,%eax
// ffffffff81d0e6f5:       83 e2 f8                and    $0xfffffff8,%edx [%edx: here is BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)]
// ffffffff81d0e6f8:       29 d0                   sub    %edx,%eax         [prehandler: probe here] 
// ffffffff81d0e6fa:       85 c0                   test   %eax,%eax        
// ffffffff81d0e6fc:       0f 8e 0a 37 e8 ff       jle    ffffffff81b91e0c <packet_set_ring+0x9c>
// policy: %eax >= %edx
// python -c 'print(hex(0xffffffff81d0e6f8 - 0xffffffff81d0e695))'
SEC("kprobe/packet_set_ring.cold+0x63")
int BPF_KPROBE(prog1)
{
    u32 cpu = bpf_get_smp_processor_id();
    u32 pid = bpf_get_current_pid_tgid();
    u32 eax = (u32)ctx->ax;
    u32 edx = (u32)ctx->dx;
    u32 get_rbx_content = 0;
    int err = 0;
    bool chk = eax >= edx;
    bpf_printk("packet_set_ring.cold: %u, %u\n", cpu, pid);
    bpf_printk("packet_set_ring.cold cmp: %x, %x, %u\n", eax, edx, chk);

    err = bpf_probe_read(&get_rbx_content, 4, (void*)ctx->bx);
    if (err < 0) {
        bpf_printk("probe read failed\n");
    }
    bpf_printk("packet_set_ring.cold req->tp_block_size(ebx): %x\n", get_rbx_content);
    return 0;
}


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // addr (pg_vec[i].buffer)
    __type(value, u32); // order of pages
} page_orders SEC(".maps");

//  inlined in packet_set_ring
// static struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)
// {
// 	unsigned int block_nr = req->tp_block_nr;
// 	struct pgv *pg_vec;
// 	int i;
// ...
// for (i = 0; i < block_nr; i++) {
//                   also inlined
// 		pg_vec[i].buffer = alloc_one_pg_vec_page(order);

// so we get addr of pg_vec[i].buffer and order

// ffffffff81d0e695 <packet_set_ring.cold>:
// ...
// ffffffff81d0e7de:       39 4c 24 18             cmp    %ecx,0x18(%rsp)
// ffffffff81d0e7e2:       74 35                   je     ffffffff81d0e819 <packet_set_ring.cold+0x184>
// ffffffff81d0e7e4:       48 63 44 24 18          movslq 0x18(%rsp),%rax
// ffffffff81d0e7e9:       48 8b 4c 24 10          mov    0x10(%rsp),%rcx  // [pg_vec[0]]
// ffffffff81d0e7ee:       bf c0 2d 05 00          mov    $0x52dc0,%edi    // [flag]
// ffffffff81d0e7f3:       8b 74 24 0c             mov    0xc(%rsp),%esi  // [order]
// ffffffff81d0e7f7:       48 8d 04 c1             lea    (%rcx,%rax,8),%rax
// ffffffff81d0e7fb:       48 89 44 24 20          mov    %rax,0x20(%rsp)
// unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);
// ffffffff81d0e800:       e8 7b 31 5a ff          call   ffffffff812b1980 <__get_free_pages>
// ffffffff81d0e805:       48 85 c0                test   %rax,%rax  [probe here]  order is a parameter
// ffffffff81d0e808:       74 59                   je     ffffffff81d0e863 <packet_set_ring.cold+0x1ce>
// ffffffff81d0e80a:       48 8b 4c 24 20          mov    0x20(%rsp),%rcx
// ffffffff81d0e80f:       83 44 24 18 01          addl   $0x1,0x18(%rsp)
// ffffffff81d0e814:       48 89 01                mov    %rax,(%rcx)
// ffffffff81d0e817:       eb c1                   jmp    ffffffff81d0e7da <packet_set_ring.cold+0x145>
// ffffffff81d0e819:       44 89 e6                mov    %r12d,%esi
// python -c 'print(hex(0xffffffff81d0e805 - 0xffffffff81d0e695))'
SEC("kprobe/packet_set_ring.cold+0x170")
int BPF_KPROBE(prog2)
{
    u64 order_addr = ctx->sp + 0xc;
    u64 alloc_addr = ctx->ax;
    int err = 0;
    u32 order;
    bpf_core_read(&order, 4, order_addr);
    bpf_printk("read alloc_on_pg_vec_page: %lx, %u\n", alloc_addr, order);
    err = bpf_map_update_elem(&page_orders, &alloc_addr, &order, BPF_ANY);
    if (err < 0) {
        bpf_printk("update elem failed %d\n", err);
    }
    return 0;
}

// pg_vec  [0xffffffff81d0e7c9, 0xffffffff81d0e7da): DW_OP_fbreg -96
// RSP+112-96 = 0x10(%rsp)
// struct pgv {
//         char *                     buffer;               /*     0     8 */

//         /* size: 8, cachelines: 1, members: 1 */
//         /* last cacheline: 8 bytes */
// };

// order   DW_OP_fbreg -100
// RSP+112-100 = 0xc(%rsp)

// 0xffffffff81d0e695: CFA=RSP+112: RBX=[CFA-56], RBP=[CFA-48], R12=[CFA-40], R13=[CFA-32], R14=[CFA-24], R15=[CFA-16], RIP=[CFA-8]
//   DW_CFA_def_cfa_offset: +16
//   DW_CFA_offset: RBP -16
//   DW_CFA_def_cfa: RSP +8



// static void free_pg_vec(struct pgv *pg_vec, unsigned int order,
// 			unsigned int len)
// for (i = 0; i < len; i++) {
// 		....
// 4255 				free_pages((unsigned long)pg_vec[i].buffer,
// 					   order);
// ffffffff81b8f980 <free_pg_vec>:
// ...
// lea    (%r12,%rax,8),%rbp   // pg_vec[i].buffer(buffer is 1st member)
// ffffffff81b8f9be:       48 8b 7d 00             mov    0x0(%rbp),%rdi
// ...
// ffffffff81b8f9d0:       48 8b 7d 00             mov    0x0(%rbp),%rdi
// ffffffff81b8f9d4:       44 89 f6                mov    %r14d,%esi
// ffffffff81b8f9d7:       e8 24 48 72 ff          call   ffffffff812b4200 <free_pages> [probe here]
// pg_vec  [0xffffffff81b8f99e, 0xffffffff81b8f9e5): DW_OP_reg12 R12
// python -c 'print(hex(0xffffffff81b8f9d7-0xffffffff81b8f980))'
SEC("kprobe/free_pg_vec+0x57")
int BPF_KPROBE(prog3) 
{
    u64 pg_vec_i_buff = ctx->di;
    u32 order = ctx->si;
    int err = 0;
    u32* porder = bpf_map_lookup_elem(&page_orders, &pg_vec_i_buff);
    if (porder) {
        if (*porder == order) {
            bpf_printk("free_pg_vec get : %lx, %u\n", pg_vec_i_buff, order);
        } else {
            bpf_printk("free_pg_vec get wield : %lx, %u  %u\n", pg_vec_i_buff, order, *porder);
        }
        err = bpf_map_delete_elem(&page_orders, &pg_vec_i_buff);
        if (err < 0) {
            bpf_printk("free_pg_vec map delete failed %d\n", err);
        }
    } 

    return 0;
}


// static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
//                struct packet_type *pt, struct et_device *orig_dev)
// //2352 =========buffer overflow=======================
//     skb_copy_bits(skb, 0, h.raw + macoff, snaplen);
// rdi, rsi, rdx, rcx


// ffffffff81b90490 <tpacket_rcv>:
// ...
// ffffffff81b90720:       0f b7 54 24 22          movzwl 0x22(%rsp),%edx
// ...
// ffffffff81b9077e:       8b 4c 24 24             mov    0x24(%rsp),%ecx  // snaplen
// ffffffff81b90782:       4c 01 d2                add    %r10,%rdx  // [h.raw] (the first element %r10), %rdx : macoff
// ffffffff81b90785:       31 f6                   xor    %esi,%esi [0]
// ffffffff81b90787:       48 89 ef                mov    %rbp,%rdi [skb]
// ffffffff81b9078a:       4c 89 54 24 18          mov    %r10,0x18(%rsp)
// ffffffff81b9078f:       e8 4c a0 e5 ff          call   ffffffff819ea7e0 <skb_copy_bits> // [probe here]

// skb  [0xffffffff81b9051a, 0xffffffff81b90f6f): DW_OP_reg6 RBP
// h  [0xffffffff81b906fb, 0xffffffff81b90793): DW_OP_reg10 R10, DW_OP_piece 0x8
// macoff [0xffffffff81b9066c, 0xffffffff81b908e3): DW_OP_fbreg -118, 
// snaplen   [0xffffffff81b906c0, 0xffffffff81b908e3): DW_OP_fbreg -116,  DW_CFA_def_cfa_offset: +152, => 0x24(%rsp)

// python -c 'print(hex(0xffffffff81b9078f-0xffffffff81b90490))'
SEC("kprobe/tpacket_rcv+0x2ff")
int BPF_KPROBE(prog4)
{
    u64 skb = ctx->di;
    u32 offset = ctx->si;
    u64 to = ctx->dx;
    u32 len = ctx->cx;
    u32 h_raw = ctx->r10;
    bpf_printk("src: %016lx  %u\n", skb, offset);
    bpf_printk("dst: %016lx  %u\n", to, len);
    bpf_printk("h.raw: %016lx\n", h_raw);
    u32 *plen = bpf_map_lookup_elem(&page_orders, &skb);
    if (plen) {
        bpf_printk("src: len: %u\n", *plen);
    }
    plen = bpf_map_lookup_elem(&page_orders, &to);
    if (plen) {
        bpf_printk("dst: len: %u\n", *plen);
    }

    plen = bpf_map_lookup_elem(&page_orders, &h_raw);
    if (plen) {
        bpf_printk("dst: len: %u\n", *plen);
    }
    return 0;
}



char LICENSE[] SEC("license") = "Dual BSD/GPL";


// wangzc@wangzc-wangzc:~/Desktop/ko-experiments/linux-5.15$ grep -rni packet_set_ring debuginfo/vmlinux.debug_info 
// 171917867:                DW_AT_name    ("packet_set_ring")

// cat debuginfo/vmlinux.debug_info | tail -n +171917860 | head -n 1000
// 0x10d944ac:     DW_TAG_variable
                //   DW_AT_name    ("req")
                //   DW_AT_decl_file       ("/root/linux-5.15/net/packet/af_packet.c")
                //   DW_AT_decl_line       (4325)
                //   DW_AT_decl_column     (0x16)
                //   DW_AT_type    (0x10d951d5 "tpacket_req*")
                //   DW_AT_location        (0x03a0d3c6: 
                //      [0xffffffff81b91d8a, 0xffffffff81b91dc3): DW_OP_reg4 RSI
                //      [0xffffffff81b91dc3, 0xffffffff81b91e1a): DW_OP_reg3 RBX
                //      [0xffffffff81b91e1a, 0xffffffff81b91e24): DW_OP_GNU_entry_value(DW_OP_reg4 RSI), DW_OP_stack_value
                //      [0xffffffff81b91e24, 0xffffffff81b920aa): DW_OP_reg3 RBX
                //      [0xffffffff81d0e695, 0xffffffff81d0ea4e): DW_OP_reg3 RBX)
                //   DW_AT_unknown_2137    (0x03a0d3bc)

// pahole tpacket_req_u vmlinux
// union tpacket_req_u {
//         struct tpacket_req         req;                /*     0    16 */
//         struct tpacket_req3        req3;               /*     0    28 */
// };
// pahole tpacket_req vmlinux
// struct tpacket_req {
//         unsigned int               tp_block_size;        /*     0     4 */
//         unsigned int               tp_block_nr;          /*     4     4 */
//         unsigned int               tp_frame_size;        /*     8     4 */
//         unsigned int               tp_frame_nr;          /*    12     4 */

//         /* size: 16, cachelines: 1, members: 4 */
//         /* last cacheline: 16 bytes */
// };
// pahole tpacket_req3 vmlinux
// struct tpacket_req3 {
//         unsigned int               tp_block_size;        /*     0     4 */
//         unsigned int               tp_block_nr;          /*     4     4 */
//         unsigned int               tp_frame_size;        /*     8     4 */
//         unsigned int               tp_frame_nr;          /*    12     4 */
//         unsigned int               tp_retire_blk_tov;    /*    16     4 */
//         unsigned int               tp_sizeof_priv;       /*    20     4 */
//         unsigned int               tp_feature_req_word;  /*    24     4 */

//         /* size: 28, cachelines: 1, members: 7 */
//         /* last cacheline: 28 bytes */
// };

// bypass this function
// 4373 if (po->tp_version >= TPACKET_V3 &&
// 4374     (int)(req->tp_block_size - BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)
// 4375     goto out;

// #define BLK_PLUS_PRIV(sz_of_priv) \
	// (BLK_HDR_LEN + ALIGN((sz_of_priv), V3_ALIGNMENT))

// req here is rbx, req->tp_block_size: (%rbx)
// BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv) 
    // req_u->req3: %rbx (union tpacket_req_u == struct tpacket_req3 == struct req)
    // req_u->req3.tp_sizeof_priv:  0x14(%rbp)

// ffffffff81d0e695 <packet_set_ring.cold>:
// ...
// ffffffff81d0e6e0:       41 83 bd f4 04 00 00 01         cmpl   $0x1,0x4f4(%r13)
// ffffffff81d0e6e8:       76 18                   jbe    ffffffff81d0e702 <packet_set_ring.cold+0x6d>
// ffffffff81d0e6ea:       8b 4b 14                mov    0x14(%rbx),%ecx  [here]
// ffffffff81d0e6ed:       8b 03                   mov    (%rbx),%eax      [%eax:  here is req->tp_block_size]
// ffffffff81d0e6ef:       8d 51 07                lea    0x7(%rcx),%edx
// ffffffff81d0e6f2:       83 e8 30                sub    $0x30,%eax
// ffffffff81d0e6f5:       83 e2 f8                and    $0xfffffff8,%edx [%edx: here is BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)]
// ffffffff81d0e6f8:       29 d0                   sub    %edx,%eax         [prehandler: probe here] 
// ffffffff81d0e6fa:       85 c0                   test   %eax,%eax        
// ffffffff81d0e6fc:       0f 8e 0a 37 e8 ff       jle    ffffffff81b91e0c <packet_set_ring+0x9c>