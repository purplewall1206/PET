#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // addr (pg_vec[i].buffer)
    __type(value, u32); // order of pages
} page_orders SEC(".maps");

// *****************integer OOB**********************
// net/packet/af_packet.c
// static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
// 		       struct packet_type *pt, struct net_device *orig_dev)
// ...
// 2268		netoff = TPACKET_ALIGN(po->tp_hdrlen +          // ffffffff81bdafbc
// 2269				       (maclen < 16 ? 16 : maclen)) +
// 2270				       po->tp_reserve;                  // ffffffff81bdafcd
// 2271		// po->tp_reserve is cutoff here by netoff
// 2272		if (po->has_vnet_hdr) {
// ...
// 2330    pr_info("cve-2020-14386: h.raw:%016lx, underflow:%016lx\n", (unsigned long)h.raw, 
// 2331                                            (unsigned long )(h.raw + macoff -sizeof(struct virtio_net_hdr)));
// 2332	if (do_vnet &&                                      // 0xffffffff81bdae63
// 2333	    virtio_net_hdr_from_skb(skb, h.raw + macoff -   // 0xffffffff81bdae71
// 2334				    sizeof(struct virtio_net_hdr),
// 2335				    vio_le(), true, 0)) {

//   CFA=RSP+144:

// ffffffff81bda780 <tpacket_rcv>:
// ...
// ffffffff81bda93d:       83 e0 f0                and    $0xfffffff0,%eax
// ffffffff81bda940:       01 f0                   add    %esi,%eax
// ffffffff81bda942:       66 89 44 24 16          mov    %ax,0x16(%rsp) // 0x16(%rsp) netoff [ prog1 : probe here] the po->tp_reserve is cut off here
// ffffffff81bda947:       41 f6 84 24 cc 04 00 00 04      testb  $0x4,0x4cc(%r12)
// ffffffff81bda950:       0f 85 8d 02 00 00       jne    ffffffff81bdabe3 <tpacket_rcv+0x463>
// ffffffff81bda956:       0f b7 44 24 16          movzwl 0x16(%rsp),%eax 




// netoff: [0xffffffff81bda947, 0xffffffff81bda956): DW_OP_reg0 RAX
            // [0xffffffff81bda956, 0xffffffff81bdaba6): DW_OP_fbreg -122  : %rsp + 144 - 122 = %rsp + 0x16
// po:[0xffffffff81bda7f9, 0xffffffff81bdb20b): DW_OP_reg12 R12
// po->tp_reserve: po+1300
// po->tp_hdrlen: po+1296
// macoff   [0xffffffff81bdae39, 0xffffffff81bdb08a): DW_OP_fbreg -124   %rsp + 144 - 124 = %rsp + 0x14
// python -c 'print(hex(0xffffffff81bda947-0xffffffff81bda780))'
SEC("kprobe/tpacket_rcv+0x1c7")
int BPF_KPROBE(prog1)
{
    // compare the u32 po->tp_reserve, and u16 netoff, that cut off u32 po->tp_reserve
    u64 addr_po = ctx->r12;
    u64 addr_po_tp_reserve = addr_po + 0x04fc;
    u64 val_po_tp_reserve = 0;
    bpf_core_read(&val_po_tp_reserve, 8, addr_po_tp_reserve);

    u16 netoff = ctx->ax;

    bpf_printk("tpacket_rcv: int oob: netoff=0x%hx, po=0x%lx, po->tp_reserve=0x%x\n", netoff, addr_po, val_po_tp_reserve);
 
    return 0;
}

// 0x11a1a05d:     DW_TAG_member
//                   DW_AT_name	("tp_reserve")
//                   DW_AT_decl_file	("/root/linux-5.15/net/packet/internal.h")
//                   DW_AT_decl_line	(133)
//                   DW_AT_decl_column	(0x10)
//                   DW_AT_type	(0x119f41e4 "unsigned int")
//                   DW_AT_data_member_location	(0x04fc)



// ffffffff81bda780 <tpacket_rcv>:
// ...
// ffffffff81bdae63:       80 7c 24 18 00          cmpb   $0x0,0x18(%rsp)  // do_vnet: 0x18(%rsp)
// ffffffff81bdae68:       0f b7 54 24 14          movzwl 0x14(%rsp),%edx  // macoff: 0x14(%rsp)
// ffffffff81bdae6d:       74 72                   je     ffffffff81bdaee1 <tpacket_rcv+0x761>
// ffffffff81bdae6f:       31 c9                   xor    %ecx,%ecx
// ffffffff81bdae71:       49 8d 44 12 f6          lea    -0xa(%r10,%rdx,1),%rax   // h.raw:%r10, macoff:%rax, sizeof(): 0xa
// ffffffff81bdae76:       48 c7 00 00 00 00 00    movq   $0x0,(%rax)  [probe here prog2] get addr in %rax!! real oob!
// ffffffff81bdae7d:       66 89 48 08             mov    %cx,0x8(%rax)
// ffffffff81bdae81:       8b 8d bc 00 00 00       mov    0xbc(%rbp),%ecx
// ffffffff81bdae87:       48 03 8d c0 00 00 00    add    0xc0(%rbp),%rcx
// ffffffff81bdae8e:       66 83 79 04 00          cmpw   $0x0,0x4(%rcx)
// ffffffff81bdae93:       0f 84 93 02 00 00       je     ffffffff81bdb12c <tpacket_rcv+0x9ac>

// do_vnet  [0xffffffff81bdae39, 0xffffffff81bdb007): DW_OP_fbreg -120   %rsp + 144 - 120 = %rsp + 0x18
// skb    [0xffffffff81bdabc4, 0xffffffff81bdb248): DW_OP_reg6 RBP
// h/h.raw  [0xffffffff81bdae39, 0xffffffff81bdaf31): DW_OP_reg10 R10, DW_OP_piece 0x8
// macoff   [0xffffffff81bdae39, 0xffffffff81bdb08a): DW_OP_fbreg -124   %rsp + 144 - 124 = %rsp + 0x14
// python -c 'print(hex(0xffffffff81bdae76-0xffffffff81bda780))'
SEC("kprobe/tpacket_rcv+0x6f6")
int BPF_KPROBE(prog2)
{
    // get origin addr and the underflow addr

    u64 h_raw = ctx->r10;
    u64 underflow_addr = ctx->ax;
    u64 start_addr = bpf_get_slab_start(h_raw);
    u64 buf_len = bpf_get_buff_len(h_raw);
    u64 end_addr = start_addr + (u32) buf_len;
    int oob = (underflow_addr < start_addr || underflow_addr > end_addr);
    bpf_printk("tpacket_rcv: underflow: h.raw=0x%lx, skb, (h.raw+macoff-sizeof)=0x%lx\n", h_raw, underflow_addr);
    bpf_printk("tpacket_rcv: oob:%d [0x%lx, 0x%lx)\n", oob, start_addr, end_addr);

    return 0;
}





// ************** get from CVE-2017-7308**************************
//  inlined in packet_set_ring
// static struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)
// {
// 	unsigned int block_nr = req->tp_block_nr;
// 	struct pgv *pg_vec;
// 	int i;
// ...
// for (i = 0; i < block_nr; i++) {
//                   also inlined
// 		pg_vec[i].buffer = alloc_one_pg_vec_page(order);

// so we get addr of pg_vec[i].buffer and order

// ffffffff81d59f2a <packet_set_ring.cold>:
// ...
// ffffffff81d0e7de:       39 4c 24 18             cmp    %ecx,0x18(%rsp)
// ffffffff81d0e7e2:       74 35                   je     ffffffff81d0e819 <packet_set_ring.cold+0x184>
// ffffffff81d0e7e4:       48 63 44 24 18          movslq 0x18(%rsp),%rax
// ffffffff81d0e7e9:       48 8b 4c 24 10          mov    0x10(%rsp),%rcx  // [pg_vec[0]]
// ffffffff81d0e7ee:       bf c0 2d 05 00          mov    $0x52dc0,%edi    // [flag]
// ffffffff81d0e7f3:       8b 74 24 0c             mov    0xc(%rsp),%esi  // [order]
// ffffffff81d0e7f7:       48 8d 04 c1             lea    (%rcx,%rax,8),%rax
// ffffffff81d0e7fb:       48 89 44 24 20          mov    %rax,0x20(%rsp)
// unsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);
// ffffffff81d5a095:       e8 96 79 55 ff          call   ffffffff812b1a30 <__get_free_pages>
// ffffffff81d5a09a:       48 85 c0                test   %rax,%rax  // order is a parameter
// ffffffff81d0e808:       74 59                   je     ffffffff81d0e863 <packet_set_ring.cold+0x1ce>
// ...
// ffffffff81d5a0f8:       ba 00 10 00 00          mov    $0x1000,%edx
// ffffffff81d5a0fd:       48 c7 c7 ff ff ff ff    mov    $0xffffffffffffffff,%rdi
// ffffffff81d5a104:       48 89 d0                mov    %rdx,%rax
// ffffffff81d5a107:       48 f7 64 24 28          mulq   0x28(%rsp)
// ffffffff81d5a10c:       48 0f 41 f8             cmovno %rax,%rdi
// ffffffff81d5a110:       e8 8b 64 55 ff          call   ffffffff812b05a0 <vzalloc>
// ffffffff81d5a115:       48 85 c0                test   %rax,%rax


// python -c 'print(hex(0xffffffff81d5a09a-0xffffffff81d59f2a))'
// SEC("kprobe/packet_set_ring.cold+0x170")
// int BPF_KPROBE(prog3)
// {
//     u64 order_addr = ctx->sp + 0xc;
//     u64 alloc_addr = ctx->ax;
//     int err = 0;
//     u32 order;
//     bpf_core_read(&order, 4, order_addr);
//     bpf_printk("read alloc_on_pg_vec_page: %lx, %u\n", alloc_addr, order);
//     err = bpf_map_update_elem(&page_orders, &alloc_addr, &order, BPF_ANY);
//     if (err < 0) {
//         bpf_printk("update elem failed %d\n", err);
//     }
//     return 0;
// }

// here vmalloc can directly get addr and length from bpf_get_buff_len
// python -c 'print(hex(0xffffffff81d5a115-0xffffffff81d59f2a))'
// SEC("kprobe/packet_set_ring.cold+0x1eb")
// int BPF_KPROBE(prog3_1)
// {
//     u64 order_addr = ctx->sp + 0xc;
//     u64 alloc_addr = ctx->ax;
//     int err = 0;
//     u32 order;
//     bpf_core_read(&order, 4, order_addr);
//     bpf_printk("read alloc_on_pg_vec_page vmalloc: %lx, %u\n", alloc_addr, order);
//     err = bpf_map_update_elem(&page_orders, &alloc_addr, &order, BPF_ANY);
//     if (err < 0) {
//         bpf_printk("update elem failed %d\n", err);
//     }
//     return 0;
// }

// pg_vec  [0xffffffff81d0e7c9, 0xffffffff81d0e7da): DW_OP_fbreg -96
// RSP+112-96 = 0x10(%rsp)
// struct pgv {
//         char *                     buffer;               /*     0     8 */

//         /* size: 8, cachelines: 1, members: 1 */
//         /* last cacheline: 8 bytes */
// };

// order   DW_OP_fbreg -100
// RSP+112-100 = 0xc(%rsp)

// 0xffffffff81d0e695: CFA=RSP+112: RBX=[CFA-56], RBP=[CFA-48], R12=[CFA-40], R13=[CFA-32], R14=[CFA-24], R15=[CFA-16], RIP=[CFA-8]
//   DW_CFA_def_cfa_offset: +16
//   DW_CFA_offset: RBP -16
//   DW_CFA_def_cfa: RSP +8



// static void free_pg_vec(struct pgv *pg_vec, unsigned int order,
// 			unsigned int len)
// for (i = 0; i < len; i++) {
// 		....
// 4255 				free_pages((unsigned long)pg_vec[i].buffer,
// 					   order);
// ffffffff81b8f980 <free_pg_vec>:
// ...
// lea    (%r12,%rax,8),%rbp   // pg_vec[i].buffer(buffer is 1st member)
// ffffffff81b8f9be:       48 8b 7d 00             mov    0x0(%rbp),%rdi
// ...
// ffffffff81b8f9d0:       48 8b 7d 00             mov    0x0(%rbp),%rdi
// ffffffff81b8f9d4:       44 89 f6                mov    %r14d,%esi
// ffffffff81b8f9d7:       e8 24 48 72 ff          call   ffffffff812b4200 <free_pages> [probe here]
// pg_vec  [0xffffffff81b8f99e, 0xffffffff81b8f9e5): DW_OP_reg12 R12
// python -c 'print(hex(0xffffffff81b8f9d7-0xffffffff81b8f980))'
// SEC("kprobe/free_pg_vec+0x57")
// int BPF_KPROBE(prog4) 
// {
//     u64 pg_vec_i_buff = ctx->di;
//     u32 order = ctx->si;
//     int err = 0;
//     u32* porder = bpf_map_lookup_elem(&page_orders, &pg_vec_i_buff);
//     if (porder) {
//         if (*porder == order) {
//             bpf_printk("free_pg_vec get : %lx, %u\n", pg_vec_i_buff, order);
//         } else {
//             bpf_printk("free_pg_vec get wield : %lx, %u  %u\n", pg_vec_i_buff, order, *porder);
//         }
//         err = bpf_map_delete_elem(&page_orders, &pg_vec_i_buff);
//         if (err < 0) {
//             bpf_printk("free_pg_vec map delete failed %d\n", err);
//         }
//     } 

//     return 0;
// }



char LICENSE[] SEC("license") = "Dual BSD/GPL";



// 0x11a26578:     DW_TAG_inlined_subroutine
//                   DW_AT_abstract_origin (0x11a2d325 "virtio_net_hdr_from_skb")
//                   DW_AT_entry_pc        (0xffffffff81bdae76)
//                   DW_AT_unknown_2138    (0x0000)
//                   DW_AT_ranges  (0x012bed70
//                      [0xffffffff81bdae6f, 0xffffffff81bdae71)
//                      [0xffffffff81bdae76, 0xffffffff81bdae99)
//                      [0xffffffff81bdae99, 0xffffffff81bdae99)
//                      [0xffffffff81bdae99, 0xffffffff81bdaea7)
//                      [0xffffffff81bdaea7, 0xffffffff81bdaee1)
//                      [0xffffffff81bdb12c, 0xffffffff81bdb135)
//                      [0xffffffff81bdb142, 0xffffffff81bdb145)
//                      [0xffffffff81bdb145, 0xffffffff81bdb167)
//                      [0xffffffff81bdb167, 0xffffffff81bdb170)
//                      [0xffffffff81bdb1c3, 0xffffffff81bdb1d5))
//                   DW_AT_call_file       ("/root/linux-5.15/net/packet/af_packet.c")
//                   DW_AT_call_line       (2333)
//                   DW_AT_call_column     (0x06)
//                   DW_AT_sibling (0x11a266ea)

