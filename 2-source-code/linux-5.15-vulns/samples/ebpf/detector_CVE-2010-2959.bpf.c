#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>
// #include <linux/gfp.h>
// #include <linux/slab.h>

// in net/can/bcm.c->bcm_sendmsg.cold(bcm_rx_setup real vulnerability is inlined during the compiler optimization)
// policy: msg_head->nframes < UINT_MAX/16

// ffffffff81d0e828 <bcm_sendmsg.cold>: 
// ....
// ffffffff81d0eb8a:       8b 7d c4                mov    -0x3c(%rbp),%edi  [here]
// ffffffff81d0eb8d:       be c0 0c 00 00          mov    $0xcc0,%esi  [probe here read edi]
// ffffffff81d0eb92:       41 0f af bc 24 f4 00 00 00      imul   0xf4(%r12),%edi
// ffffffff81d0eb9b:       e8 e0 4a 5c ff          call   ffffffff812d3680 <__kmalloc>
// 0xffffffff81d0eb8d - 0xffffffff81d0e828 = 0x365
// python -c 'print(hex(0xffffffff81d0eb8d - 0xffffffff81d0e828))'


// ffffffff81d0ecb7 <bcm_sendmsg.cold>:
// ...
// ffffffff81d0f019:       8b 7d c4                mov    -0x3c(%rbp),%edi
// ffffffff81d0f01c:       be c0 0c 00 00          mov    $0xcc0,%esi
// ffffffff81d0f021:       41 0f af bc 24 f4 00 00 00      imul   0xf4(%r12),%edi
// ffffffff81d0f02a:       e8 51 46 5c ff          call   ffffffff812d3680 <__kmalloc>
// python -c 'print(hex(0xffffffff81d0f01c - 0xffffffff81d0ecb7))' = 0x365  didn't change anything

SEC("kprobe/bcm_sendmsg.cold+0x365")
int BPF_KPROBE(prog1)
{
    u32 cpu = bpf_get_smp_processor_id();
    u32 pid = bpf_get_current_pid_tgid();
    u32 rdi = (u32) ctx->di;
    u32 cmp = 0xffffffff / 16;
    bool chk = rdi < cmp;
    bpf_printk("bcm_sendmsg.cold: cpu=%u, pid=%u\n", cpu, pid);
    bpf_printk("bcm_sendmsg.cold integer OOB: msg_head->nframes=%u, %u, chk=%u\n", rdi, cmp, chk);
    return 0;
}


// if (msg_head->nframes) {  -0x3c(%rbp)
// 			err = copy_from_iter(op->frames, msg_head->nframes * op->cfsiz ( 0xf4(%r12)  ), &msg->msg_iter);

// ffffffff81d0ecb7 <bcm_sendmsg.cold>:

// ffffffff81d0edf5:       8b 45 c4                mov    -0x3c(%rbp),%eax  [msg_head->nframes]
// ffffffff81d0edf8:       85 c0                   test   %eax,%eax
// ffffffff81d0edfa:       74 63                   je     ffffffff81d0ee5f <bcm_sendmsg.cold+0x1a8>
// ffffffff81d0edfc:       41 0f af 84 24 f4 00 00 00      imul   0xf4(%r12),%eax
// ffffffff81d0ee05:       49 8b bc 24 08 01 00 00         mov    0x108(%r12),%rdi  [op->frames]
// ffffffff81d0ee0d:       89 c6                   mov    %eax,%esi  
// ffffffff81d0ee0f:       85 c0                   test   %eax,%eax
// ffffffff81d0ee11:       0f 89 e8 03 00 00       jns    ffffffff81d0f1ff <bcm_sendmsg.cold+0x548>

// ffffffff81d0f1ff:       48 8b 55 88             mov    -0x78(%rbp),%rdx  [&msg->msg_iter]
// ffffffff81d0f203:       e8 f8 7d 80 ff          call   ffffffff81517000 <_copy_from_iter>  [probe here, rdi, rsi, rdx]

// python -c 'print(hex(0xffffffff81d0f203 - 0xffffffff81d0ecb7))'
// size_t _copy_from_iter(void *addr, size_t bytes, struct iov_iter *i)
SEC("kprobe/bcm_sendmsg.cold+0x54c")
int BPF_KPROBE(prog2)
{
    u32 cpu = bpf_get_smp_processor_id();
    u32 pid = bpf_get_current_pid_tgid();
    u64 arg0 = ctx->di;
    u32 arg1 = (u32)ctx->si;
    u64 arg2 = ctx->dx;
    u32 iov_iter_len = BPF_CORE_READ((struct iov_iter*)arg2, count);
    u64 iov_addr = (u64)BPF_CORE_READ((struct iov_iter*)arg2, iov, iov_base);
    u32 iov_len = BPF_CORE_READ((struct iov_iter*)arg2, iov, iov_len);
    bool chk = arg1 <= iov_iter_len;

    // how big is op->frame? 256, we need a helper function.
    bpf_printk("bcm_sendmsg.cold: cpu=%u, pid=%u\n", cpu, pid);
    bpf_printk("bcm_sendmsg.cold: arg0:%lx, arg1=%u, arg2=%lx\n", arg0, arg1, arg2);
    bpf_printk("bcm_sendmsg.cold iov_iter:%u, iov:%lx, iov_len:%u\n", iov_iter_len, iov_addr, iov_len);

    bpf_printk("bcm_sendmsg.cold arg1 <= msg->msg_iter->count : %u\n", chk);
    int buf_len = bpf_get_buff_len(arg0);
    bpf_printk("bcm_sendmsg.cold len(addr)=%d\n", buf_len);
    return 0;
}


//  poc_cfh_baselin-1085    [000] d.Z.1   356.694410: bpf_trace_printk: bcm_sendmsg.cold: arg0:ffff88800723f200, arg1=1024, arg2=ffffc9000015fe38

//  poc_cfh_baselin-1085    [000] d.Z.1   356.694411: bpf_trace_printk: bcm_sendmsg.cold iov_iter:768, iov:7f641f842000, iov_len:824

//  poc_cfh_baselin-1085    [000] d.Z.1   356.694412: bpf_trace_printk: bcm_sendmsg.cold arg1 <= msg->msg_iter->count : 0

//  poc_cfh_baselin-1085    [000] d.Z.1   356.694414: bpf_trace_printk: bcm_sendmsg.cold len(addr)=256


// Here is the vulnerability, copy_from_iter(addr, bytes, iov_iter), where the buff len of addr is 256, but bytes want to write 1024 bytes, and iov_iter passed 768 bytes

// A very large Out-of-bound was found




// #define __iterate_and_advance(i, n, base, len, off, I, K) {	\
// 	if (unlikely(i->count < n))				\
// 		n = i->count;					\    here, i->count(768) < n (1024)

// https://stackoverflow.com/questions/72262410/where-is-source-code-for-cold-functions-located-in-glibc
// The cold attribute on functions is used to inform the compiler that the function is unlikely to be executed. The function is optimized for size rather than speed and on many targets it is placed into a special subsection of the text section so all cold functions appear close together, improving code locality of non-cold parts of program.


char LICENSE[] SEC("license") = "Dual BSD/GPL";

