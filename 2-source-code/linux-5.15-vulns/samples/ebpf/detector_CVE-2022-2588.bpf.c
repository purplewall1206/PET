#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

// struct route4_bucket {        =========(0x0118)========== kmalloc 512        
// 	/* 16 FROM buckets + 16 IIF buckets + 1 wildcard bucket */
// 	struct route4_filter __rcu	*ht[16 + 16 + 1];
// 	struct rcu_head			rcu;
// };

// struct route4_filter {   ===============(0x90)=========== kmalloc 192
// 	struct route4_filter __rcu	*next;
// 	u32			id;
// 	int			iif;
// 	struct tcf_result	res;
// 	struct tcf_exts		exts;  ==========(0x20)==========
// 	u32			handle;
// 	struct route4_bucket	*bkt;
// 	struct tcf_proto	*tp;
// 	struct rcu_work		rwork;
// };

// struct tcf_exts {
// #ifdef CONFIG_NET_CLS_ACT
// 	__u32	type; /* for backward compat(TCA_OLD_COMPAT) */
// 	int nr_actions;
// 	struct tc_action **actions; ===========8===========

// there are 2 dangling ptrs:

// 1. fold, stores in fold->bkt->ht[0], a.k.a struct route4_bucket->ht[0] where stores the route4_filter object
	// if (fold) {
	// 	tcf_unbind_filter(tp, &fold->res);
	// 	tcf_exts_get_net(&fold->exts);
	// 	tcf_queue_work(&fold->rwork, route4_delete_filter_work);
	// }

    // static void __route4_delete_filter(struct route4_filter *f)
    // {
    //     tcf_exts_destroy(&f->exts);
    //     tcf_exts_put_net(&f->exts);
    //     kfree(f);
    // }

const char target[32] = "kmalloc-512";
u32 offset = 0;

// 2. fold->ext.actions, a.k.a route4_filter->ext.actions, 0x20 + 8
// void tcf_exts_destroy(struct tcf_exts *exts)
// {
// #ifdef CONFIG_NET_CLS_ACT
// 	if (exts->actions) {
// 		tcf_action_destroy(exts->actions, TCA_ACT_UNBIND);
// 		kfree(exts->actions);
// 	}
// 	exts->nr_actions = 0;
// #endif
// }
const char target1[32] = "kmalloc-192";
u32 offset1 = 0x28;



struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // start addr of page
    __type(value, u64); 
} store_map SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // start addr of page
    __type(value, u64); 
} store_map1 SEC(".maps");


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // quarantined objects
    __type(value, u64); 
} quaran_obj_map SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // quarantined objects
    __type(value, u64); 
} quaran_obj_map1 SEC(".maps");


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u64); // quarantined flag
    __type(value, u64); 
} quaran_flag SEC(".maps");


struct hmap_elem {
	// int pad; /* unused */
	struct bpf_timer timer;
};

struct inner_map {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(max_entries, 1024);
	__type(key, int);
	__type(value, struct hmap_elem);
} inner_htab SEC(".maps");

#define ARRAY_KEY 1
#define HASH_KEY 1234

struct outer_arr {
	__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
	__uint(max_entries, 100);
	__uint(key_size, sizeof(int));
	__uint(value_size, sizeof(int));
	__array(values, struct inner_map);
} outer_arr SEC(".maps") = {
	.values = { [ARRAY_KEY] = &inner_htab },
};
    



u64 INTERVAL = 6 * 1000000000;
u64 cnt = 0;

static __u64 elem_cnt(struct bpf_map *map, __u32 *key, __u64 *val,
		  void *pdata)
{
    // u64 data = *(u64 *)pdata;
    // *(u64 *)pdata = data + 1;
    return 0;
}

static int timer_sweep(void *map, int *key, struct hmap_elem *val)
{

    int err = 0;
    ++cnt;
    if (cnt % 2 == 0) {
        err = bpf_uaf_slab_sweep(&store_map, &quaran_obj_map, offset, target); 
    } else {
        err = bpf_uaf_slab_sweep(&store_map1, &quaran_obj_map1, offset1, target1);
    }
    if (cnt % 100 == 0) {
        u64 data = 0;
        int elems = bpf_for_each_map_elem(&quaran_obj_map, elem_cnt, &data, 0);
        elems += bpf_for_each_map_elem(&quaran_obj_map1, elem_cnt, &data, 0);
        if (elems > 0) {
            bpf_printk("there is dangling ptr\n");
        }
    }
    // bpf_printk("timer_sweep\n");
    bpf_timer_set_callback(&val->timer, timer_sweep);
    bpf_timer_start(&val->timer, INTERVAL, 0);

    return 0;
}


#define ARRAY_KEY 1
#define HASH_KEY 1234
#define CLOCK_REALTIME			0
#define CLOCK_MONOTONIC			1


int timer_init(void)
{
    int err = 0;
    struct hmap_elem init = {};
	struct bpf_map *inner_map;
	struct hmap_elem *val;
	int array_key = ARRAY_KEY;
	int hash_key = HASH_KEY;

    u32 pid = bpf_get_current_pid_tgid();
    
    u64 v = 0;
    u32 *pval = NULL;


    inner_map = bpf_map_lookup_elem(&outer_arr, &array_key);
    if (!inner_map)
        return 0;
    bpf_map_update_elem(inner_map, &hash_key, &init, 0);
    val = bpf_map_lookup_elem(inner_map, &hash_key);
    if (!val)
        return 0;
    bpf_timer_init(&(val->timer), inner_map, CLOCK_REALTIME);
    err = bpf_timer_set_callback(&val->timer, timer_sweep);
    if (err < 0) {
        bpf_printk("bpf_timer_set_callback failed\n");
        return err;
    }
    err = bpf_timer_start(&val->timer, INTERVAL, 0);
    if (err < 0) {
        bpf_printk("bpf_timer_start failed\n");
        return err;
    }

    bpf_printk("==========initialized===========\n");
}

int init_flag = 0;
SEC("kprobe/kfree")
int BPF_KPROBE(initialized)
{
    int err = 0;
    u32 pid = bpf_get_current_pid_tgid();
    u64 v = 0;
    u32 *pval = NULL;
    u32 *pv1 = NULL;
    // err = bpf_map_update_elem(&quaran_flag, &cpu, &pid, BPF_ANY);
    u64 obj_addr = ctx->di;
    pval = bpf_map_lookup_elem(&quaran_flag, &obj_addr);
    if (pval != NULL) {
        // skip the kfree and quarantine the freed object
        v = bpf_get_buff_len(obj_addr);
        // bpf_printk("__route4_delete_filter %u: %lx:%u\n", pid, obj_addr, v);

        if (*pval == 0) {
            pv1 = bpf_map_lookup_elem(&quaran_obj_map1, &obj_addr);
            if (pv1) {
                bpf_printk("===double free %u: %lx=====\n", v, obj_addr);
            }
            err = bpf_map_update_elem(&quaran_obj_map1, &obj_addr, &v, BPF_ANY);
        } else if (*pval == 1) {
            pv1 = bpf_map_lookup_elem(&quaran_obj_map, &obj_addr);
            if (pv1) {
                bpf_printk("===double free %u: %lx=====\n", v, obj_addr);
            }
            err = bpf_map_update_elem(&quaran_obj_map, &obj_addr, &v, BPF_ANY);
        } 
        err |= bpf_map_delete_elem(&quaran_flag, &obj_addr);
        if (err < 0) {
            bpf_printk("quarantine failed %d\n", err);
            return -1;
        }
        bpf_override_return(ctx, 0);
    }

// ========timer init===================
    if (!init_flag) {
        init_flag = 1;
        timer_init();
    }
    
    return 0;
}


// ffffffff81ac2770 <__route4_delete_filter>:
// ...
// ffffffff81ac2779:       48 83 c7 20             add    $0x20,%rdi
// ffffffff81ac277d:       e8 6e 1f fc ff          call   ffffffff81a846f0 <tcf_exts_destroy>      ffffffff81ac277e: R_X86_64_PLT32        tcf_exts_destroy-0x4
// ffffffff81ac2782:       48 8b 7d 30             mov    0x30(%rbp),%rdi
// ...
// ffffffff81ac27ab:       5d                      pop    %rbp
// ffffffff81ac27ac:       e9 9f 57 81 ff          jmp    ffffffff812d7f50 <kfree> ffffffff81ac27ad: R_X86_64_PLT32        kfree-0x4

// python -c 'print(hex(0xffffffff81ac27ac-0xffffffff81ac2770))'
SEC("kprobe/__route4_delete_filter+0x3c")
int BPF_KPROBE(prog8)
{
    u32 pid = bpf_get_current_pid_tgid();
    u64 val = 1;
    u64 quaran_addr = ctx->di;
    int err = bpf_map_update_elem(&quaran_flag, &quaran_addr, &val, BPF_ANY);
    // bpf_printk("__route4_delete_filter+0x3c %u: %lx\n", pid, quaran_addr);
    if (err < 0) {
        bpf_printk("nft_obj_destroy set flag failed: %d\n", err);
        return -1;
    }
    return 0;
}





// ffffffff81a846b0 <tcf_exts_destroy>:
// ...
// ffffffff81a846c7:       e8 c4 75 00 00          call   ffffffff81a8bc90 <tcf_action_destroy>    ffffffff81a846c8: R_X86_64_PLT32        tcf_action_destroy-0x4
// ffffffff81a846cc:       48 8b 7b 08             mov    0x8(%rbx),%rdi
// ffffffff81a846d0:       e8 3b 38 85 ff          call   ffffffff812d7f10 <kfree> ffffffff81a846d1: R_X86_64_PLT32        kfree-0x4
// python -c 'print(hex(0xffffffff81a846d0-0xffffffff81a846b0))'
SEC("kprobe/tcf_exts_destroy+0x20")
int BPF_KPROBE(prog7)
{
    u32 pid = bpf_get_current_pid_tgid();
    u64 quaran_obj = ctx->di;
    u64 val = 0;
    int err = bpf_map_update_elem(&quaran_flag, &quaran_obj, &val, BPF_ANY);
    // bpf_printk("tcf_exts_destroy+0x20 %u: %lx\n", pid, quaran_obj);
    if (err < 0) {
        bpf_printk("tcf_exts_destroy set flag failed: %d\n", err);
        return -1;
    }
    return 0;
}



char LICENSE[] SEC("license") = "Dual BSD/GPL";


