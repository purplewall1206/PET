#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u64); // addr
    __type(value, u32); 
} race_points SEC(".maps");

// net/unix/af_unix.c
// 2631		last = skb = skb_peek(&sk->sk_receive_queue);
// 2632		last_len = last ? last->len : 0;
// 		// ============cve-2021-4083 race=================== skb

// ffffffff81c06700 <unix_stream_read_generic>:
// ...
// ffffffff81c0682b:       0f 85 d1 08 00 00       jne    ffffffff81c07102 <unix_stream_read_generic+0xa02>
// ffffffff81c06831:       4c 8b ab d0 00 00 00    mov    0xd0(%rbx),%r13
// ffffffff81c06838:       44 8b 44 24 10          mov    0x10(%rsp),%r8d <---
// ffffffff81c0683d:       4c 8d bb d0 00 00 00    lea    0xd0(%rbx),%r15
// ffffffff81c06844:       4d 85 ed                test   %r13,%r13


// ffffffff81c06700 <unix_stream_read_generic>:
// ffffffff81c067eb:       e8 a0 e6 19 00          call   ffffffff81da4e90 <mutex_lock>    ffffffff81c067ec: R_X86_64_PLT32        mutex_lock-0x4
// python -c 'print(hex(0xffffffff81c067eb-0xffffffff81c06700))'
// ffffffff81c06820:       e8 0b 24 1a 00          call   ffffffff81da8c30 <_raw_spin_lock>        ffffffff81c06821: R_X86_64_PLT32        _raw_spin_lock-0x4
// python -c 'print(hex(0xffffffff81c06820-0xffffffff81c06700))'

//   [0xffffffff81c06844, 0xffffffff81c0685f): DW_OP_reg13 R13
// python -c 'print(hex(0xffffffff81c06838-0xffffffff81c06700))'
SEC("kprobe/unix_stream_read_generic+0x138")
int BPF_KPROBE(p0) {
    u64 k = ctx->r13;
    u64 v = 0;
    int err = bpf_map_update_elem(&race_points, &k, &v, BPF_NOEXIST);
    if (err < 0) {
        bpf_printk("race condition in unix_stream_read_generic\n");
    }
    return 0;
}

// python -c 'print(hex(0xffffffff81c0683d-0xffffffff81c06700))'
SEC("kprobe/unix_stream_read_generic+0x13d")
int BPF_KPROBE(v0) {
    u64 k = ctx->r13;
    int err = bpf_map_delete_elem(&race_points, &k);
    return 0;
}



// /net/unix/garbage.c
// 280	skb_queue_head_init(&hitlist); // ============cve-2021-4083 race=================== skb
// 281	list_for_each_entry(u, &gc_candidates, link)

// ffffffff81c09be0 <unix_gc>:
// ...
// ffffffff81c09e67:       48 89 50 08             mov    %rdx,0x8(%rax)
// ffffffff81c09e6b:       48 89 02                mov    %rax,(%rdx)
// ffffffff81c09e6e:       48 8b 44 24 10          mov    0x10(%rsp),%rax <-
// ffffffff81c09e73:       48 39 d8                cmp    %rbx,%rax
// ffffffff81c09e76:       75 c1                   jne    ffffffff81c09e39 <unix_gc+0x259>


// ffffffff81c09be0 <unix_gc>:
// ffffffff81c09c13:       e8 18 f0 19 00          call   ffffffff81da8c30 <_raw_spin_lock>        ffffffff81c09c14: R_X86_64_PLT32        _raw_spin_lock-0x4
// python -c 'print(hex(0xffffffff81c09c13-0xffffffff81c09be0))'
// ffffffff81c09edb:       e8 50 ed 19 00          call   ffffffff81da8c30 <_raw_spin_lock>        ffffffff81c09edc: R_X86_64_PLT32        _raw_spin_lock-0x4


// python -c 'print(hex(0xffffffff81c09e6e-0xffffffff81c09be0))'
SEC("kprobe/unix_gc+0x28e")
int BPF_KPROBE(p1) {
    u64 k = ctx->sp + 0x8 - 64;
    u64 v = 0;
    int err = bpf_map_update_elem(&race_points, &k, &v, BPF_NOEXIST);
    if (err < 0) {
        bpf_printk("race condition in tcp_send_challenge_ack.constprop.0+0x5d\n");
    }
    return 0;
}

// python -c 'print(hex(0xffffffff81c09e73-0xffffffff81c09be0))'
SEC("kprobe/unix_gc+0x293")
int BPF_KPROBE(prog0) {
    u64 k = ctx->sp + 0x8 - 64;
    int err = bpf_map_delete_elem(&race_points, &k);
    return 0;
}

char LICENSE[] SEC("license") = "Dual BSD/GPL";
