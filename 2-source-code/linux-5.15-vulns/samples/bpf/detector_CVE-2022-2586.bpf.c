#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // start addr of page
    __type(value, u64); 
} slab_page_map SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // start addr of page
    __type(value, u64); 
} slab_page_map1 SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // start addr of page
    __type(value, u64); 
} slab_page_map2 SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // quarantined objects
    __type(value, u64); 
} quaran_obj_map SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // quarantined objects
    __type(value, u64); 
} quaran_obj_map1 SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); // quarantined objects
    __type(value, u64); 
} quaran_obj_map2 SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u32); // quarantined flag
    __type(value, u32); 
} quaran_flag SEC(".maps");

struct hmap_elem {
	// int pad; /* unused */
	struct bpf_timer timer;
};

struct inner_map {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(max_entries, 1024);
	__type(key, int);
	__type(value, struct hmap_elem);
} inner_htab SEC(".maps");

#define ARRAY_KEY 1
#define HASH_KEY 1234

struct outer_arr {
	__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
	__uint(max_entries, 100);
	__uint(key_size, sizeof(int));
	__uint(value_size, sizeof(int));
	__array(values, struct inner_map);
} outer_arr SEC(".maps") = {
	.values = { [ARRAY_KEY] = &inner_htab },
};
    

// elem.priv               0xffff8880054a2380
// ext                     0xffff8880054a2388
// nft_set_ext_obj(ext)    0xffff8880054a2398
u32 offset = 0x18;

// obj                     0xffff888008c5e100
// &obj->key/obj->key.name 0xffff888008c5e120
u32 offset1 = 0x20;
// &obj->udata             0xffff888008c5e148
u32 offset2 = 0x48;


// const char target[32] = "skbuff_head_cache";
const char target[32] = "kmalloc-32";
const char target1[32] = "kmalloc-256";
struct kmem_cache *target_cache = NULL;
struct kmem_cache *target_cache1 = NULL;
u64 INTERVAL = 6 * 1000000000;

static int timer_sweep(void *map, int *key, struct hmap_elem *val)
{

    // int err = bpf_uaf_slab_sweep(&slab_page_map, &quaran_obj_map, offset);
    int err = 0;
    err = bpf_uaf_slab_sweep(&slab_page_map1, &quaran_obj_map1, offset1, target1);
    err = bpf_uaf_slab_sweep(&slab_page_map1, &quaran_obj_map2, offset2, target1);
    err = bpf_uaf_slab_sweep(&slab_page_map, &quaran_obj_map, offset, target);
    // bpf_printk("timer_sweep\n");
    bpf_timer_set_callback(&val->timer, timer_sweep);
    bpf_timer_start(&val->timer, INTERVAL, 0);

    return 0;
}


#define ARRAY_KEY 1
#define HASH_KEY 1234
#define CLOCK_REALTIME			0
#define CLOCK_MONOTONIC			1


int timer_init(void)
{
    int err = 0;
    struct hmap_elem init = {};
	struct bpf_map *inner_map;
	struct hmap_elem *val;
	int array_key = ARRAY_KEY;
	int hash_key = HASH_KEY;

    u32 pid = bpf_get_current_pid_tgid();
    
    u64 v = 0;
    u32 *pval = NULL;


    inner_map = bpf_map_lookup_elem(&outer_arr, &array_key);
    if (!inner_map)
        return 0;
    bpf_map_update_elem(inner_map, &hash_key, &init, 0);
    val = bpf_map_lookup_elem(inner_map, &hash_key);
    if (!val)
        return 0;
    bpf_timer_init(&(val->timer), inner_map, CLOCK_REALTIME);
    err = bpf_timer_set_callback(&val->timer, timer_sweep);
    if (err < 0) {
        bpf_printk("bpf_timer_set_callback failed\n");
        return err;
    }
    err = bpf_timer_start(&val->timer, INTERVAL, 0);
    if (err < 0) {
        bpf_printk("bpf_timer_start failed\n");
        return err;
    }

    bpf_printk("==========initialized===========\n");
}

int init_flag = 0;
SEC("kprobe/kfree")
int BPF_KPROBE(initialized)
{
    int err = 0;
    u32 pid = bpf_get_current_pid_tgid();
    u64 v = 0;
    u32 *pval = NULL;
    // err = bpf_map_update_elem(&quaran_flag, &cpu, &pid, BPF_ANY);
    
    pval = bpf_map_lookup_elem(&quaran_flag, &pid);
    if (pval != NULL) {
        // skip the kfree and quarantine the freed object
        u64 obj_addr = (u64) ctx->di;
        bpf_printk("nft_obj_destroy quarantine %u: %lx\n", pid, obj_addr);
        v = bpf_get_buff_len(obj_addr);

        if (*pval == 0) {
            err = bpf_map_update_elem(&quaran_obj_map, &obj_addr, &v, BPF_ANY);
        } else if (*pval == 1) {
            err = bpf_map_update_elem(&quaran_obj_map1, &obj_addr, &v, BPF_ANY);
        } else if (*pval == 2) {
            err = bpf_map_update_elem(&quaran_obj_map2, &obj_addr, &v, BPF_ANY);
        }
        
        
        if (err < 0) {
            bpf_printk("quarantine failed %d\n", err);
            return -1;
        }
        bpf_override_return(ctx, 0);
    }

// ========timer init===================
    if (!init_flag) {
        init_flag = 1;
        timer_init();
    }
    
    return 0;
}




SEC("kprobe/nft_obj_destroy")
int BPF_KPROBE(prog7)
{
    u32 pid = bpf_get_current_pid_tgid();
    u32 val = 0;
    int err = bpf_map_update_elem(&quaran_flag, &pid, &val, BPF_ANY);
    // bpf_printk("nft_obj_destroy start %u: %lx  %lx\n", pid, ctx->di, ctx->bp);
    if (err < 0) {
        bpf_printk("nft_obj_destroy set flag failed: %d\n", err);
        return -1;
    }
    return 0;
}

// ffffffff81b0da30 <nft_obj_destroy>:
// ...
// ffffffff81b0da62:       48 8b 7d 20             mov    0x20(%rbp),%rdi
// ffffffff81b0da66:       e8 e5 a4 7c ff          call   ffffffff812d7f50 <kfree> ffffffff81b0da67: R_X86_64_PLT32        kfree-0x4
// ffffffff81b0da6b:       48 8b 7d 48             mov    0x48(%rbp),%rdi
// ffffffff81b0da6f:       e8 dc a4 7c ff          call   ffffffff812d7f50 <kfree> ffffffff81b0da70: R_X86_64_PLT32        kfree-0x4
// ffffffff81b0da74:       48 89 ef                mov    %rbp,%rdi
// ffffffff81b0da77:       5d                      pop    %rbp
// ffffffff81b0da78:       e9 d3 a4 7c ff          jmp    ffffffff812d7f50 <kfree> ffffffff81b0da79: R_X86_64_PLT32        kfree-0x4

// python3 -c 'print(hex(0xffffffff81b0da6f-0xffffffff81b0da30))'
SEC("kprobe/nft_obj_destroy+0x3f")
int BPF_KPROBE(prog17)
{
    u32 pid = bpf_get_current_pid_tgid();
    u32 val = 1;
    int err = bpf_map_update_elem(&quaran_flag, &pid, &val, BPF_ANY);
    // bpf_printk("nft_obj_destroy start %u: %lx  %lx\n", pid, ctx->di, ctx->bp);
    if (err < 0) {
        bpf_printk("nft_obj_destroy set flag failed: %d\n", err);
        return -1;
    }
    return 0;
}

// python3 -c 'print(hex(0xffffffff81b0da78-0xffffffff81b0da30))'
SEC("kprobe/nft_obj_destroy+0x48")
int BPF_KPROBE(prog27)
{
    u32 pid = bpf_get_current_pid_tgid();
    u32 val = 2;
    int err = bpf_map_update_elem(&quaran_flag, &pid, &val, BPF_ANY);
    // bpf_printk("nft_obj_destroy start %u: %lx  %lx\n", pid, ctx->di, ctx->bp);
    if (err < 0) {
        bpf_printk("nft_obj_destroy set flag failed: %d\n", err);
        return -1;
    }
    return 0;
}

SEC("kretprobe/nft_obj_destroy")
int BPF_KRETPROBE(prog8)
{
    u32 pid = bpf_get_current_pid_tgid();
    int err = bpf_map_delete_elem(&quaran_flag, &pid);
    // bpf_printk("nft_obj_destroy end %u\n", pid);
    if (err < 0) {
        bpf_printk("nft_obj_destroy delete flag failed: %d\n", err);
        return -1;
    }
    return 0;
}


// use

// static int nf_tables_fill_setelem(struct sk_buff *skb,
// 				  const struct nft_set *set,
// 				  const struct nft_set_elem *elem)

// 	if (nft_set_ext_exists(ext, NFT_SET_EXT_OBJREF) &&
// 4822	    nla_put_string(skb, NFTA_SET_ELEM_OBJREF,
// 4823			   (*nft_set_ext_obj(ext))->key.name) < 0)
// 		goto nla_put_failure;



// ffffffff81af6650 <nf_tables_fill_setelem.isra.0>:
// ...
// ffffffff81af6788:       0f b6 43 09             movzbl 0x9(%rbx),%eax
// ffffffff81af678c:       84 c0                   test   %al,%al
// ffffffff81af678e:       74 2b                   je     ffffffff81af67bb <nf_tables_fill_setelem.isra.0+0x16b>
// ffffffff81af6790:       48 8b 04 03             mov    (%rbx,%rax,1),%rax []
// ffffffff81af6794:       4c 8b 68 20             mov    0x20(%rax),%r13

// python -c 'print(hex(0xffffffff81af6790-0xffffffff81af6650))' = 0x140



char LICENSE[] SEC("license") = "Dual BSD/GPL";







//    1. kill process
//    2. inference-> generalize
//    3. position our work? still time window?


// 0x0f801565:   DW_TAG_structure_type
//                 DW_AT_name      ("nft_object")
//                 DW_AT_byte_size (0xc0)
//                 DW_AT_alignment (0x40)
//                 DW_AT_decl_file ("/root/linux-5.15/./include/net/netfilter/nf_tables.h")
//                 DW_AT_decl_line (1192)
//                 DW_AT_decl_column       (0x08)
//                 DW_AT_sibling   (0x0f80160a)

// 0x0f801590:     DW_TAG_member
//                   DW_AT_name    ("key")
//                   DW_AT_decl_file       ("/root/linux-5.15/./include/net/netfilter/nf_tables.h")
//                   DW_AT_decl_line       (1195)
//                   DW_AT_decl_column     (0x1d)
//                   DW_AT_type    (0x0f801534 "nft_object_hash_key")
//                   DW_AT_data_member_location    (0x20)

// 0x0f801534:   DW_TAG_structure_type
//                 DW_AT_name      ("nft_object_hash_key")
//                 DW_AT_byte_size (0x10)
//                 DW_AT_decl_file ("/root/linux-5.15/./include/net/netfilter/nf_tables.h")
//                 DW_AT_decl_line (1175)
//                 DW_AT_decl_column       (0x08)
//                 DW_AT_sibling   (0x0f80155f)

// 0x0f801542:     DW_TAG_member
//                   DW_AT_name    ("name")
//                   DW_AT_decl_file       ("/root/linux-5.15/./include/net/netfilter/nf_tables.h")
//                   DW_AT_decl_line       (1176)
//                   DW_AT_decl_column     (0x23)
//                   DW_AT_type    (0x0f7e3662 "const char*")
//                   DW_AT_data_member_location    (0x00)





// int bpf_strcmp(char *dst, char *src, unsigned int size)
// {
//     for (int i = 0;i < 256;i++) {
//         if (i >= size) {
//             return -1;
//         }
//         if (dst[i] == '\0' && src[i] == '\0') {
//             return i;
//         }
//         if (dst[i] != src[i]) {
//             return -1 * i;
//         }
//     }
//     return 1;
// }



// int isTarget(struct kmem_cache *cache)
// {
//     if (target_cache == NULL) {
//         const char *p;
//         char str[32];
//         bpf_core_read(&p, sizeof(p), &cache->name);
//         bpf_probe_read_kernel_str(str, sizeof(str), p);

//         if (bpf_strcmp(str, target, sizeof(str))) {
//             target_cache = cache;
//             return 1;
//         } else {
//             return 0;
//         }
//     } else if (target_cache == cache) {
//         return 1;
//     } else {
//         return 0;
//     }
// }

// int isTarget1(struct kmem_cache *cache)
// {
//     if (target_cache1 == NULL) {
//         const char *p;
//         char str[32];
//         bpf_core_read(&p, sizeof(p), &cache->name);
//         bpf_probe_read_kernel_str(str, sizeof(str), p);

//         if (bpf_strcmp(str, target1, sizeof(str))) {
//             target_cache1 = cache;
//             return 1;
//         } else {
//             return 0;
//         }
//     } else if (target_cache1 == cache) {
//         return 1;
//     } else {
//         return 0;
//     }
// }

// static struct page *new_slab(struct kmem_cache *s, gfp_t flags, int node)
// s: [0xffffffff812cf4c6, 0xffffffff812cf5b3): DW_OP_reg3 RBX
// SEC("kretprobe/new_slab")**int retprobe, registers are poped, you cannot read them**
// int BPF_KRETPROBE(prog2)
// python -c 'print(hex(0xffffffff812cf47c-0xffffffff812cf290))'
// [0xffffffff812cf2b3, 0xffffffff812cf488): DW_OP_reg3 RBX

// ffffffff812cf473:       f0 48 01 42 28          lock add %rax,0x28(%rdx)
// ffffffff812cf478:       5b                      pop    %rbx
// ffffffff812cf479:       4c 89 e0                mov    %r12,%rax
// SEC("kprobe/new_slab+0x3ed")
// int BPF_KPROBE(prog2) // ret instruction in the new_slab is not in the end.
// {
//     struct kmem_cache *cache = (struct kmem_cache*) ctx->di;
//     struct kmem_cache_order_objects oo = BPF_CORE_READ(cache, oo);
//     struct page *page = ctx->r12;
//     u32 order = (u32) oo.x >> 16;
//     u32 size = BPF_CORE_READ(cache, object_size);
//     int err = 0;
//     u64 key = (u64) page;
//     u64 val = 0;
//     if (isTarget(cache)) {
//         err = bpf_map_update_elem(&slab_page_map, &key, &val, BPF_ANY);
//         if (err < 0) {
//             bpf_printk("new_slab:failed insert:page 0x%lx\n", key);
//             return -1;
//         } 
//         bpf_printk("ret: page:0x%lx, bx:0x%lx, ip:0x%lx\n", ctx->r12, ctx->bx, ctx->ip);
//     } else if (isTarget1(cache)) {
//         err = bpf_map_update_elem(&slab_page_map1, &key, &val, BPF_ANY);
//         if (err < 0) {
//             bpf_printk("new_slab:failed insert:page 0x%lx\n", key);
//             return -1;
//         } 
//         bpf_printk("ret: page:0x%lx, bx:0x%lx, ip:0x%lx\n", ctx->r12, ctx->bx, ctx->ip);
//     }
//     return 0;
// }





// static void __free_slab(struct kmem_cache *s, struct page *page)
// order [0xffffffff812d04a0, 0xffffffff812d04b9): DW_OP_reg14 R14)
// SEC("kprobe/__free_slab")
// int BPF_KPROBE(prog3)
// {
//     struct kmem_cache *cache = (struct kmem_cache*) ctx->di;
//     struct page* page = ctx->si;
//     int err = 0;
//     u64 key = (u64) page;
//     if (isTarget(cache)) {
//         err = bpf_map_delete_elem(&slab_page_map, &key);
//         if (err < 0) {
//             bpf_printk("__free_slab:failed delete:page 0x%lx\n", key);
//             return -1;
//         }
//         bpf_printk("__free_slab: page:0x%lx\n",  page);
//     } else if (isTarget1(cache)) {
//         err = bpf_map_delete_elem(&slab_page_map1, &key);
//         if (err < 0) {
//             bpf_printk("__free_slab:failed delete:page 0x%lx\n", key);
//             return -1;
//         }
//         bpf_printk("__free_slab: page:0x%lx\n",  page);
//     }
//     return 0;
// }




// net/netfilter/nf_tables_api.c 
// static int nf_tables_newobj(struct sk_buff *skb, const struct nfnl_info *info,
// 			    const struct nlattr * const nla[])
// ...
// struct nft_object *obj;
// ...
// obj = nft_obj_lookup(net, table, nla[NFTA_OBJ_NAME], objtype, genmask);
// 6629 	obj->key.name = nla_strdup(nla[NFTA_OBJ_NAME], GFP_KERNEL);
// ...

// static void nft_obj_destroy(const struct nft_ctx *ctx, struct nft_object *obj)
// ...
// 	module_put(obj->ops->type->owner);
//6906 	kfree(obj->key.name);
//6907 	kfree(obj->udata);
// 	kfree(obj); 
// }

// ffffffff81ac7f50 <nft_obj_destroy>:
// ...
// ffffffff81ac7f7d:       e8 8e e3 6b ff          call   ffffffff81186310 <module_put>    ffffffff81ac7f7e: R_X86_64_PLT32        module_put-0x4
// ffffffff81ac7f82:       48 8b 7d 20             mov    0x20(%rbp),%rdi
// ffffffff81ac7f86:       e8 45 fb 80 ff          call   ffffffff812d7ad0 <kfree> ffffffff81ac7f87: R_X86_64_PLT32        kfree-0x4
// ffffffff81ac7f8b:       48 8b 7d 48             mov    0x48(%rbp),%rdi
// ffffffff81ac7f8f:       e8 3c fb 80 ff          call   ffffffff812d7ad0 <kfree> ffffffff81ac7f90: R_X86_64_PLT32        kfree-0x4
// ffffffff81ac7f94:       48 89 ef                mov    %rbp,%rdi
// ffffffff81ac7f97:       e8 34 fb 80 ff          call   ffffffff812d7ad0 <kfree> ffffffff81ac7f98: R_X86_64_PLT32        kfree-0x4
// ffffffff81ac7f9c:       48 89 ee                mov    %rbp,%rsi

// python -c 'print(hex(0xffffffff81ac7f97-0xffffffff81ac7f50 ))'
// SEC("kprobe/nft_obj_destroy+0x47")
// int BPF_KPROBE(prog5) 
// {
//     u32 pid = bpf_get_current_pid_tgid();
//     u32 val = 0;
//     int err = bpf_map_update_elem(&quaran_flag, &pid, &val, BPF_ANY);
//     // bpf_printk("nft_obj_destroy start %u: %lx  %lx\n", pid, ctx->di, ctx->bp);
//     if (err < 0) {
//         bpf_printk("nft_obj_destroy set flag failed: %d\n", err);
//         return -1;
//     }
//     return 0;
// }
// python -c 'print(hex(0xffffffff81ac7f9c-0xffffffff81ac7f50 ))'
// SEC("kprobe/nft_obj_destroy+0x4c")
// int BPF_KPROBE(prog6) 
// {
//     u32 pid = bpf_get_current_pid_tgid();
//     int err = bpf_map_delete_elem(&quaran_flag, &pid);
//     // bpf_printk("nft_obj_destroy end %u\n", pid);
//     if (err < 0) {
//         bpf_printk("nft_obj_destroy delete flag failed: %d\n", err);
//         return -1;
//     }
//     return 0;
// }
// **************because every ptr in the nft_obj_destroy maybe treated as UAF ptr, so quarantine them all*********




// 0xffffffff81b305e0    682     13      5   0             0
// 0xffffffff81b305e0    742     35      5   0             0  is_stmt
// 0xffffffff81b305e0    744      2      5   0             0  is_stmt
// 0xffffffff81b305e0    685     21      5   0             0  is_stmt
// 0xffffffff81b305e0    687      2      5   0             0  is_stmt
// 0xffffffff81b305e0   4823      6      4   0             0