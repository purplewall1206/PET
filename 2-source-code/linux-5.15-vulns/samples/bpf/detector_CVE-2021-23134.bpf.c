#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


char LICENSE[] SEC("license") = "Dual BSD/GPL";

// there is double free on nfc_llcp_sock->local
// quarantine objects: struct nfc_llcp_local *local
        // net/dccp/ccid.c
        // int nfc_llcp_local_put(struct nfc_llcp_local *local)   inlined in this function.
            // return kref_put(&local->ref, local_release);
                // kfree(local);

// dangling ptr store address in struct nfc_llcp_sock kmalloc-1k + 0x310

struct hmap_elem {
	// int pad; /* unused */
	struct bpf_timer timer;
};

struct inner_map {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(max_entries, 1024);
	__type(key, int);
	__type(value, struct hmap_elem);
} inner_htab SEC(".maps");

#define ARRAY_KEY 1
#define HASH_KEY 1234

struct outer_arr {
	__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
	__uint(max_entries, 100);
	__uint(key_size, sizeof(int));
	__uint(value_size, sizeof(int));
	__array(values, struct inner_map);
} outer_arr SEC(".maps") = {
	.values = { [ARRAY_KEY] = &inner_htab },
};


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 4096);
    __type(key, u64); 
    __type(value, u64); 
} dangling_ptr_map SEC(".maps");


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); 
    __type(value, u64); 
} quarantine_map SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u64); // quarantined flag
    __type(value, u64); 
} quaran_flag SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u32); // pid
    __type(value, struct pt_regs); 
} checkpoints SEC(".maps");

u64 offset0 = 0x310;

char target[30] = "kmalloc-1k";

#define ARRAY_KEY 1
#define HASH_KEY 1234
#define CLOCK_REALTIME			0
#define CLOCK_MONOTONIC			1

#define RANGE_FLAG	0
#define OFFSET_FLAG	1


u64 INTERVAL = 1 * (u64)1000000000;

u64 count = 0;

static int timer_sweep(void *map, int *key, struct hmap_elem *val)
{
    int err = 0;
    ++count;


    struct offset_args args1 = {"kmalloc-1k", offset0};
    bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args1, OFFSET_FLAG);
    bpf_uaf_free_undangle(&dangling_ptr_map, &quarantine_map, OFFSET_FLAG);


    bpf_printk("timer_sweep %d\n", count);
    bpf_timer_set_callback(&val->timer, timer_sweep);
    bpf_timer_start(&val->timer, INTERVAL, 0);

    return 0;
}


int timer_init(void)
{
    int err = 0;
    struct hmap_elem init = {};
	struct bpf_map *inner_map;
	struct hmap_elem *val;
	int array_key = ARRAY_KEY;
	int hash_key = HASH_KEY;

    u32 pid = bpf_get_current_pid_tgid();
    
    u64 v = 0;
    u32 *pval = NULL;


    inner_map = bpf_map_lookup_elem(&outer_arr, &array_key);
    if (!inner_map)
        return 0;
    bpf_map_update_elem(inner_map, &hash_key, &init, 0);
    val = bpf_map_lookup_elem(inner_map, &hash_key);
    if (!val)
        return 0;
    bpf_timer_init(&(val->timer), inner_map, CLOCK_REALTIME);
    err = bpf_timer_set_callback(&val->timer, timer_sweep);
    if (err < 0) {
        bpf_printk("bpf_timer_set_callback failed\n");
        return err;
    }
    err = bpf_timer_start(&val->timer, INTERVAL, 0);
    if (err < 0) {
        bpf_printk("bpf_timer_start failed\n");
        return err;
    }

    bpf_printk("==========initialized===========\n");
}



// struct range_args {
// 	unsigned long addr;
// 	unsigned long len;
// };

int init_flag = 0;
SEC("kprobe/kfree")
int BPF_KPROBE(initialized)
{
    int err = 0;
    u64 key = ctx->di ^ 0xffffffffffffffff;
    u64 v = 0;
    u64 *pv = bpf_map_lookup_elem(&quaran_flag, &key);
    if (pv) {
        err = bpf_map_delete_elem(&quaran_flag, &key);
        if (err < 0) {
            bpf_printk("kfree delete quaran_flag failed: %d\n", err);
        }
        err = bpf_map_update_elem(&quarantine_map, &key, &v, BPF_ANY);
        if (err < 0) {
            bpf_printk("kfree update quarantine_map failed: %d\n", err);
        }
    }

// ========timer init===================
    if (!init_flag) {
        init_flag = 1;
        timer_init();
    }
    
    return err;
}




SEC("kprobe/nfc_llcp_local_put")
int BPF_KPROBE(prog1)
{
    u64 local = ctx->di ^ 0xffffffffffffffff;
    u64 val = 0;
    int err = 0;
    bpf_printk("nfc_llcp_local_put free %lx\n", local);
    if (local) {
        bpf_printk("nfc_llcp_local_put free %lx\n", local);
        u64 *pv = bpf_map_lookup_elem(&quarantine_map, &local);
        if (pv) {
            bpf_printk("nfc_llcp_local_put double free: %lx\n", local);
            struct pt_regs x_regs = {};
            x_regs.r15 = ctx->r15 ;
            x_regs.r14 = ctx->r14 ;
            x_regs.r13 = ctx->r13 ;
            x_regs.r12 = ctx->r12 ;
            x_regs.bp  = ctx->bp  ;
            x_regs.bx  = ctx->bx  ;
            x_regs.r11 = ctx->r11;
            x_regs.r10 = ctx->r10;
            x_regs.r9  = ctx->r9 ;
            x_regs.r8  = ctx->r8 ;
            x_regs.ax  = 0 ;
            x_regs.cx  = ctx->cx ;
            x_regs.dx  = ctx->dx ;
            x_regs.si  = ctx->si ;
            x_regs.di  = ctx->di ;
            x_regs.orig_ax = ctx->orig_ax;
            x_regs.ip = 0xffffffff81e0d880;
            x_regs.cs = ctx->cs;
            x_regs.flags = ctx->flags;
            x_regs.sp = ctx->sp;
            x_regs.ss = ctx->ss;

            err = bpf_set_regs(ctx, &x_regs);
            err |= bpf_send_signal(9);
            bpf_printk("nfc_llcp_local_put exit %d\n", err);
            return err;
        }


        err = bpf_map_update_elem(&quaran_flag, &local, &val, BPF_ANY);
        if (err < 0) {
            bpf_printk("nfc_llcp_local_put: %d\n", err);
        }
    }
    return err;
}


