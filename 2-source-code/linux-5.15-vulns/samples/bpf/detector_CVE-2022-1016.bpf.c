#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


// unsigned int
// nft_do_chain(struct nft_pktinfo *pkt, void *priv)
// {
//     ...
// 	struct nft_regs regs;  create
// ...
// next_rule:
// 	rule = *rules;
//182 	regs.verdict.code = NFT_CONTINUE;  use

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u64); // addr
    __type(value, struct nft_regs);  // not a fixed size
} uninitialized_var SEC(".maps");

// ffffffff81ae5480 <nft_do_chain>:
// ...
// ffffffff81ae54ef:       0f 84 03 03 00 00       je     ffffffff81ae57f8 <nft_do_chain+0x378>
// ffffffff81ae54f5:       4c 8b 60 08             mov    0x8(%rax),%r12
// ffffffff81ae54f9:       49 8b 04 24             mov    (%r12),%rax
// ffffffff81ae54fd:       c7 44 24 50 ff ff ff ff         movl   $0xffffffff,0x50(%rsp)


// DW_AT_name      ("regs")
//                 DW_AT_decl_file ("/home/ppw/Documents/ebpf-detector/linux-5.15-vulns/net/netfilter/nf_tables_core.c")
//                 DW_AT_decl_line (165)
//                 DW_AT_decl_column       (0x12)
//                 DW_AT_type      (0x0b85e296 "nft_regs")
//                 DW_AT_location  (DW_OP_breg7 RSP+80)


// struct nft_regs {
//         union {
//                 u32                data[20];             /*     0    80 */
//                 struct nft_verdict verdict;              /*     0    16 */
//         };                                               /*     0    80 */

//         /* size: 80, cachelines: 2, members: 1 */
//         /* last cacheline: 16 bytes */
// };
SEC("kprobe/nft_do_chain")
int BPF_KPROBE(creation) {
    u64 addr = rsp + 80;
    return 0;
}



// python -c 'print(hex(0xffffffff81ae54fd-0xffffffff81ae5480))'
SEC("kprobe/nft_do_chain+0x7d")
int BPF_KPROBE(use) {
    u64 addr = rsp + 80;
    return 0;
}