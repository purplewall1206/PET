#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


u64 ret_show_timer = 0x0;

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u32); // pid
    __type(value, struct pt_regs); 
} checkpoints SEC(".maps");


// SEC("kprobe/show_timer")
// int BPF_KPROBE(checkpoint_setup)
// {
//     u32 pid = bpf_get_current_pid_tgid();
//     struct pt_regs x_regs = {};
//         x_regs.r15 = ctx->r15 ;
//         x_regs.r14 = ctx->r14 ;
//         x_regs.r13 = ctx->r13 ;
//         x_regs.r12 = ctx->r12 ;
//         x_regs.bp  = ctx->bp  ;
//         x_regs.bx  = ctx->bx  ;
//         x_regs.r11 = ctx->r11;
//         x_regs.r10 = ctx->r10;
//         x_regs.r9  = ctx->r9 ;
//         x_regs.r8  = ctx->r8 ;
//         x_regs.ax  = ctx->ax ;
//         x_regs.cx  = ctx->cx ;
//         x_regs.dx  = ctx->dx ;
//         x_regs.si  = ctx->si ;
//         x_regs.di  = ctx->di ;
//     x_regs.orig_ax = ctx->orig_ax;
//         x_regs.ip = ctx->ip;
//         x_regs.cs = ctx->cs;
//         x_regs.flags = ctx->flags;
//         x_regs.sp = ctx->sp;
//         x_regs.ss = ctx->ss;
//     int err = bpf_map_update_elem(&checkpoints, &pid, &x_regs, BPF_ANY);
//     return 0;
// }

// SEC("kretprobe/show_timer")
// int BPF_KRETPROBE(checkpoint_remove)
// {
//     u32 pid = bpf_get_current_pid_tgid();
//     struct pt_regs* pregs = bpf_map_lookup_elem(&checkpoints, &pid);
//     if (pregs) {
//         int err = bpf_map_delete_elem(&checkpoints, &pid);
//     }
//     return 0;
// }

// int restore(struct pt_regs *ctx, u64 errcode, u64 retaddr)
// {
//     int err = bpf_send_signal(9);// SIGKILL
//     u32 pid = bpf_get_current_pid_tgid();
//     struct pt_regs *px_regs = bpf_map_lookup_elem(&checkpoints, &pid);
//     if (px_regs) {
//         px_regs->ax = errcode;
//         px_regs->ip = retaddr;
//         err = bpf_set_regs(ctx, px_regs);
//     }
//     return 0;
// }

// fs/proc/base.c
// static int show_timer(struct seq_file *m, void *v)
//     ...
// 2457	int notify;
// 2458	static const char * const nstr[] = {
//             [SIGEV_SIGNAL] = "signal",
//             [SIGEV_NONE] = "none",
//             [SIGEV_THREAD] = "thread",
//         };
//     ....
// 2471	seq_printf(m, "notify: %s/%s.%d\n",      // rdi, rsi
// 2472		   nstr[notify & ~SIGEV_THREAD_ID],  // rdx
// 2473		   (notify & SIGEV_THREAD_ID) ? "tid" : "pid",  // rcx
// 2474		   pid_nr_ns(timer->it_pid, tp->ns));  // r8


// ffffffff81372b40 <show_timer>:
// ...
// ffffffff81372b82:       49 8b 75 18             mov    0x18(%r13),%rsi
// ffffffff81372b86:       48 8b 7b 68             mov    0x68(%rbx),%rdi
// ffffffff81372b8a:       e8 d1 58 d9 ff          call   ffffffff81108460 <pid_nr_ns>
// ffffffff81372b8f:       41 f6 c4 04             test   $0x4,%r12b
// ffffffff81372b93:       48 89 ef                mov    %rbp,%rdi
// ffffffff81372b96:       48 c7 c1 a4 8a 46 82    mov    $0xffffffff82468aa4,%rcx
// ffffffff81372b9d:       41 89 c0                mov    %eax,%r8d
// ffffffff81372ba0:       48 c7 c0 48 b7 4a 82    mov    $0xffffffff824ab748,%rax
// ffffffff81372ba7:       48 c7 c6 8c b8 4a 82    mov    $0xffffffff824ab88c,%rsi
// ffffffff81372bae:       48 0f 44 c8             cmove  %rax,%rcx
// ffffffff81372bb2:       41 83 e4 fb             and    $0xfffffffb,%r12d
// ffffffff81372bb6:       4d 63 e4                movslq %r12d,%r12
// ffffffff81372bb9:       4a 8b 14 e5 40 9c 23 82         mov    -0x7ddc63c0(,%r12,8),%rdx
// ffffffff81372bc1:       e8 1a 9d f9 ff          call   ffffffff8130c8e0 <seq_printf>


// nstr: 0xffffffff82239c40;
// nstr: len = 3*8
// notify: R12
// SIGEV_THREAD_ID: 4
// python -c 'print(hex(0xffffffff81372bc1-0xffffffff81372b40))'
SEC("kprobe/show_timer+0x81")
int BPF_KPROBE(prog1)
{
    u64 nstr = 0xffffffff82239c40;
    u64 r12 = ctx->r12; // notify & ~SIGEV_THREAD_ID
    u64 nstr_offset = nstr + (u32)r12 * sizeof(char*);
    u64 nstr_end = nstr + 3 * sizeof(char *);

    int oob = (nstr_offset < nstr) || (nstr_offset > nstr_end);

    bpf_printk("show_timer: nstr[notify & ~SIGEV_THREAD_ID]: 0x%lx\n", nstr_offset);
    bpf_printk("show_timer: oob:%d  [0x%lx, 0x%lx)\n", oob, nstr, nstr_end);
    if (oob) {
        bpf_printk("\n");
        // restore(ctx, (u64)((u32)(-1)), ret_show_timer);
    }
    return 0;
}







char LICENSE[] SEC("license") = "Dual BSD/GPL";

// 0x042df742:     DW_TAG_variable
//                   DW_AT_name    ("nstr")
//                   DW_AT_decl_file       ("/root/linux-5.15/fs/proc/base.c")
//                   DW_AT_decl_line       (2458)
//                   DW_AT_decl_column     (0x1c)
//                   DW_AT_type    (0x042c3f51 "const const const char*[3]")
//                   DW_AT_location        (DW_OP_addr 0xffffffff82239c40)

// 0x042df72d:     DW_TAG_variable
//                   DW_AT_name    ("notify")
//                   DW_AT_decl_file       ("/root/linux-5.15/fs/proc/base.c")
//                   DW_AT_decl_line       (2457)
//                   DW_AT_decl_column     (0x06)
//                   DW_AT_type    (0x042bf8ce "int")
//                   DW_AT_location        (0x0129142a: 
//                      [0xffffffff81372b63, 0xffffffff81372bb6): DW_OP_reg12 R12)
//                   DW_AT_unknown_2137    (0x01291428)


// ffffffff813b3bb0 <show_timer>:

// ffffffff813b3c31:       e8 6a 48 f8 ff          call   ffffffff813384a0 <seq_printf>    ffffffff813b3c32: R_X86_64_PLT32        seq_printf-0x4


// 0xffffffff813b3c29   2471      2      1   0             0


// 0xffffffff813b3bf2   2471      2      1   0             0  is_stmt
// 0xffffffff813b3c29   2471      2      1   0             0
