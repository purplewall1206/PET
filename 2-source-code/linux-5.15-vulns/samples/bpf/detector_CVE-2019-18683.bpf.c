#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>


char LICENSE[] SEC("license") = "Dual BSD/GPL";

// kfree in __vb2_queue_free
// quarantine objects: struct vb2_buffer  
        // __vb2_queue_free
        // 
// dangling ptr store address in 1. struct vivid_dev(a very large obj 0x8860) vivid->vb_vid_cap_q (+0x6ee0)
        // range sweep the entire kernel, not in the slab although allocated by kzalloc



struct hmap_elem {
	// int pad; /* unused */
	struct bpf_timer timer;
};

struct inner_map {
	__uint(type, BPF_MAP_TYPE_HASH);
	__uint(max_entries, 1024);
	__type(key, int);
	__type(value, struct hmap_elem);
} inner_htab SEC(".maps");

#define ARRAY_KEY 1
#define HASH_KEY 1234

struct outer_arr {
	__uint(type, BPF_MAP_TYPE_ARRAY_OF_MAPS);
	__uint(max_entries, 100);
	__uint(key_size, sizeof(int));
	__uint(value_size, sizeof(int));
	__array(values, struct inner_map);
} outer_arr SEC(".maps") = {
	.values = { [ARRAY_KEY] = &inner_htab },
};


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 32000000);
    __type(key, u64); 
    __type(value, u64); 
} dangling_ptr_map SEC(".maps");


struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 40960);
    __type(key, u64); 
    __type(value, u64); 
} quarantine_map SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u64); // quarantined flag
    __type(value, u64); 
} quaran_flag SEC(".maps");

u64 offset0 = 0x620;
u64 offset1 = 0x628;

char target[30] = "ccid2_hc_rx_sock";

#define ARRAY_KEY 1
#define HASH_KEY 1234
#define CLOCK_REALTIME			0
#define CLOCK_MONOTONIC			1

#define RANGE_FLAG	0
#define OFFSET_FLAG	1


u64 INTERVAL = 2 * (u64)1000000000;

u64 count = 0;

static int timer_sweep(void *map, int *key, struct hmap_elem *val)
{

    // int err = bpf_uaf_slab_sweep(&slab_page_map, &quaran_obj_map, offset);
    int err = 0;
    unsigned long start_addr = 0xffff888000000000;
    unsigned long GB = (1 << 30);
    unsigned long MB = (1 << 20);
    unsigned long len = 256 * MB;
    ++count;
    // if (count % 2 == 0) {
    //     bpf_printk("odd %lu\n", count);
    // } else {
    //     bpf_printk("even %lu\n", count);
    // }
    // struct range_args args = {0xffff888000000000, ((unsigned long)1 << 30) * (unsigned long)17};
    // start_addr = ((32 + count - 1) % 32) * len + start_addr;
    // struct range_args args = {start_addr, len};
    
    // bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args, RANGE_FLAG);

    // if (count % 16 == 0)
        // bpf_uaf_free_undangle(&dangling_ptr_map, &quarantine_map);


    struct range_args args = {start_addr, len};
    bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args, RANGE_FLAG);
    bpf_printk("sweep dangling ptr from %lx with %lx bytes\n", start_addr, len);
    if (count != 0 && count % 64 == 0) {
        bpf_printk("freeundangle : %d\n", count);
        bpf_uaf_free_undangle(&dangling_ptr_map, &quarantine_map, RANGE_FLAG);
    }
    ++count;

    // struct range_args args = {0x0, ((unsigned long)1 << 30) * (unsigned long)17};
    // bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args, RANGE_FLAG);
    // bpf_uaf_free_undangle(&dangling_ptr_map, &quarantine_map, RANGE_FLAG);

    // struct offset_args args0 = {"DCCPv6", offset0};
    // bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args0, OFFSET_FLAG);
    // struct offset_args args1 = {"DCCPv6", offset1};
    // bpf_uaf_dangling_ptr_sweep(&dangling_ptr_map, &args1, OFFSET_FLAG);
    // bpf_uaf_free_undangle(&dangling_ptr_map, &quarantine_map);


    bpf_printk("timer_sweep %d\n", count);
    bpf_timer_set_callback(&val->timer, timer_sweep);
    bpf_timer_start(&val->timer, INTERVAL, 0);

    return 0;
}


int timer_init(void)
{
    int err = 0;
    struct hmap_elem init = {};
	struct bpf_map *inner_map;
	struct hmap_elem *val;
	int array_key = ARRAY_KEY;
	int hash_key = HASH_KEY;

    u32 pid = bpf_get_current_pid_tgid();
    
    u64 v = 0;
    u32 *pval = NULL;


    inner_map = bpf_map_lookup_elem(&outer_arr, &array_key);
    if (!inner_map)
        return 0;
    bpf_map_update_elem(inner_map, &hash_key, &init, 0);
    val = bpf_map_lookup_elem(inner_map, &hash_key);
    if (!val)
        return 0;
    bpf_timer_init(&(val->timer), inner_map, CLOCK_REALTIME);
    err = bpf_timer_set_callback(&val->timer, timer_sweep);
    if (err < 0) {
        bpf_printk("bpf_timer_set_callback failed\n");
        return err;
    }
    err = bpf_timer_start(&val->timer, INTERVAL, 0);
    if (err < 0) {
        bpf_printk("bpf_timer_start failed\n");
        return err;
    }

    bpf_printk("==========initialized===========\n");
}



// struct range_args {
// 	unsigned long addr;
// 	unsigned long len;
// };

int init_flag = 0;
SEC("kprobe/kfree")
int BPF_KPROBE(initialized)
{
    int err = 0;
    // u32 pid = bpf_get_current_pid_tgid();
    // u64 v = 0;
    // u32 *pval = NULL;
    // err = bpf_map_update_elem(&quaran_flag, &cpu, &pid, BPF_ANY);
    u64 k = ctx->di ^ (u64) 0xffffffffffffffff;
    u64 v = 0;
    u64 *pv = bpf_map_lookup_elem(&quaran_flag, &k);
    if (pv) {
        bpf_printk("quaratine: %lx\n", k);
        err = bpf_map_update_elem(&quarantine_map, &k, &v, BPF_ANY);
        err |= bpf_map_delete_elem(&quaran_flag, &k);
        if (err < 0) {
            bpf_printk("quarantine failed: %d\n", err);
            return err;
        }
    }

// ========timer init===================
    if (!init_flag) {
        init_flag = 1;
        timer_init();
    }
    
    return 0;
}

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 200);
    __type(key, u32); // pid
    __type(value, struct pt_regs); 
} checkpoints SEC(".maps");

SEC("kprobe/__vb2_queue_free")
int BPF_KPROBE(prog0)
{
    int err = 0;
    u32 pid = bpf_get_current_pid_tgid();
    struct pt_regs x_regs = {};
    x_regs.r15 = ctx->r15 ;
    x_regs.r14 = ctx->r14 ;
    x_regs.r13 = ctx->r13 ;
    x_regs.r12 = ctx->r12 ;
    x_regs.bp  = ctx->bp  ;
    x_regs.bx  = ctx->bx  ;
    x_regs.r11 = ctx->r11;
    x_regs.r10 = ctx->r10;
    x_regs.r9  = ctx->r9 ;
    x_regs.r8  = ctx->r8 ;
    x_regs.ax  = ctx->ax ;
    x_regs.cx  = ctx->cx ;
    x_regs.dx  = ctx->dx ;
    x_regs.si  = ctx->si ;
    x_regs.di  = ctx->di ;
    x_regs.orig_ax = ctx->orig_ax;
    x_regs.ip = ctx->ip;
    x_regs.cs = ctx->cs;
    x_regs.flags = ctx->flags;
    x_regs.sp = ctx->sp;
    x_regs.ss = ctx->ss;

    // side affect mitigate of this vuln, see debuginfo in the tail
    u64 k = ctx->di ^ 0xffffffffffffffff;
    u64 v = 0;
    u64 *pv = bpf_map_lookup_elem(&quarantine_map, &k);
    if (pv) {
        x_regs.ip = 0xffffffff81991bbe;
        x_regs.ax = 0;
        err = bpf_set_regs(ctx, &x_regs);
        err |= bpf_send_signal(9);
        bpf_printk("double free/ side affect in __vb2_buf_mem_free: struct vb2_queue *q: %lx, %d\n", k, err);
        return err;
    } else {
        err = bpf_map_update_elem(&quarantine_map, &k, &v, BPF_ANY);
        if (err < 0) {
            bpf_printk("double free/ side affect in __vb2_buf_mem_free: update failed%d\n", err);
        }
    }

    bpf_printk("checkpoint __vb2_queue_free setup pid:%u\n", pid);
    err = bpf_map_update_elem(&checkpoints, &pid, &x_regs, BPF_ANY);
    if (err < 0) {
        bpf_printk("checkpoint setup failed: %d\n", err);
    }

    return err;
}

SEC("kretprobe/__vb2_queue_free")
int BPF_KRETPROBE(prog1)
{
    u32 pid = bpf_get_current_pid_tgid();
    int err = bpf_map_delete_elem(&checkpoints, &pid);
    // if (err < 0) {
    //     bpf_printk("checkpoint remove failed: %d\n", err);    
    // }
    return err;
}



// static int __vb2_queue_free(struct vb2_queue *q, unsigned int buffers)
// 597    for (buffer = q->num_buffers - buffers; buffer < q->num_buffers;
// 598	     ++buffer) {
// 599		kfree(q->bufs[buffer]);
// 600		q->bufs[buffer] = NULL;

// ffffffff81991a20 <__vb2_queue_free>:
// ....
// ffffffff81991b50:       83 c3 01                add    $0x1,%ebx
// ffffffff81991b53:       49 8d 2c c4             lea    (%r12,%rax,8),%rbp
// ffffffff81991b57:       48 8b bd d0 00 00 00    mov    0xd0(%rbp),%rdi
// ffffffff81991b5e:       e8 dd 68 94 ff          call   ffffffff812d8440 <kfree> ffffffff81991b5f: R_X86_64_PLT32        kfree-0x4
// ...
// ffffffff81991bbc:       41 5f                   pop    %r15
// ffffffff81991bbe:       c3                      ret

// python3 -c 'print(hex(0xffffffff81991b5e - 0xffffffff81991a20))'
SEC("kprobe/__vb2_queue_free+0x13e")
int BPF_KPROBE(prog3)
{
    int err = 0;
    u64 q_bufs_i = ctx->di ^ (u64) 0xffffffffffffffff;
    u64 val = 0;
    u64 *pv = bpf_map_lookup_elem(&quarantine_map, &q_bufs_i);
    if (pv) {
        u32 pid = bpf_get_current_pid_tgid();
        struct pt_regs *preg = bpf_map_lookup_elem(&checkpoints, &pid);
        if (preg) {
            preg->ip = 0xffffffff81991bbe;
            preg->ax = 0;
            err = bpf_set_regs(ctx, preg);
        }
        
        err |= bpf_send_signal(9);
        bpf_printk("double free in __vb2_queue_free: %lx, %d\n", q_bufs_i, err);
    }

    err = bpf_map_update_elem(&quaran_flag, &q_bufs_i, &val, BPF_ANY);
    if (err < 0) {
        bpf_printk("quaran_flag failed: %d\n", err);
    }

    return err;
}


// 0000000000000130 <vid_cap_buf_queue>:
//      130:       e8 00 00 00 00          call   135 <vid_cap_buf_queue+0x5>      131: R_X86_64_PLT32     __fentry__-0x4
//      135:       41 54                   push   %r12
//      137:       55                      push   %rbp
//      138:       48 89 fd                mov    %rdi,%rbp
//      13b:       53                      push   %rbx
//      13c:       48 8b 07                mov    (%rdi),%rax
//      13f:       48 8b 58 48             mov    0x48(%rax),%rbx
//      143:       8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 149 <vid_cap_buf_queue+0x19>     145: R_X86_64_PC32      vivid_debug-0x4
//      149:       85 c0                   test   %eax,%eax
//      14b:       0f 85 00 00 00 00       jne    151 <vid_cap_buf_queue+0x21>     14d: R_X86_64_PC32      .text.unlikely-0x4
//      151:       4c 8d a3 e0 47 00 00    lea    0x47e0(%rbx),%r12
//      158:       48 81 c3 80 72 00 00    add    $0x7280,%rbx
//      15f:       4c 89 e7                mov    %r12,%rdi
//      162:       e8 00 00 00 00          call   167 <vid_cap_buf_queue+0x37>     163: R_X86_64_PLT32     _raw_spin_lock-0x4
//      167:       48 8b 43 08             mov    0x8(%rbx),%rax
//      16b:       48 8d 95 a8 03 00 00    lea    0x3a8(%rbp),%rdx
//      172:       4c 89 e7                mov    %r12,%rdi
//      175:       48 89 53 08             mov    %rdx,0x8(%rbx)
//      179:       48 89 9d a8 03 00 00    mov    %rbx,0x3a8(%rbp)
//      180:       48 89 85 b0 03 00 00    mov    %rax,0x3b0(%rbp)
//      187:       48 89 10                mov    %rdx,(%rax)
//      18a:       ff 14 25 00 00 00 00    call   *0x0     18d: R_X86_64_32S       pv_ops+0x278
//      191:       5b                      pop    %rbx
//      192:       5d                      pop    %rbp
//      193:       41 5c                   pop    %r12
//      195:       c3                      ret
//      196:       66 2e 0f 1f 84 00 00 00 00 00   cs nopw 0x0(%rax,%rax,1)



// [   47.788468] BUG: kernel NULL pointer dereference, address: 0000000000000020
// [   47.788816] #PF: supervisor write access in kernel mode
// [   47.789074] #PF: error_code(0x0002) - not-present page
// [   47.789327] PGD 0 P4D 0 
// [   47.789457] Oops: 0002 [#1] SMP
// [   47.789625] CPU: 0 PID: 1166 Comm: poc Not tainted 5.15.0 #352
// [   47.789926] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
// [   47.790347] RIP: 0010:vb2_vmalloc_put+0xe/0x40
// [   47.790577] Code: 00 4c 89 e0 5b 5d 41 5c c3 4c 89 e7 49 c7 c4 f4 ff ff ff e8 24 15 94 ff eb e7 66 90 0f 1f 44 00 00 55 b8 ff ff ff ff 48 89 fd <f0> 0f c1 473
// [   47.791495] RSP: 0018:ffffc900002bbde8 EFLAGS: 00010282
// [   47.791767] RAX: 00000000ffffffff RBX: ffff888007890860 RCX: 0000000000000002
// [   47.792121] RDX: ffff888006d2f000 RSI: 0000000000000001 RDI: 0000000000000000
// [   47.792473] RBP: 0000000000000000 R08: 0000000000000000 R09: ffffc900002bbdb8
// [   47.792818] R10: 0000000000000000 R11: ffff888004b43fd8 R12: ffff888007890800
// [   47.793168] R13: 0000000000000002 R14: 0000000000000000 R15: ffff888007ea1c00
// [   47.793532] FS:  00007f213e3a4700(0000) GS:ffff88803ec00000(0000) knlGS:0000000000000000
// [   47.793925] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
// [   47.794204] CR2: 0000000000000020 CR3: 00000000072dc000 CR4: 00000000000006f0
// [   47.794553] Call Trace:
// [   47.794687]  __vb2_buf_mem_free+0x32/0x60
// [   47.794891]  __vb2_queue_free+0x1d5/0x210
// [   47.795090]  elfcorehdr_read+0x10/0x10
// [   47.795299]  ? _vb2_fop_release+0x7b/0x90
// [   47.795497]  ? v4l2_release+0x75/0xc0
// [   47.795679]  ? __fput+0x8c/0x240
// [   47.795844]  ? task_work_run+0x5f/0x90
// [   47.796028]  ? exit_to_user_mode_prepare+0x14d/0x150
// [   47.796269]  ? syscall_exit_to_user_mode+0x1d/0x40
// [   47.796503]  ? __x64_sys_close+0xe/0x40
// [   47.796691]  ? do_syscall_64+0x48/0x90
// [   47.796873]  ? entry_SYSCALL_64_after_hwframe+0x44/0xae






// [   18.492690] videobuf2_common: driver bug: stop_streaming operation is leaving buf 000000001b18c5cb in active state
// [   18.493567] BUG: kernel NULL pointer dereference, address: 0000000000000000
// [   18.493966] #PF: supervisor write access in kernel mode
// [   18.494248] #PF: error_code(0x0002) - not-present page
// [   18.494523] PGD 0 P4D 0 
// [   18.494662] Oops: 0002 [#1] SMP
// [   18.494837] CPU: 0 PID: 1148 Comm: vivid-000-vid-c Tainted: G        W         5.15.0 #352
// [   18.495294] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014
// [   18.495744] RIP: 0010:memcpy_orig+0x29/0x10f
// [   18.495993] Code: 00 48 89 f8 48 83 fa 20 72 7e 40 38 fe 7c 35 48 83 ea 20 48 83 ea 20 4c 8b 06 4c 8b 4e 08 4c 8b 56 10 4c 8b 5e 18 48 8d 76 20 <4c> 89 07 4c3
// [   18.497003] RSP: 0018:ffffc9000035bbf8 EFLAGS: 00010206
// [   18.497291] RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000001
// [   18.497676] RDX: 00000000000004c0 RSI: ffffc90000671020 RDI: 0000000000000000
// [   18.498020] RBP: 0000000000000000 R08: 80b380b380b380b3 R09: 80b380b380b380b3
// [   18.498365] R10: 80b380b380b380b3 R11: 80b380b380b380b3 R12: 0000000000000000
// [   18.498712] R13: 0000000000000000 R14: ffff888005b86800 R15: 0000000000000000
// [   18.499057] FS:  0000000000000000(0000) GS:ffff88803ec00000(0000) knlGS:0000000000000000
// [   18.499447] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
// [   18.499725] CR2: 0000000000000000 CR3: 0000000006810000 CR4: 00000000000006f0
// [   18.500072] Call Trace:
// [   18.500211]  tpg_fill_plane_buffer+0x965/0xdd0
// [   18.500432]  vivid_fillbuff+0x65d/0xcf0
// [   18.500622]  ? vivid_thread_vid_cap_tick+0x2db/0x750
// [   18.500877]  vivid_thread_vid_cap_tick+0x2db/0x750
// [   18.501111]  ? set_next_entity+0xac/0x1e0
// [   18.501312]  ? __cond_resched+0x15/0x30
// [   18.501512]  ? __mutex_lock.isra.0+0x36/0x460
// [   18.501732]  ? __switch_to_asm+0x36/0x70
// [   18.501945]  vivid_thread_vid_cap+0x152/0x280
// [   18.502168]  ? vivid_thread_vid_cap_tick+0x750/0x750
// [   18.502426]  kthread+0x127/0x150
// [   18.502588]  ? set_kthread_struct+0x40/0x40
// [   18.502793]  ret_from_fork+0x22/0x30
// [   18.502974] Modules linked in:
// [   18.503135] CR2: 0000000000000000
// [   18.503322] ---[ end trace 176b9244d9907765 ]---
// [   18.503586] RIP: 0010:memcpy_orig+0x29/0x10f
// [   18.503824] Code: 00 48 89 f8 48 83 fa 20 72 7e 40 38 fe 7c 35 48 83 ea 20 48 83 ea 20 4c 8b 06 4c 8b 4e 08 4c 8b 56 10 4c 8b 5e 18 48 8d 76 20 <4c> 89 07 4c3
// [   18.504839] RSP: 0018:ffffc9000035bbf8 EFLAGS: 00010206
// [   18.505126] RAX: 0000000000000000 RBX: 0000000000000001 RCX: 0000000000000001
// [   18.505522] RDX: 00000000000004c0 RSI: ffffc90000671020 RDI: 0000000000000000
// [   18.505903] RBP: 0000000000000000 R08: 80b380b380b380b3 R09: 80b380b380b380b3
// [   18.506295] R10: 80b380b380b380b3 R11: 80b380b380b380b3 R12: 0000000000000000
// [   18.506642] R13: 0000000000000000 R14: ffff888005b86800 R15: 0000000000000000
// [   18.506985] FS:  0000000000000000(0000) GS:ffff88803ec00000(0000) knlGS:0000000000000000
// [   18.507371] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
// [   18.507648] CR2: 0000000000000000 CR3: 0000000006810000 CR4: 00000000000006f0




// ffffffff81964cc0 <__vb2_queue_free>:
// ...
// ffffffff81964df4:       49 8b 7c dd 00          mov    0x0(%r13,%rbx,8),%rdi
// ffffffff81964df9:       e8 92 f3 96 ff          call   ffffffff812d4190 <kfree> ffffffff81964dfa: R_X86_64_PLT32        kfree-0x4
// ffffffff81964dfe:       49 c7 44 dd 00 00 00 00 00      movq   $0x0,0x0(%r13,%rbx,8)



// 0xffffffff81964df4    599      3      1   0             0


// 0xffffffff81964deb    599     16      1   0             0
// 0xffffffff81964df0    599     16      1   0             0
// 0xffffffff81964df4    599      3      1   0             0



// ffffffff8196fda0 <vid_cap_buf_queue>:
// ...
// ffffffff8196fddb:       48 8d 95 a8 03 00 00    lea    0x3a8(%rbp),%rdx


// 0xffffffff8196fddb    213      2      1   0             3


// 0xffffffff8196fdc8    213      2      1   0             3
// 0xffffffff8196fdd7    213      2      1   0             3  is_stmt
// 0xffffffff8196fddb    213      2      1   0             3
// 0xffffffff8196fde9    213      2      1   0             3
// 0xffffffff8196fdfa    213     20      4   0             3  is_stmt